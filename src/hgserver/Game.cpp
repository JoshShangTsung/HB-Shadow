#include "Game.h"
#include <cstring>
class CDebugWindow *DbgWnd;
extern void PutLogList(char * cMsg);
extern char G_cTxt[512];
extern char G_cData50000[50000]; 
extern void PutLogFileList(char * cStr);
extern void PutAdminLogFileList(char * cStr);
extern void PutItemLogFileList(char * cStr);
extern void PutLogEventFileList(char * cStr);
extern void PutHackLogFileList(char * cStr);
extern void PutPvPLogFileList(char * cStr);

// extern void PutDebugMsg(char * cStr);	// 2002-09-09 #2

extern FILE * pLogFile;
extern HWND G_hWnd;


int _tmp_iMoveLocX[9][37] = {
	// 0
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	// 1
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, -1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//2
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, -1},
	//3
	{20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, -1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//4
	{20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 19, 18, 17, 16,
		15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
		5, 4, 3, 2, 1, 0, -1},
	//5
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, -1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//6
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 2, 3, 4,
		5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, -1},
	//7
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, -1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//8
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 2, 3, 4,
		5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, -1}
};

int _tmp_iMoveLocY[9][37] = {
	// 0
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//1
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, -1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//2
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, -1},
	//3
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, -1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//4
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 15, 15, 15, 15,
		15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
		15, 15, 15, 15, 15, 15, -1},
	//5
	{15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
		15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
		15, -1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	//6
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, 15, 15, 15, 15,
		15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
		15, 15, 15, 15, 15, 15, -1},
	//7
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		10, 11, 12, 13, 14, 15, -1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0},
	// 8
	{15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
		5, 4, 3, 2, 1, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, -1}
};

char _tmp_cTmpDirX[9] = {0, 0, 1, 1, 1, 0, -1, -1, -1};
char _tmp_cTmpDirY[9] = {0, -1, -1, 0, 1, 1, 1, 0, -1};





extern BOOL G_bIsThread;
extern void ThreadProc(void *ch);

CGame::CGame(HWND hWnd) {
	int i, x;


	m_bIsGameStarted = FALSE;
	m_hWnd = hWnd;
	m_pMainLogSock = NULL;
	m_bIsLogSockAvailable = FALSE;
	m_bIsItemAvailable = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable = FALSE;
	m_bIsMagicAvailable = FALSE;
	m_bIsSkillAvailable = FALSE;
	m_bIsQuestAvailable = FALSE;
	m_bIsPortionAvailable = FALSE;


	std::memset(m_cServerName, 0, sizeof(m_cServerName));

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		m_pPortionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL; // Crafting
	}

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		for (x = 0; x < DEF_MAXPARTYMEMBERS; x++)
			m_stPartyInfo[i].iIndex[x] = 0;
	}

	m_iQueneHead = 0;
	m_iQueneTail = 0;



	m_iTotalClients = 0;
	m_iMaxClients = 0;
	m_iTotalMaps = 0;

	m_iTotalGameServerClients = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;


	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds = 0;
	m_stCityStatus[1].iWins = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds = 0;
	m_stCityStatus[2].iWins = 0;

	m_iAutoRebootingCount = 0;
	m_bEnemyKillMode = FALSE;
	m_iEnemyKillAdjust = 1;
	m_bAdminSecurity = TRUE;
	m_sRaidTimeMonday = 0;
	m_sRaidTimeTuesday = 0;
	m_sRaidTimeWednesday = 0;
	m_sRaidTimeThursday = 0;
	m_sRaidTimeFriday = 0;
	m_sRaidTimeSaturday = 0;
	m_sRaidTimeSunday = 0;
	m_sCharPointLimit = 0;
	m_sSlateSuccessRate = 0;

	//Show Debug Window
	//DbgWnd = new CDebugWindow();
	//DbgWnd->Startup();
	//DbgWnd->AddEventMsg("CGame Startup");
	
	m_bReceivedItemList = FALSE;

}

CGame::~CGame() {
	//DbgWnd->Shutdown();
	//delete DbgWnd;
}

BOOL CGame::bAccept(class XSocket * pXSock) {
	register int i;
	class XSocket * pTmpSock;

	if ((m_bIsLogSockAvailable == FALSE) ||
			  (m_bIsItemAvailable == FALSE) || (m_bIsNpcAvailable == FALSE) ||
			  (m_bIsMagicAvailable == FALSE) || (m_bIsSkillAvailable == FALSE) ||
			  (m_bIsPortionAvailable == FALSE) || (m_bOnExitProcess == TRUE) ||
			  (m_bIsQuestAvailable == FALSE) || (m_bIsBuildItemAvailable == FALSE) ||
			  (m_bIsGameStarted == FALSE))
		goto CLOSE_ANYWAY;

	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] == NULL) {

			m_pClientList[i] = new class CClient(m_hWnd);
			
			bAddClientShortCut(i);
			
			m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime =
					  m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime =
					  m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime =
					  m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();

			pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i);

			
			std::memset(m_pClientList[i]->m_cIPaddress, 0, sizeof(m_pClientList[i]->m_cIPaddress));
			m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);

			wsprintf(G_cTxt, "<%d> Client Connected: (%s)", i, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);




			m_iTotalClients++;

			if (m_iTotalClients > m_iMaxClients) {
				
				m_iMaxClients = m_iTotalClients;
				//GetLocalTime(&m_MaxUserSysTime);
				//wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
				//PutLogFileList(cTxt);
			}

			
			
			return TRUE;
		}

CLOSE_ANYWAY:
	;

	
	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, 0);
	delete pTmpSock;

	return FALSE;
}

void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam) {
	UINT iTmp;
	register int iClientH, iRet;
	DWORD dwTime = timeGetTime();

	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = message - iTmp;

	if (m_pClientList[iClientH] == NULL) return;

	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
		case DEF_XSOCKEVENT_READCOMPLETE:
			OnClientRead(iClientH);
			m_pClientList[iClientH]->m_dwTime = timeGetTime();
			break;

		case DEF_XSOCKEVENT_BLOCK:
			PutLogList("Socket BLOCKED!");
			break;

		case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
			wsprintf(G_cTxt, "<%d> Confirmcode notmatch!", iClientH);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, FALSE, TRUE);
			break;

		case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			wsprintf(G_cTxt, "<%d> Client Disconnected! (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
			PutLogList(G_cTxt);
			if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 1000) {
				wsprintf(G_cTxt, "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
			}

			DeleteClient(iClientH, TRUE, TRUE);
			break;
	}
}

BOOL CGame::bInit() {
	char cTxt[120];
	int i;
	SYSTEMTIME SysTime;
	DWORD dwTime = timeGetTime();

	//m_Misc.Temp();

	PutLogList("(!) INITIALIZING GAME SERVER...");
	//

	for (i = 0; i < DEF_MAXCLIENTS + 1; i++)
		m_iClientShortCut[i] = 0;

	if (m_pMainLogSock != NULL) delete m_pMainLogSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i]; // Crafting
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = 0;


	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}

	for (i = 0; i < DEF_MAXHELDENIAN; i++) {
		m_stHeldenianSchedule[i].iDay = -1;
		m_stHeldenianSchedule[i].StartiHour = -1;
		m_stHeldenianSchedule[i].StartiMinute = -1;
		m_stHeldenianSchedule[i].EndiHour = -1;
		m_stHeldenianSchedule[i].EndiMinute = -1;
	}

	
	m_iNpcConstructionPoint[1] = 100; // MS
	m_iNpcConstructionPoint[2] = 100; // MS
	m_iNpcConstructionPoint[3] = 100; // MS
	m_iNpcConstructionPoint[4] = 100; // MS
	m_iNpcConstructionPoint[5] = 100; // MS
	m_iNpcConstructionPoint[6] = 100; // MS

	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG
	m_iNpcConstructionPoint[51] = 1500; // Catapult
	//

	// Majestic Code By Diuuude
	ReadMajesticSettings();

	m_bIsGameStarted = FALSE;

	m_pMainLogSock = NULL;
	m_bIsLogSockAvailable = FALSE;
	m_bIsItemAvailable = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable = FALSE;
	m_bIsMagicAvailable = FALSE;
	m_bIsSkillAvailable = FALSE;
	m_bIsQuestAvailable = FALSE;
	m_bIsPortionAvailable = FALSE;

	std::memset(m_cServerName, 0, sizeof(m_cServerName));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		m_pPortionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL; // Crafting
	}

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		std::memset(m_stCrusadeStructures[i].cMapName, 0, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = 0;
		m_stCrusadeStructures[i].dX = 0;
		m_stCrusadeStructures[i].dY = 0;
	}

	for (i = 0; i < DEF_MAXADMINS; i++) {
		std::memset(m_stAdminList[i].m_cGMName, 0, sizeof(m_stAdminList[i].m_cGMName));
	}

	for (i = 0; i < DEF_MAXBANNED; i++) {
		std::memset(m_stBannedList[i].m_cBannedIPaddress, 0, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}

	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = 0;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = 0;
		m_stMiddleCrusadeStructureInfo[i].cSide = 0;
		m_stMiddleCrusadeStructureInfo[i].sX = 0;
		m_stMiddleCrusadeStructureInfo[i].sY = 0;
	}
	m_iTotalMiddleCrusadeStructures = 0;

	m_pNoticementData = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients = 0;
	m_iTotalMaps = 0;

	m_iTotalGameServerClients = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex = -1;
	m_iElvineMapIndex = -1;
	m_iBTFieldMapIndex = -1;
	m_iGodHMapIndex = -1;

	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles = 0;

	m_iSubLogSockInitIndex = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds = 0;
	m_stCityStatus[1].iWins = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds = 0;
	m_stCityStatus[2].iWins = 0;

	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana = 0;

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 =
			  m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = FALSE;

	GetLocalTime(&SysTime);
	// dwTime - ³²Àº ¿¹¾à °¡´ÉÇÑ ½Ã°£
	m_dwCanFightzoneReserveTime = dwTime - ((SysTime.wHour % 2)*60 * 60 + SysTime.wMinute * 60) *1000;

	// v1.4311-3 Ãß°¡ º¯¼ö ÃÊ±âÈ­ »çÅõÀå ¿¹¾à °ü·Ã
	for (i = 0; i < DEF_MAXFIGHTZONE; i++)
		m_iFightZoneReserve[i] = 0;

	// v1.4311-3 Ãß°¡ º¯¼ö ÃÊ±âÈ­ »çÅõÀå °­ÄÝ °ü·Ã
	m_iFightzoneNoForceRecall = 0;

	// °¢ ·¹º§º° °æÇèÄ¡ ¸®½ºÆ®¸¦ ÀÛ¼ºÇÑ´Ù.
	for (i = 1; i < 3500; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
		//testcode
		//wsprintf(G_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//PutLogFileList(G_cTxt);
	}

	m_iLimitedUserExp = m_iLevelExpTable[DEF_LEVELLIMIT + 1]; // Ã¼ÇèÆÇ À¯Àú´Â 20·¹º§ÀÌ»óÀÇ °æÇèÄ¡´Â ¾òÀ» ¼ö ¾ø´Ù.  ÀÓ½Ã·Î ·¹º§ 60±îÁö
	m_iLevelExp20 = m_iLevelExpTable[20];

	m_iGameServerMode = 0;
	if (bReadProgramConfigFile("GServer.cfg") == FALSE) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GServer.cfg file contents error!");
		return FALSE;
	}
	if (bReadSettingsConfigFile("..\\GameConfigs\\Settings.cfg") == FALSE) {
		;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings.cfg file contents error!");
		return FALSE;
	}

	if (bReadBallSystemConfigFile("..\\GameConfigs\\BallItems.cfg") == FALSE) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminSettings.cfg file contents error!");
		return FALSE;
	}

	if (bReadAdminListConfigFile("..\\GameConfigs\\AdminList.cfg") == FALSE) {
		;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminList.cfg file contents error!");
		return FALSE;
	}
	if (bReadBannedListConfigFile("..\\GameConfigs\\BannedList.cfg") == FALSE) {
		;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! BannedList.cfg file contents error!");
		return FALSE;
	}
	if (bReadAdminSetConfigFile("..\\GameConfigs\\AdminSettings.cfg") == FALSE) {
		;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminSettings.cfg file contents error!");
		return FALSE;
	}
	srand((unsigned) time(NULL));
	// Main Log Socket·ÎÀÇ ¿¬°á ½Ãµµ
	m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	wsprintf(cTxt, "(!) Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	PutLogList(cTxt);
	//Sleep(100);

	m_bF1pressed = m_bF4pressed = m_bF12pressed = m_bF5pressed = FALSE;

	// ¼­¹ö ¼Ë´Ù¿î ÇÁ·Î¼¼½º º¯¼ö. ÀÌº¯¼ö°¡ ÄÑÁö¸é ´õÀÌ»ó »õ Á¢¼ÓÀ» ¹ÞÁö ¾ÊÀ¸¸ç Å¸ÀÌ¸Ó´ç 50¸í¾¿ °­Á¦ Á¢¼Ó Á¾·á½ÃÅ²´Ù.
	m_bOnExitProcess = FALSE;

	// SkillSSN Æ÷ÀÎÆ®¸¦ ¹Ì¸® °è»êÇØ ³õ´Â´Ù.
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}

	// ÁÖ, ¾ß°£ ¸ðµå ¼³Á¤
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME)
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	// °øÁö»çÇ× ¸Þ½ÃÁö¸¦ ÀÐ´Â´Ù.
	bReadNotifyMsgListFile("notice.txt");
	m_dwNoticeTime = dwTime;

	m_iCurSubLogSockIndex = 0;
	m_iSubLogSockFailCount = 0;
	m_iSubLogSockActiveCount = 0;

	m_pNoticementData = NULL;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount = 0;
	m_bIsCrusadeMode = FALSE;
	m_bIsApocalypseMode = FALSE;

	m_dwCrusadeGUID = 0;
	m_iCrusadeWinnerSide = 0;
	m_iLastCrusadeWinner = 0;
	m_sLastCrusadeDate = -1;
	m_iFinalShutdownCount = 0;
	m_bIsCrusadeWarStarter = FALSE;
	m_iLatestCrusadeDayOfWeek = -1;

	//Heldenian 3.00 Sources
	m_dwHeldenianGUID = 0;
	m_bHeldinianDuty = 0; // new
	m_bHeldenianDutyMultiplyer = 1; // new
	m_cHeldenianModeType = 0;
	m_bIsHeldenianMode = FALSE;
	m_bHeldenianRunning = FALSE;
	m_bHeldenianInitiated = FALSE;
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;
	m_bIsHeldenianReady = FALSE; // new
	m_sLastHeldenianWinner = 0; // new
	std::memset(m_cHeldenianMapName, 0, sizeof(m_cHeldenianMapName)); // new

	//50Cent - Capture The Flag
	m_sFlagCountWin = 0;
	m_bIsCTFMode = false;
	m_bIsElvineFlagCaptured = false;
	m_bIsAresdenFlagCaptured = false;
	m_iFlagCarrierIndex = -1;

	return TRUE;
}

void CGame::OnClientRead(int iClientH) {
	char * pData, cKey;
	DWORD dwMsgSize;

	if (m_pClientList[iClientH] == NULL) return;

	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4

	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == FALSE) {
		// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}

void CGame::DisplayInfo(HDC hdc) {
	char cTxt[350];
	int i, iLine;

	// NT¿¡¼­ ¿¡·¯³²! ÁÖÀÇ
	wsprintf(cTxt, "Server-Name(%s) Max.Level(%d) Players(%d/%d - %d/%d) Crusade(%d:%d) SLSock(%d:%d) RBT(%d)", m_cServerName, m_iPlayerMaxLevel, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients, m_dwCrusadeGUID, (int) m_bIsCrusadeMode, m_iSubLogSockActiveCount, m_iSubLogSockFailCount, m_iAutoRebootingCount);
	TextOut(hdc, 5, 10, cTxt, strlen(cTxt));

	//#ifdef DEF_TESTSERVER
	//	std::memset(cTxt, 0, sizeof(cTxt));
	//	strcpy(cTxt, "인접한 클라이언트들에게 방향전환 이벤트를 알린다. ********** TEST SERVER MODE **********");
	//	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
	//#endif


	iLine = 0;
	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {

			std::memset(G_cTxt, 0, sizeof(G_cTxt));
			wsprintf(G_cTxt, "Map(%s)    Object(%d)    P(%d, %d)    N(%d, %d)    A(%d, %d)    E(%d, %d)    M(%d, %d)",
					  m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject, m_pMapList[i]->m_iMaxPx * 20 + 10, m_pMapList[i]->m_iMaxPy * 20 + 10,
					  m_pMapList[i]->m_iMaxNx * 20 + 10, m_pMapList[i]->m_iMaxNy * 20 + 10, m_pMapList[i]->m_iMaxAx * 20 + 10, m_pMapList[i]->m_iMaxAy * 20 + 10,
					  m_pMapList[i]->m_iMaxEx * 20 + 10, m_pMapList[i]->m_iMaxEy * 20 + 10, m_pMapList[i]->m_iMaxMx * 20 + 10, m_pMapList[i]->m_iMaxMy * 20 + 10);

			TextOut(hdc, 5, 400 + iLine * 15, G_cTxt, strlen(G_cTxt));
			iLine++;
		}
}

void CGame::ClientMotionHandler(int iClientH, char * pData) {

	DWORD * dwp, dwClientTime;
	WORD * wp, wCommand, wTargetObjectID;
	short * sp, sX, sY, dX, dY, wType;
	char * cp, cDir;
	int iRet, iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();
	/*m_pClientList[iClientH]->m_cConnectionCheck++;
	if (m_pClientList[iClientH]->m_cConnectionCheck > 50) {
		wsprintf(G_cTxt, "Hex: (%s) Player: (%s) - removed 03203203h, vital to hack detection.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}*/
	wp = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *) cp;
	sX = *sp;
	cp += 2;

	sp = (short *) cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	sp = (short *) cp;
	dX = *sp;
	cp += 2;

	sp = (short *) cp;
	dY = *sp;
	cp += 2;

	sp = (short *) cp;
	wType = *sp;
	cp += 2;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4
		wp = (WORD *) cp;
		wTargetObjectID = *wp;
		cp += 2;
	}

	// v2.171
	dwp = (DWORD *) cp;
	dwClientTime = *dwp;
	cp += 4;
	CheckDenialServiceAttack(iClientH, dwClientTime);

	switch (wCommand) {
		case DEF_OBJECTSTOP:
			iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
			if (iRet == 1) {
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, 0, 0, 0);
			} else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			break;

		case DEF_OBJECTRUN:
			// ´Þ¸°°Í¿¡ ´ëÇÑ È¿°ú¸¦ Ã³¸®ÇÑ´Ù. Ã¼·Â°¨¼Òµîµî
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 1);
			if (iRet == 1) {
				// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù.
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, 0, 0, 0);
			}
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
			// v2.171
			bCheckClientMoveFrequency(iClientH, dwClientTime);
			break;

		case DEF_OBJECTMOVE:
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 2);
			if (iRet == 1) {
				// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù.
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
			}
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
			// v2.171
			bCheckClientMoveFrequency(iClientH, dwClientTime);
			break;

		case DEF_OBJECTDAMAGEMOVE:
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
			if (iRet == 1) {
				// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù.
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, 0, 0);
			}
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
			break;

		case DEF_OBJECTATTACKMOVE:
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
			if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
				// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù.
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, 0, 0, 0);
				// °ø°Ý È¿°ú¸¦ °è»ê
				iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE, TRUE); // v1.4
			}
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
			// v2.171
			bCheckClientAttackFrequency(iClientH, dwClientTime);
			break;

		case DEF_OBJECTATTACK:
			// ÀÌ À§¿¡¼­ wTypeÀÌ ÇÕ´çÇÑÁö¸¦ ¸ÕÀú Ã³¸®ÇÑ´Ù.
			_CheckAttackType(iClientH, &wType);
			iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
			if (iRet == 1) {
				if (wType >= 20) {
					// ÇÊ»ì±â Ä«¿îÆ®¸¦ °¨¼ÒÇÑ´Ù.
					m_pClientList[iClientH]->m_iSuperAttackLeft--;
					// Ä«¿îÆ®°¡ ¸¶ÀÌ³Ê½º°¡ µÉ ÀÏÀº ¾ø°ÚÁö¸¸ ¿¡·¯ ¹æÁö¿ë
					if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
				}

				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
			} else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			// v2.171
			bCheckClientAttackFrequency(iClientH, dwClientTime);
			break;

		case DEF_OBJECTGETITEM:
			iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
			if (iRet == 1) {
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, 0, 0, 0);
			} else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			break;

		case DEF_OBJECTMAGIC:
			iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
			//client hp recorded here ONLY if its less than
			if (iRet == 1) {
				if (m_pClientList[iClientH]->m_bMagicPauseTime == FALSE) {
					m_pClientList[iClientH]->m_bMagicPauseTime = TRUE;
					iTemp = 10;
					SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, 0);
					m_pClientList[iClientH]->m_iSpellCount++;
					bCheckClientMagicFrequency(iClientH, dwClientTime);
				} else if (m_pClientList[iClientH]->m_bMagicPauseTime == TRUE) {
					wsprintf(G_cTxt, "Cast Delay Hack: (%s) Player: (%s) - player casting too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(iClientH, TRUE, TRUE);
				}
			} else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			break;

		default:
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
//  description			:: Handles how player or npc run, walk, attack, or get flown by attack
//  last updated		:: October 30, 2004; 1:52 AM; Hypnotoad
//	return value		:: int
//  commentary			:: - contains speed hack detection previously unavailable
//						   - changed variable 5 to char, prior BOOL.
//								1 = object run
//								2 = object malk
//								0 = object damage move, object attack move
//						   - fixed bump bug removing aura
/////////////////////////////////////////////////////////////////////////////////////
// Missing 3.51:
//			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h
// 			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
//
/////////////////////////////////////////////////////////////////////////////////////

int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType) {
	char * cp, cData[3000];
	class CTile * pTile;
	DWORD * dwp;
	WORD * wp, wObjectID;
	short * sp, dX, dY, sTemp, sTemp2, sDOtype, pTopItem;
	int * ip, iRet, iSize, iDamage;
	BOOL bRet, bIsBlocked = FALSE;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8)) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	/*dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	if (cMoveType == 2) {
		if (m_pClientList[iClientH]->m_iRecentWalkTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentWalkTime < dwTime) {
					m_pClientList[iClientH]->m_sV1++;
				}
				else {
					bIsBlocked = TRUE;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
		}
		if (bIsBlocked == FALSE) m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (590)) {
					//wsprintf(G_cTxt, "3.51 Walk Speeder: (%s) Player: (%s) walk difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwMoveLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = TRUE;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else if (cMoveType == 1) {
		if (m_pClientList[iClientH]->m_iRecentRunTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentRunTime < dwTime) {
					m_pClientList[iClientH]->m_sV1++;
				}
				else {
					bIsBlocked = TRUE;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
		}
		if (bIsBlocked == FALSE) m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (290)) {
					//wsprintf(G_cTxt, "3.51 Run Speeder: (%s) Player: (%s) run difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwRunLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = TRUE;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}*/

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
			case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++;
				break;
			case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;
				break;
			case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;
				break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
		case 1: dY--;
			break;
		case 2: dX++;
			dY--;
			break;
		case 3: dX++;
			break;
		case 4: dX++;
			dY++;
			break;
		case 5: dY++;
			break;
		case 6: dX--;
			dY++;
			break;
		case 7: dX--;
			break;
		case 8: dX--;
			dY--;
			break;
	}

	pTopItem = 0;
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, &pTopItem);

	if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
		bRet = FALSE;

	if ((bRet == TRUE) && (bIsBlocked == FALSE)) {
		if (m_pClientList[iClientH]->m_iQuest) _bCheckIsQuestCompleted(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX = dX;
		m_pClientList[iClientH]->m_sY = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short) iClientH,
				  DEF_OWNERTYPE_PLAYER,
				  dX, dY);

		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral == TRUE) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {

			} else {
				iDamage = iDice(2, 4);

				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
					m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;

		dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOVE_CONFIRM;

		cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *) cp;
		*sp = (short) (dX - 10);
		cp += 2;

		sp = (short *) cp;
		*sp = (short) (dY - 7);
		cp += 2;

		*cp = cDir;
		cp++;

		if (cMoveType == 1) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			} else {
				*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) {
					m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
		} else *cp = 0;
		cp++;

		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		*cp = (char) pTile->m_iOccupyStatus;
		cp++;

		ip = (int *) cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;

		iSize = iComposeMoveMapData((short) (dX - 10), (short) (dY - 7), iClientH, cDir, cp);
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
		}
		/*if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h == TRUE) {

			.text:00406037                 mov     [ebp+var_C1C], 0
			.text:0040603E                 xor     edx, edx
			.text:00406040                 mov     [ebp+var_C1B], edx
			.text:00406046                 mov     [ebp+var_C17], edx
			.text:0040604C                 mov     [ebp+var_C13], dx

			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
			if (bRet == 1) {
				RequestTeleportHandler(iClientH, "2   ", cTemp, wV1, wV2);
			}
		}*/
	} else {
		m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE;

		dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOVE_REJECT;
		if (bIsBlocked == TRUE) {
			m_pClientList[iClientH]->m_dwAttackLAT = 1050;
		}
		m_pClientList[iClientH]->m_dwAttackLAT = 1010;

		wObjectID = (WORD) iClientH;

		cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

		wp = (WORD *) cp;
		*wp = wObjectID;
		cp += 2;

		sp = (short *) cp;
		sX = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;

		sp = (short *) cp;
		sY = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;

		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;

		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;

		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;

		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;

		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;

		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;

		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;

		ip = (int *) cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;

		ip = (int *) cp;
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
		sTemp = (sTemp | (sTemp2 << 28));
		*ip = sTemp;
		cp += 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 42);

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
		}
		return 0;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

	return 1;
}

void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey) {
	register int i;
	char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
	BOOL bIsObserverMode;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

	// ÇÃ·¹ÀÌ¾îÀÇ ÀÌ¸§, °èÁ¤ÀÇ ÀÌ¸§, ÆÐ½º¿öµå¸¦ ±â·ÏÇÏ°í ·Î±× ¼­¹ö·Î ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ Àü¼ÛÀ» ¿äÃ»ÇÑ´Ù.

	std::memset(cCharName, 0, sizeof(cCharName));
	std::memset(cAccountName, 0, sizeof(cAccountName));
	std::memset(cAccountPassword, 0, sizeof(cAccountPassword));

	std::memset(m_pClientList[iClientH]->m_cCharName, 0, sizeof(m_pClientList[iClientH]->m_cCharName));
	std::memset(m_pClientList[iClientH]->m_cAccountName, 0, sizeof(m_pClientList[iClientH]->m_cAccountName));
	std::memset(m_pClientList[iClientH]->m_cAccountPassword, 0, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	std::memset(cTxt, 0, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	std::memset(cCharName, 0, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;

	std::memset(cTxt, 0, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	std::memset(cAccountName, 0, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	std::memset(cTxt, 0, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	std::memset(cAccountPassword, 0, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);

	bIsObserverMode = (BOOL) * cp;
	cp++;

	// Áßº¹µÈ °èÁ¤À» °®°íÀÖ´Â Ä³¸¯ÅÍ¸¦ »èÁ¦ÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
			// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏ¸é ¶Õ°í µé¾î°¥ ¼ö ÀÖ´Ù. ±×·¯³ª ´Ù¸£¸é Á¢¼Ó ºÒ°¡.
			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÑ´Ù.
				wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt);
				DeleteClient(i, TRUE, TRUE, FALSE); // 3¹øÂ° FALSE:·Î±× ¼­¹ö·Î Ä«¿îÆÃ ´Ù¿îÀº ÇÏÁö ¸»¶ó´Â ¸Þ½ÃÁö
			} else {
				// v1.4 °èÁ¤ Á¤º¸¸¦ ÀÔ·ÂÇØ¾ß ·Î±×ÀÎ ¼­¹ö·Î Åëº¸°¡ °¡´ÉÇÏ´Ù.
				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

				// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù.  Á¢¼Ó ºÒ°¡.
				DeleteClient(iClientH, FALSE, FALSE, FALSE);
				return;
			}
		}

	// Áßº¹µÈ ÀÌ¸§À» °®°í ÀÖ´Â Ä³¸¯ÅÍ°¡ ÀÖ´Ù¸é ¸¶Âù°¡Áö·Î »èÁ¦
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
			// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏ¸é ¶Õ°í µé¾î°¥ ¼ö ÀÖ´Ù. ±×·¯³ª ´Ù¸£¸é Á¢¼Ó ºÒ°¡.
			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt);
				DeleteClient(i, TRUE, TRUE, FALSE);
			} else {
				// v1.4 °èÁ¤ Á¤º¸¸¦ ÀÔ·ÂÇØ¾ß ·Î±×ÀÎ ¼­¹ö·Î Åëº¸°¡ °¡´ÉÇÏ´Ù.
				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

				// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù.  Á¢¼Ó ºÒ°¡.
				DeleteClient(iClientH, FALSE, FALSE);
				return;
			}
		}

	// Á¤º¸ ÀÔ·Â
	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;

	// Log Server·Î µ¥ÀÌÅÍ ¿äÃ» ¸Þ½ÃÁö¸¦ º¸³½´Ù.
	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

// 05/22/2004 - Hypnotoad - sends client to proper location after dieing

void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey) {
	BOOL bFlag;
	char * pBuffer = NULL;
	short * sp;
	DWORD * dwp;
	WORD * wp;
	char * cp, cPlayerName[11], cTxt[120];
	int sSummonPoints;
	int * ip, i, iTotalItemA, iTotalItemB, iSize, iRet, iStats;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;

	pBuffer = new char [DEF_MSGBUFFERSIZE + 1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE + 1);

	// íš„íšœíš„íšŽ íšì§–ì©Œíš™ ì¨‰ì§œ?íš‘íš‡íš’ì¨ì§ ?ì²´ì©Œíš¤íš‰íš  íšíš ì¨ˆíš¢. ì©”ì§¤ì§¹ì°½ì©Œì§¯ ?íš‘ì¨ì§ ?íš‘ ?íš•íš†ì§•íš‰íš•ì¨ˆíš‚íšì²  íšŠì§°?íš“íš‰íš˜ ì©Œì² ì¨‰ì¨‰ ?íšœì¨ˆíš¢.
	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);
	std::memset(cPlayerName, 0, sizeof(cPlayerName));
	memcpy(cPlayerName, cp, 10);

	std::memset(cTxt, 0, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, 10);
	m_Misc.bDecode(cKey, cTxt);
	std::memset(cPlayerName, 0, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, 10);

	// ?íš‘ì¨ì§ ?íš‘ ?íš•íš†ì§•íš‰íš•ì¨ˆíš‚íšì²  ì§¸íšì¨©ì±Œíš‰íš—ì¨ˆíš¢. ?íš•íš†ì§•íš‰íš•íšì²  ì©íšŽ?ì¨ì¨ì±• ì¨©ì±”íšì§íš‰íš•ì§¸ì±  ì§¹íš’íšŠì§±íš‰íš—ì¨ˆíš¢.
	if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) {
		DeleteClient(iClientH, FALSE, TRUE);
		return;
	}

	// íš†ì¨€ì¨ì§±íš‡íš’?íš‰ ì©íš‡ì¨©ì²˜íšì§šì¨˜ì¨ì¨ì§ ?ì²´ì©Œíš¤íš‰íš—ì¨ˆíš¢.
	dwp = (DWORD *) (pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS; // 0x0Fm_cHeldenianVictoryType000 = 262406144
	wp = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp = DEF_MSGTYPE_CONFIRM;

	cp = (char *) (pBuffer + DEF_INDEX2_MSGTYPE + 2);

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iMP;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iSP;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iDefenseRatio;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iHitRatio;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iLevel;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iStr;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iInt;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iVit;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iDex;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iMag;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iCharisma;
	cp += 4;

	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
			  m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma);

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLevel * 3 - (iStats - 70);
	wp = (WORD *) cp;
	//*wp = m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70);
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;

	*cp = m_pClientList[iClientH]->m_cVar;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iExp;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iPKCount;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iRewardGold;
	cp += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp += 20;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iGuildRank;
	cp += 4;

	// v1.4311
	*cp = (char) m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	// v1.4311-3 íš„íš©ì§¸ì§• ì¨©ì±Œíš‡ì²œ?ì±…ì©”ì¨”ì©íšª ì©”ì§¤ì¨˜íš“ì¨ì§ íš‡ì§­ì¨‹ì²˜?íš‘ì©ì±¨íšˆì§°ì©”ì§• ì¨˜ì¨ì¨€ì©ì¨ˆíš¢.
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp += 4;

	//Syntax : ======HP==MP==SP==DRatHRatLVL=STR=INT=VIT=DEX=MAG=CHR=LUstatEXP=EK==PK==RewaLocation==GuildName=RankAF
	//Syntax : 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
	//Syntax : ......145212521152........376.200=200=200=200=200=195=......big.8...17......aresden...NONE......NONE30
	// 0x0Fm_cHeldenianVictoryType000 = 262406144
	// ì¨íš§ì©íš„íšì²  ?ì²´ì©Œíš¤

	//Debug Event
	//DbgWnd->AddEventMsg(MSG_SEND,pBuffer,180,0);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 118); // Original : 115
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ì¨íš§ì©íš„íšì² ì¨ì§ ì¨˜ì¨ì¨€ì©ì¨‹ì§  ì©”ì§•ì¨Œì§±ì§¸ì§• ì¨”íš©ì¨©ì²µíš‰íš©ì¨ˆíš¢ì¨ì±• íšì§ì§¸íš‡íš‰íš—ì¨ˆíš¢.
			DeleteClient(iClientH, TRUE, TRUE);
			if (pBuffer != NULL) delete pBuffer;
			return;
	}

	// íš†ì¨€ì¨ì§±íš‡íš’?íš‰ ì©íšˆ?íš‘íš‡íš¤ íšì§šì¨˜ì¨ì¨ì§ ?ì²´ì©Œíš¤íš‰íš—ì¨ˆíš¢.
	dwp = (DWORD *) (pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp = DEF_MSGTYPE_CONFIRM;

	// ì¨íš›?ì²¬ ì©Œíš˜íšì² íš‰íš•ì§¸ì±  ?íšœì¨ˆíš‚ ì©íšˆ?íš‘íš‡íš¤
	// ì©íšˆ?íš‘íš‡íš¤?íš‰ íš„íš— ì§¸ì¨”ì©Œì² 
	bFlag = FALSE; // Kaozures - Adaptado darmart123.
	while (bFlag == FALSE) {
		bFlag = TRUE;
		for (i = 0; i < DEF_MAXITEMS - 1; i++)
			if ((m_pClientList[iClientH]->m_pItemList[i] == NULL) && (m_pClientList[iClientH]->m_pItemList[i + 1] != NULL)) {
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemList[i + 1];
				m_pClientList[iClientH]->m_pItemList[i + 1] = NULL;
				m_pClientList[iClientH]->m_ItemPosList[i].x = m_pClientList[iClientH]->m_ItemPosList[i + 1].x;
				m_pClientList[iClientH]->m_ItemPosList[i].y = m_pClientList[iClientH]->m_ItemPosList[i + 1].y;
				bFlag = FALSE;
			}
	}
	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
			iTotalItemA++;

	cp = (char *) (pBuffer + DEF_INDEX2_MSGTYPE + 2);

	*cp = iTotalItemA;
	cp++;

	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			// ì©”ì§•ì¨Œì§± ì¨”ì±ˆíšì² ì©”ì±˜ íš†íš£ì¨‰ì±…?íš‘ì¨ˆíš¢. ì¨”ì§°íšì§ì§¸ì§• ?íšœì¨ˆíš‚ íš†ì¨€ì¨ì§±íš‡íš’?íš‰ ì¨‰ì§œ?íš‘íš‡íš’ì¨ì§ ì¨˜íš–ì©Œì§°íš‰íš˜ì§¸íš’. ì©”íšœ ì¨€íš“?íš•ì§¹ì±¤?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if (pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp = (DWORD *) cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char) m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp = (short *) cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *) cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *) cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char) m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41
		cp++;
		dwp = (DWORD *) cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		/*
		 *cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); // Custom-Item?íš“íšì² ?íš‰ ì©”ì§¤ì¨˜íš“
		cp++;
		 */
	}

	// ì¨ˆíš¢?ì© ì¨˜ì¨ì§¸ì²´íšíš©?íš“ ì©íšˆ?íš‘íš‡íš¤
	// ì©íšˆ?íš‘íš‡íš¤?íš‰ íš„íš— ì§¸ì¨”ì©Œì² 
	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL)
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;

	for (i = 0; i < iTotalItemB; i++) {
		// ### ?íš‰ì©íš‹ì©ì¨˜ì¨Œì§±ì©”ì±¤ ERROR POINT
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			// ì©”ì§•ì¨Œì§± ì¨”ì±ˆíšì² ì©”ì±˜ íš†íš£ì¨‰ì±…?íš‘ì¨ˆíš¢. ì¨”ì§°íšì§ì§¸ì§• ?íšœì¨ˆíš‚ íš†ì¨€ì¨ì§±íš‡íš’?íš‰ ì¨‰ì§œ?íš‘íš‡íš’ì¨ì§ ì¨˜íš–ì©Œì§°íš‰íš˜ì§¸íš’. ì©”íšœ ì¨€íš“?íš•ì§¹ì±¤?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if (pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp = (DWORD *) cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp = (short *) cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *) cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *) cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char) m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41
		cp++;
		dwp = (DWORD *) cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		/*
		 *cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-Item?íš“íšì² ?íš‰ ì©”ì§¤ì¨˜íš“
		cp++;
		 */
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	// ì©íšˆ?íš‘íš‡íš¤ íšì§šì¨˜ì¨ ?ì²´ì©Œíš¤
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA * 44 + iTotalItemB * 43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ì¨íš§ì©íš„íšì² ì¨ì§ ì¨˜ì¨ì¨€ì©ì¨‹ì§  ì©”ì§•ì¨Œì§±ì§¸ì§• ì¨”íš©ì¨©ì²µíš‰íš©ì¨ˆíš¢ì¨ì±• íšì§ì§¸íš‡íš‰íš—ì¨ˆíš¢.
			DeleteClient(iClientH, TRUE, TRUE);
			if (pBuffer != NULL) delete pBuffer;
			return;
	}

	// ì¨íšŽì¨‰ì§œ?íš‘íš‡íš’ì¨ì§ ?ì²´ì©Œíš¤íš‰íš—ì¨ˆíš¢.
	dwp = (DWORD *) (pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp = DEF_MSGTYPE_CONFIRM;

	cp = (char *) (pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ ?ì§ íš†ì§•ì¨ì§ íšŠì§°íšì§šíš‰íš—ì¨ˆíš¢. v1.41 ì§¸ì²´ì¨‹ì²¨?íš£ ì¨ì±¨ì¨‰ì±…ì¨‹ì²˜ì¨ì±• ì§¹íšž?ì§ íš†ì§• ì§¹íšžì¨ˆì±˜ì¨Œíš“ ì¨€ì²œì¨ˆíš‚ì¨ˆíš¢.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp = (WORD *) cp;
	*wp = iClientH;
	cp += 2;

	// ?ì²´ì©Œíš¤íš‰íš˜ ì¨íšŽ ì¨‰ì§œ?íš‘íš‡íš’?íš‰ ì§¹ì°½íšíš ?ì§ íš†ì§•. íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤ì¨ˆíš‚ ì§¹ì°½íšíš ?ì§ íš†ì§• (x, y)ì¨Œíš“ì¨˜íš“íš‡íš’ (x+14, y+12)ì©”ì§• ?ì§ íš†ì§•íš‰íš—ì¨ˆíš¢.
	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip = (int *) cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4; // Original : 2

	// (!) íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤ì§¸ì§• ?ì§ íš†ì§•íš‰íš•ì¨ˆíš‚ ì¨íšŽ?íš‘ì¨ì§ ?ì¨© ì§¹ì°½ì¨Œíš•íš‰íš—ì¨ˆíš¢.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// ì¨ì± íš†ì§§ì¨©ì²˜?íš‰ ì¨íšŽ ?íš‘ì¨ì§ ?ì¨© ?íššì¨Œíš‚íš‰íš—ì¨ˆíš¢.
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// íšíšœì©íš©ì§¸ì§™ ì¨ì±¨ì¨‰ì±…ì¨ì§ ì¨©ì±¨?íšš
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// ì§¹ì°½ì¨©ì²˜ ì¨©ì²˜íš‡íš‚ ì¨ì±¨ì¨‰ì±…ì¨ì§ ì¨©ì±¨?íšš
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)
		*cp = 0;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤ì¨ì§ ì¨íšŽì¨©ì²˜ì©”ì§• íš„íšœíš„íšŽì¨Œíš“ ?ì§ íš†ì§•ì©íš„íš‡ì§¼ì¨ˆíš¢.

	// v1.41 ì©”ì§¤ì§¹ì°½ì©Œì§¯ ì§¸ì²´ì¨‹ì²¨?íš£ ì¨ì±¨ì¨‰ì±…ì¨‹ì²˜ì¨ì±• ?ì§ íš†ì§•ì©íš„íš‡ì§¸íšì²  ì©íšŽì¨ˆíš‚ì¨ˆíš¢.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
				  DEF_OWNERTYPE_PLAYER,
				  m_pClientList[iClientH]->m_sX,
				  m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char) m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;
	// catches debug on player load up

	// v1.41
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;

	//Unknown variable
	*cp = 0;
	cp++;

	// ì¨íšŽ?íš‰ íšì§šì¨˜ì¨ì¨ì§ íš„íš©ì§¸ì§•íš‰íš—ì¨ˆíš¢.
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp);

	// ì¨íš§ì©íš„íšì²  ?ì²´ì©Œíš¤
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize + 4 + 4 + 1 + 4 + 4 + 3); // Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 59 + iSize +4 +4 +1 +4 +4); // v1.41
	//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ì¨íš§ì©íš„íšì² ì¨ì§ ì¨˜ì¨ì¨€ì©ì¨‹ì§  ì©”ì§•ì¨Œì§±ì§¸ì§• ì¨”íš©ì¨©ì²µíš‰íš©ì¨ˆíš¢ì¨ì±• íšì§ì§¸íš‡íš‰íš—ì¨ˆíš¢.
			DeleteClient(iClientH, TRUE, TRUE);
			if (pBuffer != NULL) delete pBuffer;
			return;
	}

	if (pBuffer != NULL) delete pBuffer;

	// ì¨ˆíš¢ì¨ì§œ íš‡ì§­ì¨‹ì²˜?íš‘ì©ì±¨íšˆì§°ì¨‰ì±•ì©”ì§•ì§¸íšš ì¨©ì²œ íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤ íšì§–ì©Œíš™?ì¨© ì©íšì¨ì§¸ì¨ˆíš¢.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	// �÷��̾ �ٸ� �ʿ� ����. ���� ���̶�� �ð��� �����Ѵ�.
	// v2.13 ��ڴ� ���ݵ��� �ʴ´�.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) &&
			  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
			  && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// v2.17 2002-7-15 ���� �ð��� ���� �� �� �ְ� �����Ѵ�.
		SetForceRecallTime(iClientH);
	}// v2.13 ��ڴ� ���ݵ��� �ʴ´�.
	else if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) &&
			  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			  && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 ���� �ð��� ���� �� �� �ְ� �����Ѵ�.
		SetForceRecallTime(iClientH);
	} else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) ||
			  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
			  && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;
			// ���ݽð��� 5�� ���� ���
		} else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20 * 5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5; // 5��
		}

	} else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
			  (m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		// ��ڰ� ���ݸ�带 �������� �ʴ°�쿡�� ����Ÿ���� �����ȴ�.

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// �������� �� �ִ� ���� �ð��� ������ �ش�.
		// 0 �ú��� 2�ð� �������� ���ȴ� �� 0�ÿ� �����ϸ� 2�ð����� ���� ������ �ִ�.
		// �������� �ð� ���̸� ����Ͽ� �����ð� 2�� �ִ�. �� 2�ð� �Ǳ� 2������� ���ݵȴ�.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2)*20 * 60 + SysTime.wMinute * 20) - 2 * 20;
	} else {
		m_pClientList[iClientH]->m_bIsWarLocation = FALSE;
		// v1.42
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		// 06/11/2004
		SetForceRecallTime(iClientH);
	}

	// v2.17 2002-7-15 ���� �ð��� ����ڿ��� �����ش�.
	if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_pClientList[iClientH]->m_bIsWarLocation == TRUE)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, 0, 0, NULL);
		wsprintf(G_cTxt, "(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall / 20);
		PutLogList(G_cTxt);
	}


	// No entering enemy shops
	int iMapside, iMapside2;

	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideOwnTown = FALSE;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideOwnTown = TRUE;
			}
		}
	} else {
		if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone == TRUE &&
				  m_iFightzoneNoForceRecall == FALSE &&
				  m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2)*20 * 60 + SysTime.wMinute * 20) - 2 * 20;
		} else {
			if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "arejail", 7) == 0 ||
					  memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "elvjail", 7) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
				}
			}
		}
	}

	/*if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) &&
		(m_pClientList[iClientH]->m_bIsWarLocation == TRUE)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
	}*/

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) {
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, NULL);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, NULL);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMPOSLIST, 0, 0, 0, NULL);

	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, NULL);
	}

	// Crusade íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ CrusadeGUIDì§¸ì§• 0 íšŠì§š?ì¨˜ íš‰ì² ?ì±Œì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ì±• íš„ì¨€?ì© íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì¨ˆíš‚ ì§¸íš’?íš‘ì¨ˆíš¢. íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• 0?íš‘ì¨‹ì²œ ì§¸íš’?ì¨˜ íš„ì¨€?ì© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì©”ì§• ì¨‰ì±•ì©ì±¤ì©”íššì¨ˆíš¢ì¨ˆíš‚ ?íš‰ì¨”íš‘. ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		} else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©íšˆ?íš‘ì¨‰ì±¨ì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ˆíš‚ ì§¸íš’?ì¨˜ ?ì²¬ì¨”ì²©ì©”ì§• ì¨”ì²¬ì©ì±¤íšì¨€ì¨ˆì²© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…?íš‰ ì§¸ì°¼ì§¸ì²¬?íš‘ì¨ˆíš¢.
			// ?íš‘ì¨Œì§¹ ì§¸ì±ˆì©”ì±™ ?ì²´ì§¸ì²©ì©”ì§• ì¨‰ì²­ì¨ì§œ íšˆì²¨ì¨©ì²˜?ì¨© íš‰íš˜ ì©Œì²  ì©ì²©ì¨ˆíš¢. íš„íšœì©Œíš˜íš‰íš— íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì§¸ì§• íšì©ì¨Œì°¼ì¨‰íšŠ ì¨ˆíš¢?ì© ì¨ˆíš¢?ì© ?ì²´ì¨ì±•?ì²´?íš‘ ì©íš„?íš¤ì¨‰íš‰ì§¹ì°½ ?ì²´ì©”ì§• íšì§–ì©Œíš™?ì¨© íš‰íš ì©íš© íšˆì²¨ì¨©ì²˜?ì¨© ì©ì±µ?ì¨© ì©Œì²  ?íšœì¨ˆíš¢.
			// ?íš‘?ì²´ì©”ì§• íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì©ì²¬ì¨ˆì²© ì©”ì§§íš‰íš˜, ì§¸íš‰ì©Œì¨€ íšˆì²¨?íš“íšˆì§°, ?ì²´?ì±¦ ì§¸ì²©íš‰ì±…ì¨‰ì¨‰ íš„íšŽì§¹ì°½íšŠì§¯.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… GUIDì§¸ì§• ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢. íšˆì²¨ì¨©ì²˜ ì¨˜íš˜ì§¸ì§•.
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD) m_bIsCrusadeMode, 0, 0, NULL, -1);
		}
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD) m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, NULL);
	} else if (m_bIsHeldenianMode == TRUE) {
		sSummonPoints = m_pClientList[iClientH]->m_iCharisma * 300;
		if (sSummonPoints > 12000) sSummonPoints = 12000;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == 0) {
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
		} else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwHeldenianGUID) {
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwHeldenianGUID;
		}
		m_pClientList[iClientH]->m_cWarType = 2;
		if (m_bIsHeldenianMode == TRUE) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, NULL);
			if (m_bHeldenianInitiated == FALSE) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, NULL);
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, NULL);
			UpdateHeldenianStatus();
		}
	} else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	} else {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_pClientList[iClientH]->m_cVar == 1) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD) m_bIsCrusadeMode, 0, 0, NULL, -1);
			}
		} else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD) m_bIsCrusadeMode, 0, 0, NULL, -1);
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	if (m_bIsHeldenianMode == TRUE) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, NULL, 0);
	if (m_bHeldenianInitiated == TRUE) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, NULL, 0);

	// Crusade
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, NULL);
	//Critical Count Fix.
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, NULL);
}

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData) {
	register int * ip, ix, iy, iSize, iTileExists;
	class CTile * pTileSrc, * pTile;
	unsigned char ucHeader;
	short * sp, * pTotal;
	int sTemp, sTemp2;
	WORD * wp;
	char * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *) pData;
	cp = (char *) (pData + 2);

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile +
			  (sX) + (sY) * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	for (iy = 0; iy < 16; iy++)
		for (ix = 0; ix < 21; ix++) {

			if (((sX + ix) == 100) && ((sY + iy) == 100))
				sX = sX;

			pTile = (class CTile *)(pTileSrc + ix + iy * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

			//If player not same side and is invied (Beholder Hack)
			if ((m_pClientList[pTile->m_sOwner] != NULL) && (pTile->m_sOwner != iClientH))
				if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
						  (m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
						  ((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
					continue;
				}

			// @@@ !!! @@@ ÀÌ°÷¿¡ Á¶°ÇÀÌ ÀÔ·ÂµÇ¾ß¸¸ Á¤º¸°¡ Àü´ÞµÈ´Ù!!!
			if ((pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) ||
					  (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != 0)) {
				iTileExists++;
				// À§Ä¡Á¤º¸ ÀÔ·Â
				sp = (short *) cp;
				*sp = ix;
				cp += 2;
				sp = (short *) cp;
				*sp = iy;
				cp += 2;
				iSize += 4;

				// Çì´õ Á¤º¸¸¦ ÀÛ¼ºÇÑ´Ù.
				ucHeader = 0;
				if (pTile->m_sOwner != 0) {
					// °£È¤ ÇÚµéÀÌ ÀÖ´Âµ¥µµ NULLÀÎ °æ¿ì·Î ¿¡·¯¹ß»ý. ¿øÀÎÆÄ¾ÇÁß  ¿¡·¯ º¸¿Ï ±â´É »ðÀÔ. ±×·¯³ª ±Ùº»ÀûÀÎ
					// ¿øÀÎÀ» ¾Ë¾Æ³»¾ß ÇÑ´Ù.
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else {
							// ###debugcode
							wsprintf(G_cTxt, "Empty player handle: %d", pTile->m_sOwner);
							//PutLogFileList(G_cTxt);
							//
							pTile->m_sOwner = 0;
						}
					}

					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = 0;
					}
				}
				if (pTile->m_sDeadOwner != 0) {
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
				}
				if (pTile->m_pItem[0] != NULL) ucHeader = ucHeader | 0x04;
				if (pTile->m_sDynamicObjectType != 0) ucHeader = ucHeader | 0x08;
				//
				*cp = ucHeader;
				cp++;
				iSize++;

				if ((ucHeader & 0x01) != 0) {
					switch (pTile->m_cOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:
							// Object ID number(Player) : 1~10000
							sp = (short *) cp;
							*sp = pTile->m_sOwner;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
							cp++;
							iSize++;
							// Appearance1
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr1;
							cp += 2;
							iSize += 2;
							// Appearance2
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Appearance3
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr3;
							cp += 2;
							iSize += 2;
							// Appearance4
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr4;
							cp += 2;
							iSize += 2;
							// v1.4 ApprColor
							ip = (int *) cp;
							*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
							cp += 4;
							iSize += 4;

							// Status
							ip = (int *) cp;

							// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù.
							sTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
							sTemp = 0x0FFFFFFF & sTemp; //Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
							sTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
							sTemp = (sTemp | (sTemp2 << 28)); //Original : 12
							*ip = sTemp;
							//*sp = DEF_TEST;
							cp += 4; //Original 2
							iSize += 4; //Original 2
							// Name
							memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
							cp += 10;
							iSize += 10;
							break;

						case DEF_OWNERTYPE_NPC:
							// Object ID number(NPC) : 10000~
							sp = (short *) cp;
							*sp = pTile->m_sOwner + 10000;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *) cp;
							*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
							cp++;
							iSize++;
							// Appr2
							sp = (short *) cp;
							*sp = m_pNpcList[pTile->m_sOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Status
							ip = (int *) cp;

							sTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
							sTemp = 0x0FFFFFFF & sTemp; //Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
							sTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
							sTemp = (sTemp | (sTemp2 << 28)); //Original : 12
							*ip = sTemp;
							//*sp = DEF_TEST;
							cp += 4; //Original 2
							iSize += 4; //Original 2
							// Name
							memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
							cp += 5;
							iSize += 5;
							break;
					}
				}

				if ((ucHeader & 0x02) != 0) {
					// Á×Àº Ä³¸¯ÅÍ Á¤º¸ »ðÀÔ
					switch (pTile->m_cDeadOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:
							// Object ID number : 1~10000
							sp = (short *) cp;
							*sp = pTile->m_sDeadOwner;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;
							// Appearance1
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
							cp += 2;
							iSize += 2;
							// Appearance2
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Appearance3
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
							cp += 2;
							iSize += 2;
							// Appearance4
							sp = (short *) cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
							cp += 2;
							iSize += 2;
							// v1.4 ApprColor
							ip = (int *) cp;
							*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
							cp += 4;
							iSize += 4;

							// Status
							ip = (int *) cp;

							// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù.
							sTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
							sTemp = 0x0FFFFFFF & sTemp; //Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
							sTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sDeadOwner);
							sTemp = (sTemp | (sTemp2 << 28)); //Original : 12
							*ip = sTemp;
							//*sp = DEF_TEST;
							cp += 4; //Original 2
							iSize += 4; //Original 2
							// Name
							memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
							cp += 10;
							iSize += 10;
							break;

						case DEF_OWNERTYPE_NPC:
							// Object ID number : 10000	~
							sp = (short *) cp;
							*sp = pTile->m_sDeadOwner + 10000;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *) cp;
							*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;
							// Appr2
							sp = (short *) cp;
							*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Status
							ip = (int *) cp;

							sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
							sTemp = 0x0FFFFFFF & sTemp; //Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
							sTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
							sTemp = (sTemp | (sTemp2 << 28)); //Original : 12
							*ip = sTemp;
							//*sp = DEF_TEST;
							cp += 4; //Original 2
							iSize += 4; //Original 2
							// Name
							memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
							cp += 5;
							iSize += 5;
							break;
					}
				}

				if (pTile->m_pItem[0] != NULL) {
					// ¾ÆÀÌÅÛ Á¤º¸ »ðÀÔ
					// ½ºÇÁ¶óÀÌÆ®
					sp = (short *) cp;
					*sp = pTile->m_pItem[0]->m_sSprite;
					cp += 2;
					iSize += 2;
					// ½ºÇÁ¶óÀÌÆ® ÇÁ·¹ÀÓ
					sp = (short *) cp;
					*sp = pTile->m_pItem[0]->m_sSpriteFrame;
					cp += 2;
					iSize += 2;
					// ¾ÆÀÌÅÛ »ö Ãß°¡µÊ v1.4
					*cp = pTile->m_pItem[0]->m_cItemColor;
					cp++;
					iSize++;
				}

				if (pTile->m_sDynamicObjectType != 0) {
					// µ¿Àû °´Ã¼ Á¾·ù ÇÒ´ç
					wp = (WORD *) cp;
					*wp = pTile->m_wDynamicObjectID;
					cp += 2;
					iSize += 2;

					sp = (short *) cp;
					*sp = pTile->m_sDynamicObjectType;
					cp += 2;
					iSize += 2;
				}
			} // Big if
		} // while(1)

	*pTotal = iTileExists;
	return iSize;
}

void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn) {
	int i, iExH;
	char cTmpMap[30];

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}

		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		if ((m_pClientList[iClientH]->m_iAllocatedFish != 0) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL))
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex == iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(0, i, DEF_NOTIFY_WHISPERMODEOFF, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);
			}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
				  m_pClientList[iClientH]->m_sX,
				  m_pClientList[iClientH]->m_sY);

		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);
	}

	if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)) {

		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));

			if (m_pClientList[iClientH]->m_cSide == 0) {
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			} else {
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						} else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
					}

					if (strcmp(cTmpMap, "elvine") == 0) {
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 10 * 2;
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					} else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				} else {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						} else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
					}
					if (strcmp(cTmpMap, "aresden") == 0) {
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 10 * 2;
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					} else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				}
			}
		} else if (bForceCloseConn == TRUE) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 10 * 60;
		}

		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1, 2)) {
					case 1:
						memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
						break;
					case 2:
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
						break;
				}
			} else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1, 2)) {
					case 1:
						memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
						break;
					case 2:
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
						break;
				}
			} else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
		} else bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
	} else {
		if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE) {

			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
		} else {
			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE);
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != 0) {
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				wsprintf(G_cTxt, "PartyID:%d member:%d Out(Delete) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto DC_LOOPBREAK1;
			}
DC_LOOPBREAK1:
		;
		for (i = 0; i < DEF_MAXPARTYMEMBERS - 1; i++)
			if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] != 0)) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1];
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] = 0;
			}
	}

	m_iTotalClients--;

	//50Cent - Capture The Flag
	if (bCheckIfIsFlagCarrier(iClientH)) {
		SetFlagCarrierFlag(iClientH, false);
		SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	}

	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = NULL;

	RemoveClientShortCut(iClientH);
}

void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3) {
	int * ip, i, iShortCutIndex;
	char * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200], cData_Srt_Av[200];
	DWORD * dwp;
	WORD * wp;
	int * ipStatus, iDumm;
	short * sp, sRange, sX, sY;
	BOOL bFlag, cOwnerSend;
	char cKey;
	int iTemp3, iTemp, iTemp2;

	std::memset(cData_All, 0, sizeof(cData_All));
	std::memset(cData_Srt, 0, sizeof(cData_Srt));
	std::memset(cData_Srt_Av, 0, sizeof(cData_Srt_Av));
	ipStatus = (int *) &iDumm;
	cKey = (rand() % 255) + 1;

	dwp = (DWORD *) (cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp = (WORD *) (cData_All + DEF_INDEX2_MSGTYPE);
	*wp = wMsgType;

	dwp = (DWORD *) (cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp = (WORD *) (cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp = wMsgType;

	dwp = (DWORD *) (cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp = (WORD *) (cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp = wMsgType;

	cp_a = (char *) (cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s = (char *) (cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *) (cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);


	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) ||
			  (wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = 1;
	else sRange = 0;


	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == NULL) return;

		switch (wMsgType) {
			case DEF_OBJECTNULLACTION:
			case DEF_OBJECTDAMAGE:
			case DEF_OBJECTDYING:
			case DEF_MSGTYPE_CONFIRM:
				cOwnerSend = TRUE;
				break;
			default:
				cOwnerSend = FALSE;
				break;
		}

		wp = (WORD *) cp_a;
		*wp = sOwnerH;
		cp_a += 2;

		sp = (short *) cp_a;
		sX = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp = (short *) cp_a;
		sY = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp = (short *) cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;

		sp = (short *) cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;

		sp = (short *) cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		sp = (short *) cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;

		sp = (short *) cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;

		ip = (int *) cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;

		ip = (int *) cp_a;
		ipStatus = ip;
		*ip = m_pClientList[sOwnerH]->m_iStatus;
		cp_a += 4;

		//iTemp += m_pClientList[sOwnerH]->m_iStatus & 0x0F0;
		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F; //0F0FFFF7Fh

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1;
			else *cp_a = 0;
		} else *cp_a = 0;
		cp_a++;

		wp = (WORD *) cp_s;
		*wp = sOwnerH + 30000;
		cp_s += 2;

		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char) sV1;
		cp_s++;

		*cp_s = (unsigned char) sV2;
		cp_s++;

		sp = (short *) cp_s;
		sX = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;

		sp = (short *) cp_s;
		sY = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp = (WORD *) cp_sv;
		*wp = sOwnerH + 30000;
		cp_sv += 2;

		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;

		*cp_sv = sV1 - sX;
		cp_sv++;

		*cp_sv = sV2 - sY;
		cp_sv++;

		sp = (short *) cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = TRUE;
		iShortCutIndex = 0;

		while (bFlag) {
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))

				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
						  (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
						  (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
						  (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
						  (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange)) {

					/*//If player not same side and is invied (Beholder Hack)
					if (m_pClientList[sOwnerH] != NULL && i != sOwnerH)
						if ((m_pClientList[i]->m_cSide != m_pClientList[sOwnerH]->m_cSide) &&
							((m_pClientList[sOwnerH]->m_iStatus & 0x00000010) != 0)) {
							if(wMsgType == DEF_OBJECTRUN || wMsgType == DEF_OBJECTMOVE || wMsgType == DEF_OBJECTSTOP || wMsgType == DEF_OBJECTGETITEM)
								if we filter attacking
								[KLKS] - http://xtremehb.com -> Play Abaddon (PRO ARESDEN) says:
								the poor guy who's being attacked wont know what hit him
						continue;
					}*/

					/*iTemp = *ipStatus;
					iTemp = 0x0FFFFFFF & iTemp; // ���� 4��Ʈ Ŭ����
					iTemp2 = (short)iGetPlayerABSStatus(sOwnerH, i); //(short)iGetPlayerRelationship_SendEvent(sOwnerH, i);
					iTemp  = (iTemp | (iTemp2 << 28));
					 *ipStatus = iTemp;*/

					if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
						if (m_pClientList[i]->m_iAdminUserLevel > 0) { //¾îµå¹Î¿¡°Ô´Â ¹«Á¶°Ç º¸³½´Ù.
							iTemp = m_pClientList[sOwnerH]->m_iStatus;
						} else if (i != sOwnerH) {
							iTemp = iTemp3;
						} else {
							iTemp = m_pClientList[sOwnerH]->m_iStatus;
						}
					} else {
						iTemp = m_pClientList[sOwnerH]->m_iStatus;
						//iTemp = 0x0FFFFFFF;
					}

					//iTemp = m_pClientList[sOwnerH]->m_iStatus;
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
					iTemp = (iTemp | (iTemp2 << 28));
					*ipStatus = iTemp;

					if ((m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9) &&
							  (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) &&
							  (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) &&
							  (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7)) {

						switch (wMsgType) {
							case DEF_MSGTYPE_CONFIRM:
							case DEF_MSGTYPE_REJECT:
							case DEF_OBJECTNULLACTION:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								break;

							case DEF_OBJECTATTACK:
							case DEF_OBJECTATTACKMOVE:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								break;

							case DEF_OBJECTMAGIC:
							case DEF_OBJECTDAMAGE:
							case DEF_OBJECTDAMAGEMOVE:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								break;

							case DEF_OBJECTDYING:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								break;

							default:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
								break;
						} //Switch
					}// If 2
					else {
						switch (wMsgType) {
							case DEF_MSGTYPE_CONFIRM:
							case DEF_MSGTYPE_REJECT:
							case DEF_OBJECTNULLACTION:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								break;

							case DEF_OBJECTATTACK:
							case DEF_OBJECTATTACKMOVE:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								break;

							case DEF_OBJECTMAGIC:
							case DEF_OBJECTDAMAGE:
							case DEF_OBJECTDAMAGEMOVE:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								break;

							case DEF_OBJECTDYING:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								break;

							default:
								if (cOwnerSend == TRUE)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								else
									if (i != sOwnerH)
									m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
								break;
						} //Switch
					} //else
				} // If 1
		} //While finish
	}//Finish Player
	else {

		if (m_pNpcList[sOwnerH] == NULL) return;

		wp = (WORD *) cp_a;
		*wp = sOwnerH + 10000;
		cp_a += 2;

		sp = (short *) cp_a;
		sX = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp = (short *) cp_a;
		sY = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp = (short *) cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;

		sp = (short *) cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		ip = (int *) cp_a;
		ipStatus = ip;
		*ip = m_pNpcList[sOwnerH]->m_iStatus;
		cp_a += 4;

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1;
			else *cp_a = 0;
		} else *cp_a = 0;
		cp_a++;

		wp = (WORD *) cp_s;
		*wp = sOwnerH + 40000;
		cp_s += 2;

		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char) sV1;
		cp_s++;
		*cp_s = (unsigned char) sV2;
		cp_s++;

		sp = (short *) cp_s;
		sX = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp = (short *) cp_s;
		sY = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp = (WORD *) cp_sv;
		*wp = sOwnerH + 40000;
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp = (short *) cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = TRUE;
		iShortCutIndex = 0;

		while (bFlag) {

			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			if ((bFlag == TRUE) && (m_pClientList[i] != NULL))

				if ((m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
						  (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
						  (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
						  (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
						  (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange)) {

					iTemp = *ipStatus;
					iTemp = 0x0FFFFFFF & iTemp;
					iTemp2 = iGetNpcRelationship(sOwnerH, i);
					iTemp = (iTemp | (iTemp2 << 28));
					*ipStatus = iTemp;

					if ((m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
							  (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
							  (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
							  (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7)) {
						switch (wMsgType) {
							case DEF_MSGTYPE_CONFIRM:
							case DEF_MSGTYPE_REJECT:
							case DEF_OBJECTNULLACTION:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27, cKey);
								break;

							case DEF_OBJECTDYING:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								break;

							case DEF_OBJECTDAMAGE:
							case DEF_OBJECTDAMAGEMOVE:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								break;

							case DEF_OBJECTATTACK:
							case DEF_OBJECTATTACKMOVE:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								break;

							default:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
								break;

						} //Switch
					} else {
						switch (wMsgType) {
							case DEF_MSGTYPE_CONFIRM:
							case DEF_MSGTYPE_REJECT:
							case DEF_OBJECTNULLACTION:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27, cKey);
								break;

							case DEF_OBJECTDYING:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
								break;

							case DEF_OBJECTDAMAGE:
							case DEF_OBJECTDAMAGEMOVE:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
								break;

							case DEF_OBJECTATTACK:
							case DEF_OBJECTATTACKMOVE:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
								break;

							default:
								m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27, cKey);
								break;

						} //Switch
					}
				}
		}
	} // else - NPC
}

int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData) {
	register int * ip, ix, iy, iSize, iTileExists, iIndex;
	class CTile * pTileSrc, * pTile;
	unsigned char ucHeader;
	short * sp, * pTotal;
	int iTemp, iTemp2;
	WORD * wp;
	char * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *) pData;
	cp = (char *) (pData + 2);

	iSize = 2;
	iTileExists = 0;

	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile +
			  (sX) + (sY) * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	iIndex = 0;

	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;

		iIndex++;

		pTile = (class CTile *)(pTileSrc + ix + iy * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		//If player not same side and is invied (Beholder Hack)
		// there is another person on the tiles, and the owner is not the player
		//xxxxxx
		if ((m_pClientList[pTile->m_sOwner] != NULL) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
					  (m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
					  ((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}

		if ((pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) ||
				  (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != 0)) {

			iTileExists++;

			sp = (short *) cp;
			*sp = ix;
			cp += 2;
			sp = (short *) cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			ucHeader = 0;

			if (pTile->m_sOwner != 0) {
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = 0;
				}
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = 0;
				}
			}
			if (pTile->m_sDeadOwner != 0) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = 0;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = 0;
				}
			}

			if (pTile->m_pItem[0] != NULL) ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != 0) ucHeader = ucHeader | 0x08;

			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
					case DEF_OWNERTYPE_PLAYER:
						sp = (short *) cp;
						*sp = pTile->m_sOwner;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sType;
						cp += 2;
						iSize += 2;

						*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
						cp++;
						iSize++;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr1;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr3;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sAppr4;
						cp += 2;
						iSize += 2;

						ip = (int *) cp;
						*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
						cp += 4;
						iSize += 4;

						ip = (int *) cp;

						if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide) {
							if (iClientH != pTile->m_sOwner) {
								iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus & 0x0F0FFFF7F;
							} else {
								iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
							}
						} else {
							iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
						}

						//iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
						iTemp = (iTemp | (iTemp2 << 28));
						*ip = iTemp;
						cp += 4;
						iSize += 4;

						memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
						cp += 10;
						iSize += 10;
						break;

					case DEF_OWNERTYPE_NPC:
						sp = (short *) cp;
						*sp = pTile->m_sOwner + 10000;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
						cp += 2;
						iSize += 2;

						*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
						cp++;
						iSize++;

						sp = (short *) cp;
						*sp = m_pNpcList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;

						ip = (int *) cp;
						iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
						iTemp = (iTemp | (iTemp2 << 28));
						*ip = iTemp;
						cp += 4;
						iSize += 4;

						memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
						cp += 5;
						iSize += 5;
				}//end switch
			}// if ((ucHeader & 0x01) != 0)

			if ((ucHeader & 0x02) != 0) {
				switch (pTile->m_cDeadOwnerClass) {
					case DEF_OWNERTYPE_PLAYER:

						sp = (short *) cp;
						*sp = pTile->m_sDeadOwner;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
						cp += 2;
						iSize += 2;

						*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
						cp++;
						iSize++;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
						cp += 2;
						iSize += 2;

						ip = (int *) cp;
						*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
						cp += 4;
						iSize += 4;

						ip = (int *) cp;

						if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide) {
							if (iClientH != pTile->m_sDeadOwner) {
								iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus & 0x0F0FFFF7F;
							} else {
								iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
							}
						} else {
							iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
						}

						//iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
						iTemp = 0x0FFFFFFF & iTemp;

						iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
						iTemp = (iTemp | (iTemp2 << 28));
						*ip = iTemp;
						cp += 4;
						iSize += 4;

						memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
						cp += 10;
						iSize += 10;
						break;

					case DEF_OWNERTYPE_NPC:
						sp = (short *) cp;
						*sp = pTile->m_sDeadOwner + 10000;
						cp += 2;
						iSize += 2;

						sp = (short *) cp;
						*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
						cp += 2;
						iSize += 2;

						*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
						cp++;
						iSize++;

						sp = (short *) cp;
						*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
						cp += 2;
						iSize += 2;

						ip = (int *) cp;

						iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
						iTemp = (iTemp | (iTemp2 << 28));
						*ip = iTemp;

						cp += 4;
						iSize += 4;

						memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
						cp += 5;
						iSize += 5;
						break;
				}//End Switch
			}// if ((ucHeader & 0x02) != 0)

			if (pTile->m_pItem[0] != NULL) {
				sp = (short *) cp;
				*sp = pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;

				sp = (short *) cp;
				*sp = pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;

				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != 0) {

				wp = (WORD *) cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;

				sp = (short *) cp;
				*sp = pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			} //(pTile->m_sDynamicObjectType != NULL)

		} //(pTile->m_sOwner != NULL)
	} // end While(1)
	*pTotal = iTileExists;
	return iSize;
}

void CGame::CheckClientResponseTime() {
	register int i, iPlusTime, iMaxSuperAttack, iValue;
	short sTemp;
	DWORD dwTime;
	short sItemIndex;
	int iMapside, iMapside2;
	//SYSTEMTIME SysTime;

	/*
	// ½Ã°£À» ±¸ÇÑ´ÙÀ½ iWarPeriod¸¦ ±¸ÇÑ´Ù.
	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; //¿ù¿äÀÏ
	case 2:	iWarPeriod = 30; break; //È­¿äÀÏ
	case 3:	iWarPeriod = 60; break; //¼ö¿äÀÏ
	case 4:	iWarPeriod = 60*2;  break; //¸ñ¿äÀÏ
	case 5:	iWarPeriod = 60*5;  break; //±Ý¿äÀÏ
	case 6:	iWarPeriod = 60*10; break; //Åä¿äÀÏ
	case 0:	iWarPeriod = 60*20; break; //ÀÏ¿äÀÏ
	}
	 */

	dwTime = timeGetTime();

	// ÀÏÁ¤½Ã°£µ¿¾È ¸Þ½ÃÁö¸¦ º¸³»¿ÀÁö ¾Ê´Â Å¬¶óÀÌ¾ðÆ®´Â »èÁ¦ÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {

			if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
				if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
					// °ÔÀÓÁßÀÎ Å¬¶óÀÌ¾ðÆ®°¡ ÀÀ´äÀÌ ¾øÀ¸¹Ç·Î »èÁ¦ÇÑ´Ù.
					//Testcode
					wsprintf(G_cTxt, "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);

					DeleteClient(i, TRUE, TRUE);
				} else if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
					// ÃÊ±âÈ­ µÇÁö ¾Ê°í ´ë±âÁßÀÎ Å¬¶óÀÌ¾ðÆ®ÀÌ´Ù. Àå½Ã°£µ¿¾È Ã³¸®°¡ ÁøÇàµÇÁö ¾ÊÀ¸¸é »èÁ¦ÇÑ´Ù.
					DeleteClient(i, FALSE, FALSE); // ÃÊ±âÈ­ µÇÁö ¾Ê¾ÒÀ¸¹Ç·Î µ¥ÀÌÅÍ¸¦ ÀúÀåÇÒ ÇÊ¿ä°¡ ¾ø´Ù.
				}
			} else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// ÇÃ·¹ÀÌ¾îÀÇ ÀüÃ¼ Ã¤ÆÃ ºÒ°¡´É Áö¼Ó½Ã°£À» ÁÙÀÎ´Ù.
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;

				// ÆòÆÇÀ» ³»¸± ¼ö ÀÖ´Â ½Ã°£À» ÁÙÀÎ´Ù.
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;

				// ¹è°íÆÄÁú ½Ã°£ÀÌ µÇ¸é Ä«¿îÆ®¸¦ ÇÏ³ª ±ï´Â´Ù.
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
					// ½Ã°£ÀÌ ´Ù µÇ¾ú´Ù.
					// v2.03 ¿î¿µÀÚ´Â ¹è°íÆÄÁöÁö ¾Ê´Â´Ù.
					if ((m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1)) {
						// ·¹º§ÀÌ DEF_LEVELLIMITÀÌÇÏÀÌ¸é ¹è°íÇÄ Áö¼ö¸¦ ±ïÁö ¾Ê´Â´Ù.
					} else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;
					if ((m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 40)) {//50Cent - Hunger Fix
						// ¹è°�*ÇÄÀ» ´À³¢´Â »óÅÂÀÌ´Ù. Å¬¶óÀÌ¾ðÆ®¿¡°Ô Åëº¸ÇÑ´Ù. 
						SendNotifyMsg(0, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, 0, 0, NULL);
					}
				}

				if (_bCheckCharacterData(i) == FALSE) {
					DeleteClient(i, TRUE, TRUE);
					break;
				}

				// ¹è°¡ °íÇÁ¸é ¿À¸£´Â ½Ã°£ÀÌ ±æ¾îÁø´Ù.
				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0))
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;

				iPlusTime = abs(iPlusTime);

				// HP°¡ ¿Ã¶ó°¥ ½Ã°£ÀÌ µÇ¸é ¿Ã¸°´Ù.
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD) (DEF_HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}

				// MP°¡ ¿Ã¶ó°¥ ½Ã°£ÀÌ µÇ¸é ¿Ã¸°´Ù.
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD) (DEF_MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}

				// SP°¡ ¿Ã¶ó°¥ ½Ã°£ÀÌ µÇ¸é ¿Ã¸°´Ù.
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD) (DEF_SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}

				// Áßµ¶ È¿°ú¸¦ °è»êÇÑ´Ù.
				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, 0);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}

				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == FALSE) &&
						  ((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD) DEF_AUTOSAVETIME)) {
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}

				// ExpStockÀ» °è»êÇÒ ½ÃÁ¡ÀÌ¸é
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD) DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					CheckHeldenianResultCalculation(i); // new
				}

				// AutoExe °è»ê ½ÃÁ¡ÀÌ¸é
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD) DEF_AUTOEXPTIME) {
					iValue = (m_pClientList[i]->m_iLevel / 2);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						// ÀÚµ¿ ½Ã°£ °è»ê °æÇèÄ¡·Î´Â ·¹º§ÀÌ ¿À¸£Áö ¾ÊÀ¸¹Ç·Î Ã³¸®ÇÑ´Ù.
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel + 1]) {
							//m_pClientList[i]->m_iExpStock += iValue;
							GetExp(i, iValue, FALSE);
							CalcExpStock(i);
						}
					}

					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}

				// v1.432 Æ¯¼ö ´É·Â »ç¿ë °¡´É ½Ã°£À» ÁÙÀÎ´Ù. 3¾¿ ÁÙ¾îµç´Ù.
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					// »ç¿ëÀÚ¿¡°Ô ¾Ë·ÁÁØ´Ù.
					SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, NULL);
					// New 25/05/2004
					// After the time up, add magic back
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if ((m_pClientList[i]->m_iInt + m_pClientList[i]->m_iAngelicInt) > 99 && (m_pClientList[i]->m_iMag + m_pClientList[i]->m_iAngelicMag) > 99) {
								m_pClientList[i]->m_cMagicMastery[94] = TRUE;
								SendNotifyMsg(0, i, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, NULL);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;

				// v1.432 Æ¯¼ö ´É·Â »ç¿ëÁßÀÎ ½Ã°£À» Ã¼Å©
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
					if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime) / 1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
						// »ç¿ë½Ã°£ÀÌ ´Ù µÇ¾ú´Ù.
						SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, 0, 0, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
						// ´ÙÀ½ »ç¿ë °¡´É ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						// È¿°ú ºñÆ® Å¬¸®¾î
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						// ¿ÜÇüÀÌ º¯ÇßÀ½À» ¾Ë¸°´Ù.
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					// ¸Ê °¤Èû ½Ã°£ Á¾·á. Å¬¸®¾îÇÑ´Ù.
					m_pClientList[i]->m_iLockedMapTime = 0;
					std::memset(m_pClientList[i]->m_cLockedMapName, 0, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}

				// v2.04 �׾����� ���Ƽ �ð�
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;

				if ((m_pClientList[i]->m_bIsWarLocation == TRUE)) {
					// Crusade
					if (m_bIsCrusadeMode == FALSE)
						if (m_pClientList[i]->m_bIsInsideOwnTown == FALSE)
							m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						// �ð��� �� �Ǿ��. ���� �����Ѵ�.
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = FALSE;

						// ��ȯ�ȴٴ� �޽����� ������.
						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
						RequestTeleportHandler(i, "1   ");
					}
				}

				if ((m_bIsHeldenianMode == TRUE) && (m_pMapList[m_pClientList[i]->m_cMapIndex] != 0)) {
					if (bCheckHeldenianMap(i, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, TRUE);
					} else {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, FALSE);
					}
				}

				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					// ¾ÆÀÌÅÛ Á¦ÀÛ ¸í·ÉÀÌ 2°³ ÀÌ»ó Á¢¼öµÇ¾ú´Ù¸é ÀÌ»óÇÑ °ÍÀÌ´Ù. Á¤»óÀûÀÌ¶ó¸é 1°³ ±îÁö ¿Ã ¼ö ÀÖ´Ù.
					//wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) ¼Óµµ Á¶ÀÛ", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				} else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				// ¼Óµµ¹ö±× Ã¼Å©¿ë. ´ÜÀ§½Ã°£´ç Áö³ªÄ¡°Ô ¸¹Àº °æÇèÄ¡¸¦ ¾òÀº Ä³¸¯Àº ºí·ÏµÈ´Ù.
				if (m_pClientList[i] == NULL) break;
				// ÇÏÀ§ ·¹º§ Á¦ÇÑ¿¡ °É¸°´Ù¸é
				//if (m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) {
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 2)) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// »óÀ§ ·¹º§ Á¦ÇÑ¿¡ °É¸°´Ù¸é
				//if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
				//	 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) ) {
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
						  (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 2)) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
					if ((m_pClientList[i]->m_cSide == 1) &&
							  (m_pClientList[i]->m_iAdminUserLevel == 0)) {
						RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
					} else if ((m_pClientList[i]->m_cSide == 2) &&
							  (m_pClientList[i]->m_iAdminUserLevel == 0)) {
						RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
					}
				}

				if (m_pClientList[i] == NULL) break;
				if ((strcmp(m_pClientList[i]->m_cLocation, "elvine") != 0) &&
						  (strcmp(m_pClientList[i]->m_cLocation, "elvhunter") != 0) &&
						  (strcmp(m_pClientList[i]->m_cLocation, "arehunter") != 0) &&
						  (strcmp(m_pClientList[i]->m_cLocation, "aresden") != 0) &&
						  (m_pClientList[i]->m_iLevel >= 20) &&
						  (m_pClientList[i]->m_iAdminUserLevel == 0)) {
					wsprintf(G_cTxt, "Traveller Hack: (%s) Player: (%s) is a traveller and is greater than level 19.", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}

				if (m_pClientList[i] == NULL) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "aresden", 7) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvine", 6) == 0)) &&
						  (m_bIsCrusadeMode == TRUE)) {
					iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
					if (iMapside > 3) iMapside2 = iMapside - 2;
					else iMapside2 = iMapside;

					if ((m_pClientList[i]->m_cSide != iMapside2) && (iMapside != 0)) {
						if ((iMapside <= 2) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
							if (m_pClientList[i]->m_cSide != 0) {
								m_pClientList[i]->m_dwWarBeginTime = timeGetTime();
								m_pClientList[i]->m_bIsWarLocation = TRUE;
								m_pClientList[i]->m_iTimeLeft_ForceRecall = 1;

								RequestTeleportHandler(i, "1   ");
								SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
							}
						}
					}
				}

				if (m_pClientList[i] == NULL) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "arehunter", 9) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvhunter", 9) == 0)) &&
						  ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0))) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
					RequestTeleportHandler(i, "1   ");
				}

				if (m_bIsApocalypseMode == TRUE) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "abaddon", 7) == 0) {
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 167, 169, 0, m_pClientList[i]->m_cMapName);
					} else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0) {
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 89, 31, 0, m_pClientList[i]->m_cMapName);
					}
				}

				//50Cent - Capture The Flag
				if (m_bIsCTFMode) {
					RequestCheckFlag(i);
					if (bCheckIfIsFlagCarrier(i)) {
						if (m_pClientList[i]->m_iHP >= 1) {
							SetInvisibilityFlag(i, DEF_OWNERTYPE_PLAYER, false);
							SetIceFlag(i, DEF_OWNERTYPE_PLAYER, true);
						}
					}
				}


				if (m_pClientList[i] == NULL) break;
				if ((m_bIsApocalypseMode == TRUE) &&
						  (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0) &&
						  ((m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 31) ||
						  (m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 32) ||
						  (m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 31) ||
						  (m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 32))) {
					RequestTeleportHandler(i, "2   ", "druncncity", -1, -1);
				}

				if (m_pClientList[i] == NULL) break;
				// ³ó°æÁö¸Ê¿¡ ÀûÀÌ µé¾î°¡¸é ¸®ÄÝ
				if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) &&
						  (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// ³ó°æÁö¸Ê¿¡ ÀûÀÌ µé¾î°¡¸é ¸®ÄÝ
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) &&
						  (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "arefarm") == 0)) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// Áß¸³ÀÌ Á¢°æÁö³ª ¹Ìµé·£µå¿¡ ÀÖ´Ù¸é ¸®ÄÝ
				if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0)
						  && (strcmp(m_pClientList[i]->m_cLocation, "NONE") == 0) &&
						  (m_pClientList[i]->m_iAdminUserLevel < 1)) {
					// ��ȯ�ȴٴ� �޽����� ������ ���� ����.
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i]->m_bInRecallImpossibleMap == TRUE) {
					m_pClientList[i]->m_iTimeLeft_ForceRecall--;
					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_bInRecallImpossibleMap = FALSE;
						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, NULL);
						RequestTeleportHandler(i, "0   ");
					}
				}

				if (m_pClientList[i] == NULL) break;
				// ÇÊ»ì±â Ä«¿îÆ® Áõ°¡
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39ÃÊ¸¶´Ù ÇÑ°³¾¿ ÃàÀû µÈ´Ù.

					m_pClientList[i]->m_iSuperAttackCount = 0;
					// ÇÊ»ì±â´Â ÃÖ´ë Level/10 °³ ±îÁö ÃàÀûµÈ´Ù.
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;

					// v1.12 ¼­¹ö¿Í Å¬¶óÀÌ¾ðÆ® °£¿¡ Ä«¿îÆ®°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â °æ¿ì°¡ ÀÖÀ» ¼ö ÀÖÀ¸¹Ç·Î °¡°¨¿¡ »ó°ü¾øÀÌ º¸³½´Ù.
					SendNotifyMsg(0, i, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, NULL);
				}

				// v1.42 °íÁ¤ ½ºÅÂ¹Ì³Ê Ä«¿îÆ® °¨¼Ò
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade ¸ÊÁ¤º¸¸¦ º¸³»´Â ÁßÀÌ¾ú´Ù¸é °è¼Ó º¸³½´Ù.
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					// ´©ÀûµÈ °Ç¼³ Æ÷ÀÎÆ®°¡ ÀÖ´Ù.
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

void CGame::OnMainLogSocketEvent(UINT /*message*/, WPARAM wParam, LPARAM lParam) {
	int iRet;

	if (m_pMainLogSock == NULL) return;

	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
		case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
			// �α׼������� ������ �̷�� �����Ƿ� ���Ӽ��� ��� �޽����� ����Ѵ�.
			PutLogList("(!!!) Main-log-socket connected!");
			bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, 0);
			break;

		case DEF_XSOCKEVENT_READCOMPLETE:
			// �޽����� ���ŵǾ��.
			OnMainLogRead();
			break;

		case DEF_XSOCKEVENT_BLOCK:
			PutLogList("(!!!) Main-log-socket BLOCKED!");
			break;

		case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
			// Ȯ���ڵ尡 ��ġ���� �ʴ´�.
		case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
			// �����ؾ� �� �޽��� ũ�Ⱑ ���ۺ��� ũ��.	�����ؾ߸� �Ѵ�.
		case DEF_XSOCKEVENT_SOCKETERROR:
			// ���Ͽ� ������ ����.
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ������ �����.
			delete m_pMainLogSock;
			m_pMainLogSock = NULL;
			PutLogList("(!!!) Main-log-socket connection lost!");
			m_bIsLogSockAvailable = FALSE;

			// �α� �������� ������ �������Ƿ� ������ �� ���. �ڵ����� ������ �˴ٿ��Ѵ�.
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode = 3;
				m_bOnExitProcess = TRUE;
				m_dwExitProcessTime = timeGetTime();
				// ���� ���� �˴ٿ��� ���۵Ǹ� ���̻��� Ŭ���̾�Ʈ ������ �źεȴ�.
				PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
			}
			break;
	}
}

void CGame::OnMainLogRead() {
	DWORD dwMsgSize;
	char * pData, cKey;

	pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, 0, cKey) == FALSE) {
		// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}

BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag, char* pData) {
	DWORD * dwp;
	WORD * wp;
	int iRet, i, iSize;
	char cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
	char cGuildLoc[11], cTemp[120];
	int * ip, iSendSize;


	/*
	// ¸Þ½ÃÁö¸¦ º¸³¾ Sub-log-socket ÀÎµ¦½º ÀüÁø
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	// ¸Þ½ÃÁö¸¦ º¸³»±â¿¡ Àû´çÇÑ Sub-log-socketÀ» Ã£´Â´Ù.
	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if (m_pSubLogSock[m_iCurSubLogSockIndex] != NULL)
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// º¸³¾ ¼ö ÀÖ´Â Sub-log-socketÀÌ ÇÏ³ªµµ ¾ø´Ù. °­Á¦ ¼Ë´Ù¿î ¸ðµå·Î ÀüÈ¯
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù.
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}
	 */


	// v1.41
	std::memset(G_cData50000, 0, sizeof(G_cData50000));
	std::memset(cCharName, 0, sizeof(cCharName));
	std::memset(cAccountName, 0, sizeof(cAccountName));
	std::memset(cAccountPassword, 0, sizeof(cAccountPassword));
	std::memset(cAddress, 0, sizeof(cAddress));
	std::memset(cGuildName, 0, sizeof(cGuildName));
	std::memset(cGuildLoc, 0, sizeof(cGuildLoc));

	switch (dwMsg) {
			// New 07/05/2004
		case MSGID_GAMEMASTERLOG:
			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;
			if (pData == NULL) return FALSE;


			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_GAMEMASTERLOG;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			iSize = strlen(pData);
			memcpy((char *) cp, pData, iSize);

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
			iSendSize = 6 + iSize;
			break;
			// v2.15

		case MSGID_GAMEITEMLOG:
			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			//		if (m_pClientList[iClientH] == NULL) return FALSE;
			if (pData == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_GAMEITEMLOG;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			iSize = strlen(pData);
			memcpy((char *) cp, pData, iSize);

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
			iSendSize = 6 + iSize;
			break;

		case MSGID_SENDSERVERSHUTDOWNMSG:
			if (m_pMainLogSock == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			// ÀÌ ¸Þ½ÃÁö´Â m_pMainLogSockÀ¸·Î º¸³»¾ß ÇÑ´Ù.
			iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
			break;

		case MSGID_GAMESERVERSHUTDOWNED:
			if (m_pMainLogSock == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_GAMESERVERSHUTDOWNED;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			// ÀÌ ¸Þ½ÃÁö´Â m_pMainLogSockÀ¸·Î º¸³»¾ß ÇÑ´Ù.
			iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
			return TRUE;

		case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
		case MSGID_REQUEST_SETACCOUNTINITSTATUS:
			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;
			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = dwMsg;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
			cp += 10;

			ip = (int *) cp;
			*ip = m_pClientList[iClientH]->m_iLevel;
			cp += 4;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
			iSendSize = 16;
			break;

		case MSGID_ENTERGAMECONFIRM:

			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_ENTERGAMECONFIRM;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
			cp += 10;

			memcpy(cp, m_cServerName, 10);
			cp += 10;

			std::memset(cTxt, 0, sizeof(cTxt));
			m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
			memcpy(cp, cTxt, 16);
			cp += 16;

			ip = (int *) cp;
			*ip = m_pClientList[iClientH]->m_iLevel;
			cp += 4;

			//testcode
			wsprintf(G_cTxt, "Confirmed. Account: (%s) Name: (%s) Level: (%d)", m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel);
			PutLogList(G_cTxt);

			if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
				break;
			} else
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
			iSendSize = 56;
			break;

		case MSGID_REQUEST_REGISTERGAMESERVER:
			// ·Î±× ¼­¹ö¿¡°Ô °ÔÀÓ¼­¹ö µî·ÏÀ» ¿äÃ»ÇÑ´Ù.
			if (m_pMainLogSock == NULL) return FALSE;

			wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
			PutLogList(cTxt);

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cAccountName, m_cServerName, 10);
			if (m_iGameServerMode == 1) {
				memcpy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
			}
			if (m_iGameServerMode == 2) {
				memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
			}
			memcpy(cp, cAccountName, 10);
			cp += 10;

			memcpy(cp, cAddress, 16);
			cp += 16;

			wp = (WORD *) cp;
			*wp = m_iGameServerPort;
			cp += 2;

			*cp = m_iTotalMaps;
			cp++;

			for (i = 0; i < m_iTotalMaps; i++) {
				memcpy(cp, m_pMapList[i]->m_cName, 11);
				cp += 11;
			}

			// ÀÌ ¸Þ½ÃÁö´Â m_pMainLogSockÀ¸·Î º¸³»¾ß ÇÑ´Ù.
			iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps * 11);

			return TRUE;

		case MSGID_REQUEST_PLAYERDATA:

			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			// ·Î±× ¼­¹ö·Î ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ¸¦ ¿äÃ»ÇÑ´Ù.
			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_PLAYERDATA;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			//testcode
			if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

			memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
			memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
			memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

			memcpy((char *) cp, cCharName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountPassword, 10);
			cp += 10;

			std::memset(cTemp, 0, sizeof(cTemp));
			iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
			memcpy((char *) cp, cTemp, 15);
			cp += 15;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
			iSendSize = 52;
			break;

		case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
		case MSGID_REQUEST_SAVEPLAYERDATA:
		case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = dwMsg;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
			memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
			memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

			memcpy((char *) cp, cCharName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountPassword, 10);
			cp += 10;

			*cp = (char) bFlag; // Ä«¿îÆÃ ÇÃ·¡±×
			cp++;

			iSize = _iComposePlayerDataFileContents(iClientH, cp);

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
			iSendSize = 37 + iSize;
			break;

		case MSGID_REQUEST_NOSAVELOGOUT:

			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_NOSAVELOGOUT;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
			memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
			memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

			memcpy((char *) cp, cCharName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountPassword, 10);
			cp += 10;

			*cp = (char) bFlag; // Ä«¿îÆÃ ÇÃ·¡±×
			cp++;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
			iSendSize = 37;
			break;

		case MSGID_REQUEST_CREATENEWGUILD:

			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_CREATENEWGUILD;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
			memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
			memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
			memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
			memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

			memcpy((char *) cp, cCharName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountPassword, 10);
			cp += 10;

			memcpy((char *) cp, cGuildName, 20);
			cp += 20;
			memcpy((char *) cp, cGuildLoc, 10);
			cp += 10;

			ip = (int *) cp;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp += 4;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
			iSendSize = 75;
			break;

		case MSGID_REQUEST_DISBANDGUILD:
			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_DISBANDGUILD;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
			memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
			memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
			memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

			memcpy((char *) cp, cCharName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountName, 10);
			cp += 10;

			memcpy((char *) cp, cAccountPassword, 10);
			cp += 10;

			memcpy((char *) cp, cGuildName, 20);
			cp += 20;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
			iSendSize = 56;
			break;

		case MSGID_REQUEST_HELDENIAN_WINNER:
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_HELDENIAN_WINNER;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;
			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			if (m_cHeldenianVictoryType == 1)
				memcpy(cp, "aresden", 7);
			else if (m_cHeldenianVictoryType == 2)
				memcpy(cp, "elvine", 6);
			else
				memcpy(cp, "draw", 4);

			cp += 7;

			ip = (int *) cp;
			*ip = m_dwHeldenianStartTime;
			cp += 4;

			ip = (int *) cp;
			*ip = m_dwHeldenianFinishTime;
			cp += 4;

			ip = (int *) cp;
			*ip = m_cHeldenianModeType;
			cp += 4;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 21);
			iSendSize = 21;
			break;

		case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
			memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

			memcpy((char *) cp, cCharName, 10);
			cp += 10;

			memcpy((char *) cp, cGuildName, 20);
			cp += 20;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
			iSendSize = 36;
			break;

		case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

			// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

			if (m_pClientList[iClientH] == NULL) return FALSE;

			dwp = (DWORD *) (G_cData50000 + DEF_INDEX4_MSGID);
			*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
			wp = (WORD *) (G_cData50000 + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			cp = (char *) (G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

			memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
			memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

			memcpy((char *) cp, cCharName, 10);
			cp += 10;

			memcpy((char *) cp, cGuildName, 20);
			cp += 20;

			iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
			iSendSize = 36;
			break;
	}

	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Sub-log-socketÀ» »ç¿ëÇØ¼­ ·Î±× ¼­¹ö·Î ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù.
			wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);

			delete m_pSubLogSock[m_iCurSubLogSockIndex];
			m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
			m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
			m_iSubLogSockActiveCount--;

			// ´Ù½Ã ¿¬°áÀ» ½Ãµµ
			m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
			m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

			wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
			PutLogList(G_cTxt);

			// v1.41 sub-log-socket Àü¼Û ½ÇÆÐ Ä«¿îÆ® Áõ°¡
			m_iSubLogSockFailCount++;

			// v1.41 º¸³»·Á´Ù ½ÇÆÐÇÑ ¸Þ½ÃÁö´Â ´Ù¸¥ ¼ÒÄÏÀ» »ç¿ëÇÏ¿© Àü¼ÛÇØ¾ß ÇÑ´Ù.
			// ÀÌ ¹æ¹ýÀÌ ¸ðµç ¸Þ½ÃÁöÀÇ Àü¼ÛÀ» º¸ÀåÇÏÁö´Â ¾Ê´Â´Ù. ÃÖ¼ÒÇÑÀÇ ÀåÄ¡ÀÎ ¼À.
			if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
			m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

			return FALSE;
	}

	return TRUE;
}

void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize) {
	WORD * wp;
	char * cp, cCharName[11], cTxt[120];
	int i;

	// ·Î±× ¼­¹ö·ÎºÎÅÍ ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù.
	std::memset(cCharName, 0, sizeof(cCharName));
	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ® ¹è¿­À» °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
				wp = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
				switch (*wp) {
					case DEF_LOGRESMSGTYPE_CONFIRM:
						// Å¬¶óÀÌ¾ðÆ® µ¥ÀÌÅÍ°¡ Á¤»óÀûÀ¸·Î ¼ö½ÅµÇ¾ú´Ù.
						InitPlayerData(i, pData, dwSize);
						break;

					case DEF_LOGRESMSGTYPE_REJECT:
						// ÀÌ Å¬¶óÀÌ¾ðÆ®ÀÇ µ¥ÀÌÅÍ ÃÊ±âÈ­°¡ °ÅºÎµÇ¾ú´Ù. Á¢¼ÓÀ» ²÷´Â´Ù.
						wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
						PutLogList(G_cTxt);
						//PutLogFileList(G_cTxt); // v1.4

						DeleteClient(i, FALSE, FALSE);
						break;

					default:
						break;
				}

				return;
			}
		}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize) {

	char * cp, cName[11], cData[256], cTxt[256], cGuildStatus, cQuestRemain;
	DWORD * dwp;
	WORD * wp;
	int iRet, i, iTotalPoints;
	BOOL bRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return; // ÀÌ¹Ì ÃÊ±âÈ­ µÈ Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍÀÌ´Ù. ÀÌ·±ÀÏÀÌ ÀÖÀ» ¼ö ÀÖÀ»±î?

	// Log Server·ÎºÎÅÍÀÇ ¸Þ½ÃÁö¸¦ ºÐ¼®ÇÏ¿© ÇÃ·¹ÀÌ¾îÀÇ µ¥ÀÌÅÍ¸¦ ÃÊ±âÈ­ÇÑ´Ù.
	// ¸¸¾à ·Î±×¼­¹ö·ÎºÎÅÍÀÇ ¸Þ½ÃÁö°¡ ÆÄÀÏ¼Õ»óµîÀÇ ÀÌÀ¯·Î ³»¿ëÀÌ Á¤È®ÇÏ°Ô ¸ÂÁö ¾ÊÀ¸¸é ÃÊ±âÈ­ ÇÏÁö ¾Ê°í Å¬¶óÀÌ¾ðÆ®¸¦ »èÁ¦ÇÑ´Ù.

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	// °èÁ¤Á¤º¸ ÀúÀå  v1.43	ºÎÅÍ ´õÀÌ»óÀÇ °èÁ¤ Á¤º¸´Â ÇÊ¿ä¾ø´Ù.
	//m_pClientList[iClientH]->m_cAccountStatus = *cp;
	cp++;

	// ±æµå Á¤º¸ ÀÐ´Â´Ù. ÀÌ °ªÀÌ 0ÀÌ¸é ±æµåÀÌ¸§°ú ·©Å©´Â ¹«È¿´Ù.
	cGuildStatus = *cp;
	cp++;

	// ±âº» ¸íÁß·üÀº 0%(¹æ¾î·ü°ú´Â ¾à°£ ÀÇ¹Ì°¡ ´Ù¸§. ¸Ç¼Õ°ø°Ý½ÃÀÇ ¸íÁß·üÀº µû·Î °è»êµÈ´Ù)
	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide = 0;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	// ¸®ÅÏ°ªÀÌ FALSEÀÌ¸é Å¬¶óÀÌ¾ðÆ® µ¥ÀÌÅÍ°¡ ¹«¾ð°¡ Àß¸øµÈ °Í. Å¬¶óÀÌ¾ðÆ®¸¦ »èÁ¦ÇÏ°í ¸®ÅÏÇÑ´Ù.
	if (bRet == FALSE) {
		wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, FALSE, TRUE); //!!!
		return;
	}
	if (m_bHappyHour == TRUE) {
		StarHappyHour();
	}
	// *******^^^^^^^^^^^^^^^^^^^^Æ¯¼ºÄ¡°ª ·Îµù ¿Ï·á^^^^^^^^^^^^^^^^^^^^^********
	//***************************************************************************

	// (!) Æ¯¼ºÄ¡¸¦ º¹±¸ÇÑ´Ù.
	___RestorePlayerCharacteristics(iClientH);

	// (!) Àß¸øµÈ Æ¯¼ºÄ¡¸¦ º¹±¸ÇÑ´Ù.
	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		// ÁÂÇ¥°¡ ¸ðµÎ -1ÀÌ¸é À§Ä¡ÇÑ ¸ÊÀÇ InitialPoint·Î °£´Ù.
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	if (m_pClientList[iClientH]->m_iLevel > 100)
		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
			ForceChangePlayMode(iClientH, FALSE);

	// ´ÙÀ½ ·¹º§ÀÇ °æÇèÄ¡¸¦ ±¸ÇÑ´Ù.
	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	// Æ¯¼ºÄ¡ Àç°è»ê.
	CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
	// ¹«°Ô °è»ê
	iCalcTotalWeight(iClientH);

	// New 23/05/2004
	//GM Invi comes here
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
	}

	if ((m_pClientList[iClientH]->m_iLevel > 2) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
			  (m_pClientList[iClientH]->m_iExp < iGetLevelExp(m_pClientList[iClientH]->m_iLevel - 1) - 3000)) {
		m_pClientList[iClientH]->m_iExp = iGetLevelExp(m_pClientList[iClientH]->m_iLevel - 1) - 3000;
		wsprintf(G_cTxt, "Problema, posible editaci�n: (%s) Jugador: (%s) tiene la experiencia bajo 0 - (Exp:%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iExp);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	iTotalPoints = 0;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
	if ((iTotalPoints - 21 > m_sCharSkillLimit) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) - has more than allowed skill points (%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, iTotalPoints);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// Æ¯¼ö ÀÌº¥Æ® °è»ê
	CheckSpecialEvent(iClientH);
	bCheckMagicInt(iClientH);

	// GuildNameÀÌ NONEÀÌ ¾Æ´Ï°í GuildStatus°¡ 0ÀÌ¸é Á¢¼ÓÁßÀÌ ¾Æ´Ò¶§ ±æµå°¡ Áö¿öÁ³´Ù´Â ÀÇ¹Ì.
	if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
		// ±æµå°¡ ºñÁ¢¼ÓÁßÀÏ¶§ »ç¶óÁ³À¸¹Ç·Î Áö±Ý ¾Ë·ÁÁØ´Ù.
		std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_GUILDDISBANDED, 0, 0, 0, m_pClientList[iClientH]->m_cGuildName);
	}

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, NULL);
		_bCheckIsQuestCompleted(iClientH);
	}


	// ¸Þ½ÃÁö Àü¼Û µµÁß ¿¡·¯°¡ ¹ß»ýÇÏ¿© Å¬¶óÀÌ¾ðÆ®°¡ »èÁ¦µÇ¾ú´Ù¸é Ã³¸® Á¾·á
	if (m_pClientList[iClientH] == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}


	std::memset(cData, 0, sizeof(cData));
	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = DEF_MSGTYPE_CONFIRM;

	// µ¥ÀÌÅÍ ÃÊ±âÈ­ È®ÀÎ ¸Þ½ÃÁö Àü¼Û
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			// ## BUG POINT!!! ¸ÕÀú ·Î±× ¸Þ½ÃÁö Ãâ·ÂÈÄ »èÁ¦ÇÑ´Ù.
			wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
			PutLogList(cTxt);

			DeleteClient(iClientH, FALSE, TRUE); //!!!!!
			return;
	}

	// Å¬¶óÀÌ¾ðÆ®ÀÇ µ¥ÀÌÅÍ°¡ ÃÊ±âÈ­ µÇ¾ú´Ù.
	m_pClientList[iClientH]->m_bIsInitComplete = TRUE;

	// ·Î±× ¼­¹ö¿¡°Ô ÀÌ °èÁ¤ÀÇ ÇÃ·¹ÀÌ¾î°¡ °ÔÀÓÁß¿¡ µé¾î¿ÔÀ½À» ¾Ë·ÁÁØ´Ù.
	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	// ¼­¹ö ´Ù¿îÀ» ¸·±âÀ§ÇÑ ÃÖÈÄÀÇ Á¶Ä¡ÀÌ´Ù.
	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();
	if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1, 2)) {
			case 1:
				RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
				break;
			case 2:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 0: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1);
						break;
					case 1: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1);
						break;
					case 2: RequestTeleportHandler(iClientH, "2   ", "resurr2", -1, -1);
						break;
				}
				break;
		}
	}

	PlayerOrder_GetSkills(iClientH);

	return;
}

void CGame::GameProcess() {
	NpcProcess();
	MsgProcess();
	DelayEventProcess();
}

BOOL CGame::bReadProgramConfigFile(const char * cFn) {
	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;
	char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "";
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;
	bool bLogDNS = false; // bLogDNS added by snaipperi

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		//	PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	} else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );
		while (token != NULL) {

			if (cReadMode != 0) {
				switch (cReadMode) {
					case 1:
						std::memset(m_cServerName, 0, sizeof(m_cServerName));
						if (strlen(token) > 10) {
							// ¼­¹öÀÇ ÀÌ¸§ÀÌ ³Ê¹« ±æ´Ù.
							wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
							PutLogList(cTxt);
							return FALSE;
						}
						strcpy(m_cServerName, token);
						wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 2:
						// v2.04 °ÔÀÓ¼­¹ö IP ÀÚµ¿À¸·Î ÀÎ½Ä
						std::memset(m_cGameServerAddr, 0, sizeof(m_cGameServerAddr));
						char ServerAddr[50];
						::gethostname(ServerAddr, 50);
						struct hostent *pHostEnt;
						pHostEnt = ::gethostbyname(ServerAddr);
						if (pHostEnt != NULL) {
							wsprintf(ServerAddr, "%d.%d.%d.%d",
									  (pHostEnt->h_addr_list[0][0] & 0x00ff),
									  (pHostEnt->h_addr_list[0][1] & 0x00ff),
									  (pHostEnt->h_addr_list[0][2] & 0x00ff),
									  (pHostEnt->h_addr_list[0][3] & 0x00ff));
						}
						strcpy(m_cGameServerAddr, ServerAddr);

						wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
						PutLogList(cTxt);

						m_iGameServerPort = atoi(token);
						wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 3:
						std::memset(m_cLogServerAddr, 0, sizeof(m_cLogServerAddr));

						if (bLogDNS == true) { //bLogDNS by Snaipperi
							PutLogList(cTxt);
							char *cAddress = token;
							char cDnsResult[40];
							struct hostent *host_entry;

							host_entry = gethostbyname(cAddress);
							if (host_entry == NULL) {
								wsprintf(cTxt, "(!)DNS (%s) failed", token);
								PutLogList(cTxt);
								return FALSE;
							}

							wsprintf(cDnsResult, "%d.%d.%d.%d",
									  (pHostEnt->h_addr_list[0][0] & 0x00ff),
									  (pHostEnt->h_addr_list[0][1] & 0x00ff),
									  (pHostEnt->h_addr_list[0][2] & 0x00ff),
									  (pHostEnt->h_addr_list[0][3] & 0x00ff));

							wsprintf(cTxt, "(!)DNS from (%s) to (%s) success!", token, cDnsResult);
							PutLogList(cTxt);
							strcpy(m_cLogServerAddr, cDnsResult);
							wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
							PutLogList(cTxt);
							cReadMode = 0;
							break;
						}

						if (strlen(token) > 20) {
							// �ּҰ� 15����Ʈ �̻�. �����.
							wsprintf(cTxt, "(!!!) Log server address(%s) must within 20 chars!", token);
							PutLogList(cTxt);
							return FALSE;
						}
						strcpy(m_cLogServerAddr, token);
						wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
						PutLogList(cTxt);
						cReadMode = 0;
						break;


					case 4:
						m_iLogServerPort = atoi(token);
						wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 5:
						// ¸ÊÀ» µî·ÏÇÑ´Ù.
						if (strlen(token) > 10) {
							// ¸ÊÀÇ ÀÌ¸§ÀÌ ³Ê¹« ±æ´Ù.
							wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
							PutLogList(cTxt);
							return FALSE;
						}
						if (_bRegisterMap(token) == FALSE) {
							return FALSE;
						}
						cReadMode = 0;
						break;

					case 8:
						std::memset(m_cGameServerAddrInternal, 0, sizeof(m_cGameServerAddrInternal));
						if (strlen(token) > 15) {
							// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù.
							wsprintf(cTxt, "(!!!) Internal (LAN) Game server address(%s) must within 15 chars!", token);
							PutLogList(cTxt);
							return FALSE;
						}
						strcpy(m_cGameServerAddrInternal, token);
						wsprintf(cTxt, "(*) Internal (LAN) Game server address : %s", m_cGameServerAddrInternal);
						PutLogList(cTxt);
						cReadMode = 0;
						break;


					case 9:
						std::memset(m_cGameServerAddrExternal, 0, sizeof(m_cGameServerAddrExternal));
						if (strlen(token) > 15) {
							// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù.
							wsprintf(cTxt, "(!!!) External (Internet) Game server address(%s) must within 15 chars!", token);
							PutLogList(cTxt);
							return FALSE;
						}
						strcpy(m_cGameServerAddrExternal, token);
						wsprintf(cTxt, "(*) External (Internet) Game server address : %s", m_cGameServerAddrExternal);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 10:
						std::memset(m_cGameServerAddr, 0, sizeof(m_cGameServerAddr));
						if (strlen(token) > 15) {
							// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù.
							wsprintf(cTxt, "(!!!) Game server address(%s) must within 15 chars!", token);
							PutLogList(cTxt);
							return FALSE;
						}
						strcpy(m_cGameServerAddr, token);
						wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
						PutLogList(cTxt);
						cReadMode = 0;
						break;
					case 11:
						if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0)) {
							m_iGameServerMode = 1;
							memcpy(cGSMode, "LAN", 3);
						}
						if ((memcmp(token, "internet", 3) == 0) || (memcmp(token, "INTERNET", 3) == 0)) {
							m_iGameServerMode = 2;
							memcpy(cGSMode, "INTERNET", 8);
						}
						if (m_iGameServerMode == 0) {
							wsprintf(cTxt, "(!!!) Game server mode(%s) must be either LAN/lan/INTERNET/internet", token);
							PutLogList(cTxt);
							return FALSE;
						}
						wsprintf(cTxt, "(*) Game server mode : %s", cGSMode);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 13: //Log DNS by Snaipperi
						if (memcmp(token, "true", 4) == 0) {
							bLogDNS = TRUE;
						} else bLogDNS = FALSE;
						wsprintf(cTxt, "Log DNS is set to %i", bLogDNS);
						PutLogList(cTxt);
						cReadMode = 0;
						break;
				}
			} else {
				if (memcmp(token, "game-server-name", 16) == 0) cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0) cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0) cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0) cReadMode = 5;
				if (memcmp(token, "game-server-internal-address", 28) == 0) cReadMode = 8;
				if (memcmp(token, "game-server-external-address", 28) == 0) cReadMode = 9;
				if (memcmp(token, "game-server-address", 19) == 0) cReadMode = 10;
				if (memcmp(token, "game-server-mode", 16) == 0) cReadMode = 11;
				if (memcmp(token, "log-server-dns", 14) == 0) cReadMode = 13;

			}
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	if (m_iGameServerMode == 0) {
		wsprintf(cTxt, "(!!!) Game server mode cannot be empty. It must be either LAN/lan/INTERNET/internet", token);
		PutLogList(cTxt);
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bReadSettingsConfigFile(const char * cFn) {
	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;
	char * cp, * token, cReadMode, cTxt[120], len;
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		//   PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	} else {
		PutLogList("(!) Reading settings file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );
		while (token != NULL) {

			if (cReadMode != 0) {
				switch (cReadMode) {

					case 1:
						if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) {
							m_iPrimaryDropRate = atoi(token);
						} else {
							wsprintf(cTxt, "(!!!) Primary drop rate(%s) invalid must be between 1 to 10000", token);
							PutLogList(cTxt);
						}
						wsprintf(cTxt, "(*) Primary drop rate: (%d)", m_iPrimaryDropRate);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 2:
						if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) {
							m_iSecondaryDropRate = atoi(token);
						} else {
							wsprintf(cTxt, "(!!!) Secondary drop rate(%s) invalid must be between 1 to 10000", token);
							PutLogList(cTxt);
						}
						wsprintf(cTxt, "(*) Secondary drop rate: (%d)", m_iSecondaryDropRate);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 3:
						if ((memcmp(token, "classic", 7) == 0) || (memcmp(token, "CLASSIC", 7) == 0)) {
							m_bEnemyKillMode = FALSE;
							wsprintf(cTxt, "(*) Enemy Kill Mode: CLASSIC");
							PutLogList(cTxt);
						} else if ((memcmp(token, "deathmatch", 10) == 0) || (memcmp(token, "DEATHMATCH", 10) == 0)) {
							m_bEnemyKillMode = TRUE;
							wsprintf(cTxt, "(*) Enemy Kill Mode: DEATHMATCH");
							PutLogList(cTxt);
						} else {
							wsprintf(cTxt, "(!!!) ENEMY-KILL-MODE: (%s) must be either DEATHMATCH or CLASSIC", token);
							PutLogList(cTxt);
							return FALSE;
						}
						cReadMode = 0;
						break;

					case 4:
						if ((strlen(token) != 0) && (strlen(token) <= 100) && (strlen(token) >= 1)) {
							m_iEnemyKillAdjust = atoi(token);
						} else {
							wsprintf(cTxt, "(!!!) ENEMY-KILL-ADJUST: (%s) invalid must be between 1 to 100", token);
							PutLogList(cTxt);
						}
						wsprintf(cTxt, "(*) Player gains (%d) EK per enemy kill.", m_iEnemyKillAdjust);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 5:
						if ((memcmp(token, "on", 2) == 0) || (memcmp(token, "ON", 2) == 0)) {
							m_bAdminSecurity = TRUE;
							wsprintf(cTxt, "(*) Administator actions limited through security.");
							PutLogList(cTxt);
						}
						if ((memcmp(token, "off", 3) == 0) || (memcmp(token, "OFF", 3) == 0)) {
							m_bAdminSecurity = FALSE;
							wsprintf(cTxt, "(*) Administator vulnerability ignored.");
							PutLogList(cTxt);
						}

						cReadMode = 0;
						break;

					case 6:
						m_sRaidTimeMonday = atoi(token);
						if (m_sRaidTimeMonday == 0) m_sRaidTimeMonday = 3;
						wsprintf(cTxt, "(*) Monday Raid Time : (%d) minutes", m_sRaidTimeMonday);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 7:
						m_sRaidTimeTuesday = atoi(token);
						if (m_sRaidTimeTuesday == 0) m_sRaidTimeTuesday = 3;
						wsprintf(cTxt, "(*) Tuesday Raid Time : (%d) minutes", m_sRaidTimeTuesday);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 8:
						m_sRaidTimeWednesday = atoi(token);
						if (m_sRaidTimeWednesday == 0) m_sRaidTimeWednesday = 3;
						wsprintf(cTxt, "(*) Wednesday Raid Time : (%d) minutes", m_sRaidTimeWednesday);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 9:
						m_sRaidTimeThursday = atoi(token);
						if (m_sRaidTimeThursday == 0) m_sRaidTimeThursday = 3;
						wsprintf(cTxt, "(*) Thursday Raid Time : (%d) minutes", m_sRaidTimeThursday);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 10:
						m_sRaidTimeFriday = atoi(token);
						if (m_sRaidTimeFriday == 0) m_sRaidTimeFriday = 10;
						wsprintf(cTxt, "(*) Friday Raid Time : (%d) minutes", m_sRaidTimeFriday);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 11:
						m_sRaidTimeSaturday = atoi(token);
						if (m_sRaidTimeSaturday == 0) m_sRaidTimeSaturday = 45;
						wsprintf(cTxt, "(*) Saturday Raid Time : (%d) minutes", m_sRaidTimeSaturday);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 12:
						m_sRaidTimeSunday = atoi(token);
						if (m_sRaidTimeSunday == 0) m_sRaidTimeSunday = 60;
						wsprintf(cTxt, "(*) Sunday Raid Time : (%d) minutes", m_sRaidTimeSunday);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 13:
						if ((memcmp(token, "player", 6) == 0) || (memcmp(token, "PLAYER", 6) == 0)) {
							m_bLogChatOption = 1;
							wsprintf(cTxt, "(*) Logging Player Chat.");
							PutLogList(cTxt);
						}
						if ((memcmp(token, "gm", 2) == 0) || (memcmp(token, "GM", 2) == 0)) {
							m_bLogChatOption = 2;
							wsprintf(cTxt, "(*) Logging GM Chat.");
							PutLogList(cTxt);
						}
						if ((memcmp(token, "all", 3) == 0) || (memcmp(token, "ALL", 3) == 0)) {
							m_bLogChatOption = 3;
							wsprintf(cTxt, "(*) Logging All Chat.");
							PutLogList(cTxt);
						}
						if ((memcmp(token, "none", 4) == 0) || (memcmp(token, "NONE", 4) == 0)) {
							m_bLogChatOption = 4;
							wsprintf(cTxt, "(*) Not Logging Any Chat.");
							PutLogList(cTxt);
						}
						cReadMode = 0;
						break;

					case 14:
						m_iSummonGuildCost = atoi(token);
						wsprintf(cTxt, "(*) Summoning guild costs (%d) gold", m_iSummonGuildCost);
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 15:
						m_sSlateSuccessRate = atoi(token);
						wsprintf(cTxt, "(*) Slate Success Rate (%d) percent", m_sSlateSuccessRate);
						PutLogList(cTxt);
						if (m_sSlateSuccessRate == 0) m_sSlateSuccessRate = 14;
						cReadMode = 0;
						break;

					case 16:
						m_sCharStatLimit = atoi(token);
						if (m_sCharStatLimit == 0) m_sCharStatLimit = 200;
						cReadMode = 0;
						break;

					case 17:
						m_sCharSkillLimit = atoi(token);
						if (m_sCharSkillLimit == 0) m_sCharSkillLimit = 700;
						cReadMode = 0;
						break;

					case 18:
						m_cRepDropModifier = atoi(token);
						wsprintf(cTxt, "(*) Rep<->Drop modifier: (%d)", m_cRepDropModifier);
						PutLogList(cTxt);
						if (m_cRepDropModifier < 0) m_cRepDropModifier = 0;
						cReadMode = 0;
						break;

					case 19:
						std::memset(m_cSecurityNumber, 0, sizeof(m_cSecurityNumber));
						len = strlen(token);
						if (len > 10) len = 10;
						memcpy(m_cSecurityNumber, token, len);
						wsprintf(cTxt, "(*) Security number memorized!");
						PutLogList(cTxt);
						cReadMode = 0;
						break;

					case 20:
						m_sMaxPlayerLevel = atoi(token);
						if (m_sMaxPlayerLevel == 0) m_sMaxPlayerLevel = 180;
						cReadMode = 0;
						break;

				}
			} else {
				if (memcmp(token, "primary-drop-rate", 17) == 0) cReadMode = 1;
				if (memcmp(token, "secondary-drop-rate", 19) == 0) cReadMode = 2;
				if (memcmp(token, "enemy-kill-mode", 15) == 0) cReadMode = 3;
				if (memcmp(token, "enemy-kill-adjust", 17) == 0) cReadMode = 4;
				if (memcmp(token, "admin-security", 14) == 0) cReadMode = 5;
				if (memcmp(token, "monday-raid-time", 16) == 0) cReadMode = 6;
				if (memcmp(token, "tuesday-raid-time", 17) == 0) cReadMode = 7;
				if (memcmp(token, "wednesday-raid-time", 19) == 0) cReadMode = 8;
				if (memcmp(token, "thursday-raid-time", 18) == 0) cReadMode = 9;
				if (memcmp(token, "friday-raid-time", 16) == 0) cReadMode = 10;
				if (memcmp(token, "saturday-raid-time", 18) == 0) cReadMode = 11;
				if (memcmp(token, "sunday-raid-time", 16) == 0) cReadMode = 12;
				if (memcmp(token, "log-chat-settings", 17) == 0) cReadMode = 13;
				if (memcmp(token, "summonguild-cost", 16) == 0) cReadMode = 14;
				if (memcmp(token, "slate-success-rate", 18) == 0) cReadMode = 15;
				if (memcmp(token, "character-stat-limit", 20) == 0) cReadMode = 16;
				if (memcmp(token, "character-skill-limit", 21) == 0) cReadMode = 17;
				if (memcmp(token, "rep-drop-modifier", 17) == 0) cReadMode = 18;
				if (memcmp(token, "admin-security-code", 19) == 0) cReadMode = 19;
				if (memcmp(token, "max-player-level", 16) == 0) cReadMode = 20;
			}

			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CGame::bReadCrusadeStructureConfigFile(char * cFn) {
	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;
	char * cp, * token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open Crusade configuration file.");
		return FALSE;
	} else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								// ½ºÆ®·°ÃÄ ¹øÈ£
								if (_bGetIsStringIsNumber(token) == FALSE) {
									PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);

								if (m_stCrusadeStructures[iIndex].cType != 0) {
									// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
									PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate portion number.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}

								cReadModeB = 2;
								break;

							case 2:
								// ¸Ê ÀÌ¸§
								std::memset(m_stCrusadeStructures[iIndex].cMapName, 0, sizeof(m_stCrusadeStructures[iIndex].cMapName));
								memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;


							case 3:
								// Á¾·ù
								if (_bGetIsStringIsNumber(token) == FALSE) {
									PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCrusadeStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								// À§Ä¡
								if (_bGetIsStringIsNumber(token) == FALSE) {
									PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCrusadeStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								// À§Ä¡
								if (_bGetIsStringIsNumber(token) == FALSE) {
									PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCrusadeStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			} else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}

			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize) {
	char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA, cReadModeB;
	int i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
	class CStrTok * pStrTok;
	short sTmpType, sTmpAppr1;
	BOOL bRet;
	int iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	BOOL bIsNotUsedItemFound = FALSE;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// ¼ÒÁöÇ° °Ë»ç¿ë
	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex = 0;
	iNotUsedItemPrice = 0;

	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize + 2];
	ZeroMemory(pContents, dwSize + 2);
	memcpy(pContents, pData, dwSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
				case 1:
					// ÇÃ·¹ÀÌ¾î°¡ ¼ÓÇØÀÖ´Â ¸Ê ÀÌ¸§À» ¾ò´Â´Ù.
					std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
					strcpy(m_pClientList[iClientH]->m_cMapName, token);
					// ÀÌÁ¦ ÀÌ ¸ÊÀÇ ÀÎµ¦½º°ªÀ» Ã£¾Æ ÇÒ´çÇÑ´Ù.
					std::memset(cTmpName, 0, sizeof(cTmpName));
					strcpy(cTmpName, token);
					for (i = 0; i < DEF_MAXMAPS; i++)
						if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
							// ¸ÊÀÇ ÀÎµ¦½º´Â iÀÌ´Ù.
							m_pClientList[iClientH]->m_cMapIndex = (char) i;
						}

					if (m_pClientList[iClientH]->m_cMapIndex == -1) {
						// ¸¸¾à ÇÃ·¹ÀÌ¾î°¡ ¼ÓÇÑ ¸ÊÀÌ Á¸ÀçÇÏÁö ¾Ê´Â´Ù¸é (ÀÌ·± °æ¿ì´Â ¹ß»ýÇÏ±â Èûµé´Ù. ·Î±× ¼­¹ö¿¡¼­ ¸ÕÀú °Ë»öÇÑ ÈÄ Á¢¼ÓÇÏ±â ¶§¹®)
						wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeA = 0;
					break;

				case 2:
					// ÇÃ·¹ÀÌ¾îÀÇ ¸Ê»óÀÇ À§Ä¡ X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_sX = atoi(token);
					cReadModeA = 0;
					break;

				case 3:
					// ÇÃ·¹ÀÌ¾îÀÇ ¸Ê»óÀÇ À§Ä¡ Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_sY = atoi(token);
					cReadModeA = 0;
					break;

				case 4:
					// ÇÃ·¹ÀÌ¾îÀÇ °èÁ¤ »óÅÂ¸¦ ¾ò´Â´Ù. <- ÀÌ ±â´ÉÀº ÇöÀç ¾²Áö ¾Ê´Â´Ù. °èÁ¤Á¤º¸´Â º°µµ·Î Àü´ÞµÇ¹Ç·Î
					/*
					if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
					}
					m_pClientList[iClientH]->m_cAccountStatus = atoi(token);
					 */
					cReadModeA = 0;
					break;

				case 5:
					// ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛ Á¤º¸¸¦ ÀÐ¾î ÃÊ±âÈ­ ÇÑ´Ù.
					switch (cReadModeB) {
						case 1:
							// New 07/05/2004
							// v2.12
							if (iItemIndex >= DEF_MAXITEMS) {
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							// token°ªÀº ¾ÆÀÌÅÛÀÇ ÀÌ¸§. ÀÌ ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀÇ Æ¯¼ºÀ» m_pItemConfigList¿¡¼­ Ã£¾Æ ÇÒ´çÇÑ´Ù.
							if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
								// ÇÃ·¹ÀÌ¾î°¡ ¼ÒÁöÇÑ ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Ù. ¿¡·¯
								wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token);
								PutLogList(cTxt);

								// Debug code @@@@@@@@@@@@@@@
								HANDLE hFile;
								DWORD nWrite;
								hFile = CreateFile("Error.Log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								WriteFile(hFile, (char *) pContents, dwSize + 2, &nWrite, NULL);
								CloseHandle(hFile);
								///////////// @@@@@@@@@@@@@@@

								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							// m_dwCount
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							// °¹¼ö°¡ ¸¶ÀÌ³Ê½ºÀÌ¸é 1À¸·Î ¼¼ÆÃµÈ´Ù.
							iTemp = atoi(token);
							if (iTemp < 0) iTemp = 1;
							//¸¸¾à Áß·®ÀÌ ÃÊ°úµÇ¾ú´Ù¸é 1°³·Î ÁÙÀÎ´Ù.
							if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH)) {
								iTemp = 1;
								wsprintf(G_cTxt, "(!) Player�(%s) Item (%s) too heavy for player to carry", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName);
								PutLogFileList(G_cTxt);
								PutLogList(G_cTxt);
							}

							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD) iTemp;
							cReadModeB = 3;

							// v1.3 ¼ÒÁöÇÏ°í ÀÖ´Â °ñµåÀÇ ÃÑ ÇÕÀ» °Ë»çÇÑ´Ù.
							if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
								iTotalGold += iTemp;
							break;

						case 3:
							// m_sTouchEffectType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// m_sTouchEffectValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// m_sTouchEffectValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							// m_sTouchEffectValue3
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
							cReadModeB = 7;
							break;

						case 7:
							// m_cItemColor
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
							cReadModeB = 8;
							break;

						case 8:
							// m_sItemSpecEffectValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
							cReadModeB = 9;
							break;

						case 9:
							// m_sItemSpecEffectValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
							cReadModeB = 10;
							break;

						case 10:
							// m_sItemSpecEffectValue3
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
							cReadModeB = 11;
							break;

						case 11:
							// m_wCurLifeSpan
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);

							cReadModeB = 12;
							break;

						case 12:
							// m_dwAttribute
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);

							// v1.4 °³ÀÎ °íÀ¯ ¾ÆÀÌÅÛÀ» È®ÀÎÇÑ´Ù.
							if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
								if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
										  (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
										  (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
									// ÀÚ½ÅÀÇ °ÍÀÌ ¾Æ´Ñ ¾ÆÀÌÅÛÀ» °®°í ÀÖ´Ù.
									wsprintf(cTxt, "(!) ´Ù¸¥ »ç¶÷ÀÇ ¾ÆÀÌÅÛ ¼ÒÁö: Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
											  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
											  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
											  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
											  m_pClientList[iClientH]->m_sCharIDnum1,
											  m_pClientList[iClientH]->m_sCharIDnum2,
											  m_pClientList[iClientH]->m_sCharIDnum3);
									PutLogList(cTxt);
									//PutLogFileList(cTxt);
								}
							}

							cReadModeA = 0;
							cReadModeB = 0;

							// v1.41 ¾ÆÀÌÅÛÀÌ Custom-Made¶ó¸é ¼³Á¤Ä¡¸¦ ÀçÁ¶Á¤ÇÑ´Ù.
							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
								// ÃÖ´ë ¼ö¸íÀÌ ItemSpecialEffectValue1
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
								// ¹«±â³ª ¹æ¾î±¸ÀÇ °æ¿ì °¡ÁßÄ¡ ItemSpecialEffectValue2
							}

							// v1.42 Èñ±Í ¾ÆÀÌÅÛ ÇÃ·¡±×°¡ ¼³Á¤µÇ¾î ÀÖ´Ù¸é ÃÖ´ë ¼ö¸í, ½ºÇÇµå, ¹«°Ô µîÀ» Àç¼³Á¤ ÇØ¾ß ÇÑ´Ù.
							_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

							// v1.41 ÇöÀç ¼ö¸í ÃÖ´ë ¼ö¸íÀ» ´É°¡ÇÏ¸é ¹ö±×ÀÌ¹Ç·Î µÇµ¹¸°´Ù.
							if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan)
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

							// v1.433
							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) &&
									  (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
								// ·Î±× ³²±ä´Ù.
								wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¼ö¸í 0Â¥¸® Èñ»ý¼® ¼ÒÁö!", m_pClientList[iClientH]->m_cCharName);
								PutLogFileList(G_cTxt);
								// ¼ö¸í 1·Î È¯¿ø
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
							}

							// v2.05 +´ë¹ÌÁö·ù ¾ÆÀÌÅÛ Æ¯¼ºÄ¡·Î Á¤º¸ º¯°æ, º¯È¯
							bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);

							// v1.4 ÀÌÁ¦ ÀÌ ¾ÆÀÌÅÛÀÌ ÇöÀç »ç¿ëÀÌ ÀÎÁ¤µÈ ¾ÆÀÌÅÛÀÎ°¡¸¦ Ã£´Â´Ù.
							if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
								iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
								delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
								m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

								// v1.41
								bIsNotUsedItemFound = TRUE;
							} else
								if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) == TRUE) {
								// v1.42 º¹Á¦µÈ ¾ÆÀÌÅÛµéÀ» »èÁ¦ÇÑ´Ù.
								_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

								iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
								delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
								m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
							} else iItemIndex++;
							break;
					}
					break;

				case 6:
					// Ä³¸¯ÅÍÀÇ ¼ºº°
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_cSex = atoi(token);
					cReadModeA = 0;
					break;

				case 7:
					// Ä³¸¯ÅÍÀÇ ÇÇºÎ»ö
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_cSkin = atoi(token);
					cReadModeA = 0;
					break;

				case 8:
					// Ä³¸¯ÅÍÀÇ Çì¾î ½ºÅ¸ÀÏ
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_cHairStyle = atoi(token);
					cReadModeA = 0;
					break;

				case 9:
					// Ä³¸¯ÅÍÀÇ ¸Ó¸®»ö
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_cHairColor = atoi(token);
					cReadModeA = 0;
					break;

				case 10:
					// Ä³¸¯ÅÍÀÇ ¼Ó¿Ê»ö
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_cUnderwear = atoi(token);
					cReadModeA = 0;
					break;

				case 11:
					// ¾ÆÀÌÅÛ ÀåÂø »óÅÂ°¡ ¹Ýµå½Ã ¸¶Áö¸·ÀÌ¾î¾ß ÇÑ´Ù!!!!!

					// ¾ÆÀÌÅÛ ÀåÂø »óÅÂ ÃÊ±âÈ­ÇÑ ÈÄ ¼³Á¤ÇÑ´Ù.
					for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
						m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

					// ¾ÆÀÌÅÛ ÀåÂø»óÅÂ¸¦ ÃÊ±âÈ­ÇÑ´Ù.
					for (i = 0; i < DEF_MAXITEMS; i++)
						m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

					// v1.41 »ç¿ëÇÏÁö ¾Ê´Â ¾ÆÀÌÅÛÀ» ¼ÒÁöÇÏ°í ÀÖ¾ú´Ù¸é ÀåÂø»óÅÂ¸¦ ¸ðµÎ ¹«½Ã.
					if (bIsNotUsedItemFound == FALSE) {
						for (i = 0; i < DEF_MAXITEMS; i++) {
							wsprintf(cTxt, "%d", token[i]);
							if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
								// ÀåÂøµÉ ¼ö ÀÖ´Â ¼ºÁúÀÇ ¾ÆÀÌÅÛÀÌ¶ó¸é ÀåÂø
								if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)
									m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
								else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
							} else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

							if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
								// ¾ÆÀÌÅÛÀÌ ÀåÂøµÇ¾î ÀÖ´Ù¸é ÀåÂø È¿°ú¸¦ °è»êÇÑ´Ù.
								if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
									m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; // ¸¸¾à Æ¯¼ºÄ¡ º¯µ¿À¸·Î ÀåÂøµÈ ¾ÆÀÌÅÛÀÌ ÀåÂøµÇÁö ¾Ê¾Æ¾ß ÇÑ´Ù¸é ÀåÂø ¾ÈÇÑ°ÍÀ» Ç¥½Ã
							}
						}
					}

					cReadModeA = 0;
					break;

				case 12:
					// ¼Ò¼Ó ±æµåÀÌ¸§À» ÃÊ±âÈ­ÇÑ´Ù.
					// ±æµå ÀÌ¸§Àº ÃÖ´ë 20ÀÚ
					std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
					strcpy(m_pClientList[iClientH]->m_cGuildName, token);
					cReadModeA = 0;
					break;

				case 13:
					// ±æµå ·©Å©
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iGuildRank = atoi(token);
					cReadModeA = 0;
					break;

				case 14:
					// HP
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iHP = atoi(token);
					cReadModeA = 0;
					break;

				case 15:
					// DefenseRatio »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«ÀÇ¹ÌÇØ Áü
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//m_pClientList[iClientH]->m_iOriginDefenseRatio = atoi(token);
					//m_pClientList[iClientH]->m_iCurDefenseRatio = m_pClientList[iClientH]->m_iOriginDefenseRatio;
					cReadModeA = 0;
					break;

				case 16:
					// HitRatio  »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«ÀÇ¹ÌÇØ Áü
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//m_pClientList[iClientH]->m_iOriginHitRatio = atoi(token);
					//m_pClientList[iClientH]->m_iCurHitRatio = m_pClientList[iClientH]->m_iOriginHitRatio;
					cReadModeA = 0;
					break;

				case 17:
					// Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iLevel = atoi(token);
					cReadModeA = 0;
					break;

				case 18:
					// Str
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iStr = atoi(token);
					cReadModeA = 0;
					break;

				case 19:
					// Int
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iInt = atoi(token);
					cReadModeA = 0;
					break;

				case 20:
					// Vit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iVit = atoi(token);
					cReadModeA = 0;
					break;

				case 21:
					// Dex
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iDex = atoi(token);
					cReadModeA = 0;
					break;

				case 22:
					// Mag
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iMag = atoi(token);
					cReadModeA = 0;
					break;

				case 23:
					// Charisma
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iCharisma = atoi(token);
					cReadModeA = 0;
					break;

				case 24:
					// Luck
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iLuck = atoi(token);
					cReadModeA = 0;
					break;

				case 25:
					// Exp
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iExp = atoi(token);
					cReadModeA = 0;
					break;

				case 26:
					// Magic-Mastery ¼³Á¤ÇÑ´Ù. // 0ÀÌ¸é »ç¿ë ºÒ°¡. 1ÀÌ¸é ¹è¿î »óÅÂ.
					for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
						m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
					}
					cReadModeA = 0;
					break;

				case 27:
					// Skill-Mastery ¼³Á¤ÇÑ´Ù.
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
					cReadModeB++;

					if (cReadModeB >= DEF_MAXSKILLTYPE) {
						cReadModeA = 0;
						cReadModeB = 0;
					}
					break;
					//
				case 28:
					// Warehouse¿¡ ¸Ã°Ü³í ¾ÆÀÌÅÛ Á¤º¸¸¦ ÀÐ¾î ÃÊ±âÈ­ ÇÑ´Ù.
					switch (cReadModeB) {
						case 1:
							if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							// token°ªÀº ¾ÆÀÌÅÛÀÇ ÀÌ¸§. ÀÌ ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀÇ Æ¯¼ºÀ» m_pItemConfigList¿¡¼­ Ã£¾Æ ÇÒ´çÇÑ´Ù.
							if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
								// ÇÃ·¹ÀÌ¾î°¡ ÀúÀåÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Ù. ¿¡·¯
								wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token);
								PutLogList(cTxt);

								// Debug code @@@@@@@@@@@@@@@
								HANDLE hFile;
								DWORD nWrite;
								hFile = CreateFile("Error.Log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
								WriteFile(hFile, (char *) pOriginContents, dwSize + 2, &nWrite, NULL);
								CloseHandle(hFile);
								///////////// @@@@@@@@@@@@@@@

								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							// m_dwCount
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							// °¹¼ö°¡ ¸¶ÀÌ³Ê½ºÀÌ¸é 1À¸·Î ¼¼ÆÃµÈ´Ù.
							iTemp = atoi(token);
							if (iTemp < 0) iTemp = 1;

							// ¸¸¾à °¡Áú ¼ö ÀÖ´Â Áß·®ÀÌ ÃÊ°úµÈ ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é 1°³·Î ÁÙÀÎ´Ù.
							if (iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH)) {
								iTemp = 1;
								wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¾ÆÀÌÅÛ(%s) °³¼ö ¿À¹öÇÃ·Î¿ì", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName);
								PutLogFileList(G_cTxt);
								PutLogList(G_cTxt);
							}

							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD) iTemp;
							cReadModeB = 3;

							// v1.3 ¼ÒÁöÇÏ°í ÀÖ´Â °ñµåÀÇ ÃÑ ÇÕÀ» °Ë»çÇÑ´Ù.
							if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
								iTotalGold += iTemp;
							break;

						case 3:
							// m_sTouchEffectType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// m_sTouchEffectValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// m_sTouchEffectValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							// m_sTouchEffectValue3
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
							cReadModeB = 7;
							break;

						case 7:
							// m_cItemColor
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
							cReadModeB = 8;
							break;

						case 8:
							// m_sItemSpecEffectValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
							cReadModeB = 9;
							break;

						case 9:
							// m_sItemSpecEffectValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
							cReadModeB = 10;
							break;

						case 10:
							// m_sItemSpecEffectValue3
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
							cReadModeB = 11;
							break;

						case 11:
							// m_wCurLifeSpan
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

							cReadModeB = 12;
							break;


						case 12:
							// m_dwAttribute
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;

							// v1.41 ¾ÆÀÌÅÛÀÌ Custom-Made¶ó¸é ¼³Á¤Ä¡¸¦ ÀçÁ¶Á¤ÇÑ´Ù.
							if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != 0) {
								// ÃÖ´ë ¼ö¸íÀÌ ItemSpecialEffectValue1
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
								// ¹«±â³ª ¹æ¾î±¸ÀÇ °æ¿ì °¡ÁßÄ¡ ItemSpecialEffectValue2

							}

							// v2.16 2002-5-21 °í±¤Çö¼öÁ¤
							int iValue = (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
							if (iValue > 0) {
								// ¾÷±×·¹ÀÌµå µÈ ¾ÆÀÌÅÛ. ¹æ¾î±¸³ª ¹æÆÐ¶ó¸é ÃÖ´ë ¼ö¸íÀ» ItemSpecialEffectValue1·Î ¼³Á¤ÇÑ´Ù.
								switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
									case 5: // ¹æÆÐ
									case 6: // ¹æ¾î±¸
										m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
										break;
								}
							}

							// v1.42 Èñ±Í ¾ÆÀÌÅÛ ÇÃ·¡±×°¡ ¼³Á¤µÇ¾î ÀÖ´Ù¸é ÃÖ´ë ¼ö¸í, ½ºÇÇµå, ¹«°Ô µîÀ» Àç¼³Á¤ ÇØ¾ß ÇÑ´Ù.
							_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

							// v1.41 ¼ö¸íÀÌ ÃÖ´ë¼ö¸íÀ» ÃÊ°úÇÑ´Ù¸é ¹ö±×ÀÌ¹Ç·Î µÇµ¹¸°´Ù.
							if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;


							// v1.433
							if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) &&
									  (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
								// ·Î±× ³²±ä´Ù.
								wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¼ö¸í 0Â¥¸® Èñ»ý¼® ¼ÒÁö!", m_pClientList[iClientH]->m_cCharName);
								PutLogFileList(G_cTxt);
								// ¼ö¸í 1·Î È¯¿ø
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
							}

							// v1.4 ÀÌÁ¦ ÀÌ ¾ÆÀÌÅÛÀÌ ÇöÀç »ç¿ëÀÌ ÀÎÁ¤µÈ ¾ÆÀÌÅÛÀÎ°¡¸¦ Ã£´Â´Ù.
							if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
								iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
								delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
							} else
								if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) == TRUE) {
								// v1.42 º¹Á¦µÈ ¾ÆÀÌÅÛµéÀ» »èÁ¦ÇÑ´Ù.
								_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, 0, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

								iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
								delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
							} else iItemInBankIndex++;
							break;
					}
					break;
					//

				case 29:
					// ÇÃ·¹ÀÌ¾î ¼Ò¼ÓÀÇ ¸¶À»À» ÃÊ±âÈ­ÇÑ´Ù.
					std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
					strcpy(m_pClientList[iClientH]->m_cLocation, token);
					if (memcmp(m_pClientList[iClientH]->m_cLocation + 3, "hunter", 6) == 0)
						m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
					cReadModeA = 0;
					break;

					/* 2.03 Code - Fixed by KLKS
								case 29:
									// ÇÃ·¹ÀÌ¾î ¼Ò¼ÓÀÇ ¸¶À»À» ÃÊ±âÈ­ÇÑ´Ù.
									std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
									strcpy(m_pClientList[iClientH]->m_cLocation, token);
									cReadModeA = 0;
									break;
					 */
				case 30:
					// m_iMP
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iMP = atoi(token);
					cReadModeA = 0;
					break;

				case 31:
					// m_iSP
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iSP = atoi(token);
					cReadModeA = 0;
					break;

				case 32:
					// m_cLU_Pool
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
					cReadModeA = 0;
					break;
					/*
					case 33:
						// m_cLU_Vit
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cLU_Vit = atoi(token);
						cReadModeA = 0;
						break;

					case 34:
						// m_cLU_Dex
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cLU_Dex = atoi(token);
						cReadModeA = 0;
						break;

					case 35:
						// m_cLU_Int
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cLU_Int = atoi(token);
						cReadModeA = 0;
						break;

					case 36:
						// m_cLU_Mag
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cLU_Mag = atoi(token);
						cReadModeA = 0;
						break;

					case 37:
						// m_cLU_Char
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cLU_Char = atoi(token);
						cReadModeA = 0;
						break;
					 */
				case 38:
					// m_iEnemyKillCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
					cReadModeA = 0;
					break;

				case 39:
					// m_iPKCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iPKCount = atoi(token);
					cReadModeA = 0;
					break;

				case 40:
					// m_iRewardGold
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iRewardGold = atoi(token);
					cReadModeA = 0;
					break;

				case 41:
					// Skill-SSN ¼³Á¤ÇÑ´Ù.
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
					cReadModeB++;

					if (cReadModeB >= DEF_MAXSKILLTYPE) {
						cReadModeA = 0;
						cReadModeB = 0;
					}
					break;

				case 42:
					if (token != NULL) {
						std::memset(m_pClientList[iClientH]->m_cProfile, 0, sizeof(m_pClientList[iClientH]->m_cProfile));
						strcpy(m_pClientList[iClientH]->m_cProfile, token);
					}
					cReadModeA = 0;
					break;

				case 43:
					// Hunger-Status ¼³Á¤ÇÑ´Ù.
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
					cReadModeA = 0;
					break;

				case 44:
					// AdminUserLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iAdminUserLevel = 0; //Default it to 0
					if (atoi(token) > 0) {
						for (i = 0; i < DEF_MAXADMINS; i++) {
							if (strlen(m_stAdminList[i].m_cGMName) == 0) break; //No more GM's on list
							if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
								if (memcmp(m_stAdminList[i].m_cGMName, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) == 0) {
									m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
									break; //Break goes to cReadModeA = 0;, so no need to do it again
								}
							}
						}
					}
					cReadModeA = 0;
					break;

					/*case 44:
					// AdminUserLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					for (i = 0; i < DEF_MAXADMINS; i++) {
						if (atoi(token) > 0) {
							if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
								m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
								cReadModeA = 0;
								break;
							}
							else {
								m_pClientList[iClientH]->m_iAdminUserLevel = 0;
							}
						else m_pClientList[iClientH]->m_iAdminUserLevel = 0;
						}
					}
					cReadModeA = 0;
					break;*/

				case 45:
					// TimeLeft_ShutUp
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
					cReadModeA = 0;
					break;

				case 46:
					// TimeLeft_Rating
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
					cReadModeA = 0;
					break;

				case 47:
					// Rating
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iRating = atoi(token);
					cReadModeA = 0;
					break;

				case 48:
					// Guild GUID: ÀÌÀü¿¡ »ý¼ºµÇ¾ú´ø ±æµåµéÀº ¸ðµÎ -1ÀÌ µÇ ¹ö¸± °ÍÀÌ´Ù.
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
					cReadModeA = 0;
					break;

				case 49:
					// Down Skill Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
					cReadModeA = 0;
					break;

				case 50:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].x = atoi(token);
					if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].x < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].x = -10; //KaoZureS adaptado darmart123
					cReadModeB++;
					if (cReadModeB > 50) {
						cReadModeA = 0;
						cReadModeB = 0;
					}
					break;

				case 51:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].y = atoi(token);
					// v1.3 Àß¸øµÈ À§Ä¡°ªÀ» º¸Á¤ÇÑ´Ù.
					if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].y = -10;
					cReadModeB++;
					if (cReadModeB > 50) {
						cReadModeA = 0;
						cReadModeB = 0;
					}
					break;

				case 52:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
					cReadModeA = 0;
					break;

				case 53:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
					cReadModeA = 0;
					break;

				case 54:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
					cReadModeA = 0;
					break;

				case 55:
					switch (cReadModeB) {
						case 1:
							// Penalty Block Year
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);

							cReadModeB = 2;
							break;

						case 2:
							// Penalty Block Month
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							// Penalty Block day
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 56:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iQuest = atoi(token);
					cReadModeA = 0;
					break;

				case 57:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
					cReadModeA = 0;
					break;

				case 58:
					cReadModeA = 0;
					break;

				case 59:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
					cReadModeA = 0;
					break;

				case 60:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
					cReadModeA = 0;
					break;

				case 61:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iContribution = atoi(token);
					cReadModeA = 0;
					break;

				case 62:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iQuestID = atoi(token);
					cReadModeA = 0;
					break;

				case 63:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL) atoi(token);
					cReadModeA = 0;
					break;

				case 64:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL) atoi(token);
					cReadModeA = 0;
					break;

				case 65:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL) atoi(token);
					cReadModeA = 0;
					break;

				case 66:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iSpecialEventID = (BOOL) atoi(token);
					cReadModeA = 0;
					break;

					// v1.4311-3 Ãß°¡ »çÅõÀå ¿¹¾à¿¡ °ü°èµÈ ÆÄÀÏ ³»¿ë ÀÐ±â
				case 67:
					switch (cReadModeB) {
						case 1:
							// FightZone Number
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);

							cReadModeB = 2;
							break;

						case 2:
							// ¿¹¾àÇÑ ½Ã°£
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_iReserveTime = atoi(token);


							cReadModeB = 3;
							break;
						case 3:
							// ³²Àº Æ¼ÄÏ¼ýÀÚ
							if (_bGetIsStringIsNumber(token) == FALSE) {
								wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;

					}
					break;

				case 70:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL) atoi(token);
					cReadModeA = 0;
					break;

				case 71:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
					cReadModeA = 0;
					break;

				case 72:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iWarContribution = atoi(token);
					cReadModeA = 0;
					break;

				case 73:
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
					cReadModeA = 0;
					break;

				case 74:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
					cReadModeA = 0;
					break;

				case 75:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
					cReadModeA = 0;
					break;

				case 76:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
					cReadModeA = 0;
					break;

				case 77:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
					cReadModeA = 0;
					break;

				case 78:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
					cReadModeA = 0;
					break;

				case 79: // v2.06 12-4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iPartyID = atoi(token);
					if (m_pClientList[iClientH]->m_iPartyID != 0) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
					cReadModeA = 0;
					break;

				case 80: // v2.15 ÁöÁ¸¾ÆÀÌÅÛ¾÷±×·¹ÀÌµå
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
					cReadModeA = 0;
					break;
				case 81:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! (BallPoints) - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pClientList[iClientH]->m_iBallPoints = atoi(token);
					cReadModeA = 0;
					break;
			}
		} else {
			if (memcmp(token, "character-loc-map", 17) == 0) cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0) cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0) cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0) cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}

			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}

			if (memcmp(token, "sex-status", 10) == 0) cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0) cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0) cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0) cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0) cReadModeA = 10;

			if (memcmp(token, "item-equip-status", 17) == 0) cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0) cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio", 22) == 0) cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0) cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0) cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0) cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0) cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0) cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0) cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0) cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0) cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0) cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0) cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0) cReadModeA = 26;

			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}

			if (memcmp(token, "character-location", 18) == 0) cReadModeA = 29;

			if (memcmp(token, "character-MP", 12) == 0) cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0) cReadModeA = 31;

			if (memcmp(token, "character-LU_Pool", 17) == 0) cReadModeA = 32;

			/*
			if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
			if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;
			 */

			if (memcmp(token, "character-EK-Count", 18) == 0) cReadModeA = 38;
			if (memcmp(token, "character-PK-Count", 18) == 0) cReadModeA = 39;

			if (memcmp(token, "character-reward-gold", 21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0) cReadModeA = 42;

			if (memcmp(token, "hunger-status", 13) == 0) cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0) cReadModeA = 47;

			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;

			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 16) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 16) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1", 16) == 0) cReadModeA = 52;
			if (memcmp(token, "character-IDnum2", 16) == 0) cReadModeA = 53;
			if (memcmp(token, "character-IDnum3", 16) == 0) cReadModeA = 54;
			if (memcmp(token, "penalty-block-date", 18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}

			if (memcmp(token, "character-quest-number", 22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count", 19) == 0) cReadModeA = 57;

			if (memcmp(token, "quest-reward-type", 17) == 0) cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0) cReadModeA = 60;

			if (memcmp(token, "character-contribution", 22) == 0) cReadModeA = 61;
			if (memcmp(token, "character-quest-ID", 18) == 0) cReadModeA = 62;
			if (memcmp(token, "character-quest-completed", 25) == 0) cReadModeA = 63;

			if (memcmp(token, "timeleft-force-recall", 21) == 0) cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0) cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0) cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0) cReadModeA = 70;

			// v1.4311-3 Ãß°¡ ¿ùµå ¼­¹ö·Î ºÎÅÍ¿Â ¸Þ¼¼Áö·ÎºÎÅÍ ¿¹¾àµÈ »çÅõÀå¿¡ °üÇÑ °ª ÀÐ±â reserved-fightzone-id
			if (memcmp(token, "reserved-fightzone-id", 21) == 0) {
				cReadModeA = 67;
				cReadModeB = 1;
			}

			if (memcmp(token, "special-ability-time", 20) == 0) cReadModeA = 71;
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72;

			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0) cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0) cReadModeA = 77;

			if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0) cReadModeA = 79; // v2.06 12-4
			if (memcmp(token, "gizon-item-upgade-left", 22) == 0) cReadModeA = 80; // v2.15 ÁöÁ¸¾ÆÀÌÅÛ¾÷±×·¹ÀÌµå
			if (memcmp(token, "character-ball-points", 21) == 0) cReadModeA = 81;
			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}

		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}

DPDC_STOP_DECODING:
	;

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);

		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		WriteFile(hFile2, (char *) pOriginContents, dwSize + 2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@

		return FALSE;
	}

	// ÀÐÇôÁø ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ¸¦ °Ë»çÇØ¼­ ¿À·ù°¡ ¾ø´ÂÁö¸¦ È®ÀÎÇÏ¿© ¸®ÅÏ°ªÀ» °áÁ¤ÇÑ´Ù.
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			PutLogList(cTxt);
			return FALSE;
		}
	}

	// Æ¯¼ºÄ¡ °ª¿¡ ¿À·ù°¡ ÀÖ´ÂÁö °Ë»ç ==========================================================================
	/*	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0))
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0))
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0))
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0))
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0))
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0))
	return FALSE;
	 */
	//	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex +
	//  		  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT)
	if ((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
		return FALSE;

	//Æ¯¼ºÄ¡ÀÇ ÃÑ ÇÕÀÌ ¸ÂÁö ¾Ê´Ù¸é ¿ª½Ã Á¢¼Ó ºÒ°¡.
	//	if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
	//		 m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma)
	//		 !=	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) return FALSE;


	// Ã¼ÇèÆÇ »ç¿ëÀÚÀÇ µ¥ÀÌÅÍÀÎµ¥ Á¦ÇÑ ·¹º§ ÀÌ»óÀÌ´Ù. Á¢¼ÓÀÌ ºÒ°¡´É. v1.43ºÎÅÍ »ç¿ëÇÏÁö ¾Ê´Â´Ù.
	//if ((m_pClientList[iClientH]->m_cAccountStatus != 2) && (m_pClientList[iClientH]->m_iLevel > DEF_LEVELLIMIT))
	//	return FALSE;

	// v1.4 °èÁ¤ÀÌ¸§ÀÌ³ª Ä³¸¯ÅÍ ÀÌ¸§¿¡ Àß¸øµÈ ÄÚµå°¡ µé¾î°¡ ÀÖ´Ù¸é Á¢¼Ó ºÒ°¡.
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE))
		return FALSE;

	// v1.4 Â¡°è ¸ÔÀº Ä³¸¯ÅÍÀÇ Â¡°è±â°£ ¾ÈÀÌ¸é Á¢¼Ó ºÒ°¡
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64) (m_pClientList[iClientH]->m_iPenaltyBlockYear * 10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth * 100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64) (SysTime.wYear * 10000 + SysTime.wMonth * 100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}

	// v1.4311-3 Ãß°¡ À¯È¿ÇÏÁö ¾ÊÀº »çÅõÀå ¿¹¾àÀ» °¡Áö°í ÀÖÀ¸¸é ÃÊ±âÈ­
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64) m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64) (SysTime.wMonth * 10000 + SysTime.wDay * 100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			// ¿¹¾àÀÌ Ãë¼ÒµÊ
			SendNotifyMsg(0, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, 0, 0, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0;
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}

	// v1.42 Àß¸ø ÀÔ·ÂµÈ ¿î¿µÀÚ ·¹º§ °ªÀ» Å¬¸®¾î
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

	// ============================================================================================================


	// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
	if (m_pClientList[iClientH]->m_cSex == 1) {
		// ³²ÀÚÀÌ´Ù.
		sTmpType = 1;
	} else if (m_pClientList[iClientH]->m_cSex == 2) {
		// ¿©ÀÚÀÌ´Ù.
		sTmpType = 4;
	}

	switch (m_pClientList[iClientH]->m_cSkin) {
		case 1:
			// ¹éÀÎÀÌ¸é ±×´ë·Î.
			break;
		case 2:
			sTmpType += 1;
			break;
		case 3:
			sTmpType += 2;
			break;
	}

	// v1.41 ¿î¿µÀÚ ¾ÏÇà¿ë
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10)
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	// ¼ÒÁöÇ° ÃÑ Áß·®°è»ê
	iCalcTotalWeight(iClientH);

	// v1.3 Áö³ªÄ¡°Ô ¸¹Àº µ·À» ¼ÒÁöÇÑ Ä³¸¯ÅÍ ÀÌ¸§À» Àû´Â´Ù.
	//if (iTotalGold > 800000) {
	//	wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) Gold(%d)", m_pClientList[iClientH]->m_cCharName, iTotalGold);
	//PutLogFileList(G_cTxt);
	//}

	// v.135
	/*
	if ((m_pClientList[iClientH]->m_cSkillMastery[0] >= 70) || (m_pClientList[iClientH]->m_cSkillMastery[1] >= 70) ||
	(m_pClientList[iClientH]->m_cSkillMastery[12] >= 70)) {
	wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) ³ôÀº ½ºÅ³ (%d %d %d)", m_pClientList[iClientH]->m_cCharName,
	m_pClientList[iClientH]->m_cSkillMastery[0], m_pClientList[iClientH]->m_cSkillMastery[1],
	m_pClientList[iClientH]->m_cSkillMastery[12]);
	PutLogFileList(G_cTxt);
	}
	 */

	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		// v1.3 ÀÌ Ä³¸¯ÅÍÀÇ ID ¹øÈ£°¡ ºÎ¿©µÇÁö ¾ÊÀº »óÅÂÀÌ´Ù. ÇÒ´çÇÑ´Ù.
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}

		_sID1 = (short) timeGetTime();
		_sID2 = (short) _iTemp1;
		_sID3 = (short) _iTemp2;

		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	// v1.4 ¾ø¾îÁø ¾ÆÀÌÅÛ¿¡ ´ëÇÑ º¸»ó±ÝÀ» Áö±Þ.
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;

	//
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;

	// v1.41
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) m_pClientList[iClientH]->m_bIsNeutral = TRUE;

	return TRUE;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData) {
	SYSTEMTIME SysTime;
	char cTxt[120], cTmp[21];
	POINT TempItemPosList[DEF_MAXITEMS];
	int i, iPos;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");

	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// ÀÌ¸§ ÀúÀå
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	// Ä³¸¯ÅÍ ÇÁ·ÎÇÊ
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		// Ä³¸¯ÅÍ ÇÁ·ÎÇÊÀÌ ¼³Á¤µÇÁö ¾Ê¾Ò´Ù¸é
		strcat(pData, "__________");
	} else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");

	// ÇÃ·¹ÀÌ¾î ¼Ò¼Ó À§Ä¡
	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");

	/// ±æµå »óÅÂ
	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank°¡ -1ÀÌ¸é ±æµåÀÌ¸§Àº ¹«ÀÇ¹ÌÇÏ´Ù.
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	} else strcat(pData, "NONE");
	strcat(pData, "\n");

	// ±æµå GUID
	strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank°¡ -1ÀÌ¸é ±æµåGUID´Â ¹«ÀÇ¹ÌÇÏ´Ù.
		std::memset(cTxt, 0, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	} else strcat(pData, "-1");
	strcat(pData, "\n");

	// ±æµå ¼øÀ§
	strcat(pData, "character-guild-rank = ");
	itoa(m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	// XÁÂÇ¥ ÀúÀå
	strcat(pData, "character-loc-x   = ");
	itoa(m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// YÁÂÇ¥ ÀúÀå
	strcat(pData, "character-loc-y   = ");
	itoa(m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	//
	if (m_pClientList[iClientH]->m_iHP <= 0)
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH); //50Cent - 30HP CL Fix

	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-MP       = %d", m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d", m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-LU_Pool  = %d", m_pClientList[iClientH]->m_iLU_Pool);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	/*
	wsprintf(cTxt, "character-LU_Str   = %d", m_pClientList[iClientH]->m_cLU_Str);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Vit   = %d", m_pClientList[iClientH]->m_cLU_Vit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Dex   = %d", m_pClientList[iClientH]->m_cLU_Dex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Int   = %d", m_pClientList[iClientH]->m_cLU_Int);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Mag   = %d", m_pClientList[iClientH]->m_cLU_Mag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Char  = %d", m_pClientList[iClientH]->m_cLU_Char);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	 */
	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-reward-gold = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	/*
	wsprintf(cTxt, "party-rank = %d", m_pClientList[iClientH]->m_iPartyRank);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum1 = %d", m_pClientList[iClientH]->m_sPartyIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum2 = %d", m_pClientList[iClientH]->m_sPartyIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum3 = %d", m_pClientList[iClientH]->m_sPartyIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");
	 */

	//
	// ÇÃ·¹ÀÌ¾î Æ¯¼ºÄ¡ ÀÔ·Â
	strcat(pData, "sex-status       = ");
	itoa(m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa(m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa(m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa(m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa(m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "admin-user-level = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "penalty-block-date = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-quest-completed = %d", (int) m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "special-event-id = %d", (int) m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "super-attack-left = %d", (int) m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// v1.4311-3 Ãß°¡ ¿ùµå¼­¹ö¿¡ »çÅõÀå °ü·Ã º¯¼ö¸¦ º¸³½´Ù.
	// »çÅõÀå ¿¹¾à °ü·ÃµÈ ³»¿ë ÀúÀå reserved-fightzone-id ¿¹¾àµÈ »çÅõÀå¹øÈ£/³¯Â¥¹×½Ã°£/³²ÀºÆ¼ÄÏ°¹¼ö
	wsprintf(cTxt, "reserved-fightzone-id = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime, m_pClientList[iClientH]->m_iFightZoneTicketNumber);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// Æ¯¼ö ´É·Â ¹ßÈÖ¿ë ³²Àº ½Ã°£
	wsprintf(cTxt, "special-ability-time = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// Àá±ä ¸Ê ÀÌ¸§
	wsprintf(cTxt, "locked-map-name = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// Àá±ä ¸Ê ½Ã°£
	wsprintf(cTxt, "locked-map-time = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// Å©·ç¼¼ÀÌµå¿¡¼­ ¸ÃÀº Á÷Ã¥.
	wsprintf(cTxt, "crusade-job = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// Å©·ç¼¼ÀÌµå °íÀ¯ ¾ÆÀÌµð
	wsprintf(cTxt, "crusade-GUID = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "construct-point = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// v2.04 »ç¸Á½Ã Æä³ÎÆ¼ Å¸ÀÓ
	wsprintf(cTxt, "dead-penalty-time = %d", m_pClientList[iClientH]->m_iDeadPenaltyTime);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// v2.06 12-4 ÆÄÆ¼ ¾ÆÀÌµð
	wsprintf(cTxt, "party-id = 0", m_pClientList[iClientH]->m_iPartyID);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "character-ball-points = %d", m_pClientList[iClientH]->m_iBallPoints);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	// v2.15 ÁöÁ¸¾ÆÀÌÅÛ¾÷±×·¹ÀÌµå
	wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	/*wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");*/

	strcat(pData, "\n\n");

	// Ä³¸¯ÅÍÀÇ ¿ÜÇüÇ¥Çö Appr4°³¸¦ ÀúÀåÇÑ´Ù. ÀÌ°ÍÀº °ÔÀÓ¼­¹ö¿¡¼­´Â »ç¿ëÇÏÁö ¾ÊÀ¸¸ç ·Î±×¼­¹ö->Å¬¶óÀÌ¾ðÆ®°£¿¡ »ç¿ëµÈ´Ù.
	strcat(pData, "appr1 = ");
	itoa(m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	// ÀüÅõ¸ðµå ÇÃ·¡±×¸¦ Å¬¸®¾îÇÑ´Ù.
	//m_pClientList[iClientH]->m_sAppr2 = m_pClientList[iClientH]->m_sAppr2 & 0x0FFF;
	itoa(m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa(m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa(m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa(m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	// ¾ÆÀÌÅÛ Á¤º¸ ÀúÀå
	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
		TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;

	// °¢°¢ÀÇ ¾ÆÀÌÅÛÀ» ÀúÀåÇÑ´Ù.
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			// v1.4 ¾ÆÀÌÅÛ ¼ø¼­¸¦ Àç¹èÄ¡ÇÑ´Ù.
			TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
			TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
			iPos++;

			strcat(pData, "character-item = ");
			memset(cTmp, ' ', 21);
			strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
			cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char) ' ';
			cTmp[20] = 0;
			strcat(pData, cTmp);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, "\n");
		}
	strcat(pData, "\n\n");

	// v1.4 Àç °è»êµÈ ¾ÆÀÌÅÛ À§Ä¡ ±â¾ï
	for (i = 0; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x;
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
			strcat(pData, "character-bank-item = ");
			memset(cTmp, ' ', 21);
			strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
			cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char) ' ';
			cTmp[20] = 0;
			strcat(pData, cTmp);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, " ");
			itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
			strcat(pData, cTxt);
			strcat(pData, "\n");
		}
	strcat(pData, "\n\n");


	strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData, "\n");

	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt, "%d", (int) m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");

	strcat(pData, "skill-mastery     = ");


	for (i = 0; i < 60; i++) {
		std::memset(cTxt, 0, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

		strcat(pData, cTxt); // ÃÊ±â°ª ÀÔ·Â
	}
	strcat(pData, "\n");

	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		std::memset(cTxt, 0, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

		strcat(pData, cTxt); // ÃÊ±â°ª ÀÔ·Â
	}
	strcat(pData, "\n");

	// ¾ÆÀÌÅÛ ÀåÂø »óÅÂ¸¦ ÀúÀåÇÑ´Ù. ¹Ýµå½Ã ¸Ç ¸¶Áö¸·¿¡ ÀÖ¾î¾ß ÇÔ.
	strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
	strcat(pData, "item-equip-status = ");

	std::memset(cTxt, 0, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");

	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) &&
					  (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
				cTxt[iEP] = '1';
			}
			iEP++;
		}
	strcat(pData, cTxt);
	strcat(pData, "\n");


	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		std::memset(cTxt, 0, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");

	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		std::memset(cTxt, 0, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");

	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");

	return strlen(pData);
}

BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize) {
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int iItemConfigListIndex, iTemp;
	class CStrTok * pStrTok;

	pContents = new char[dwMsgSize + 1];
	ZeroMemory(pContents, dwMsgSize + 1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok( pContents, seps );
	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iItemConfigListIndex = atoi(token);

							//testcode
							if (iItemConfigListIndex == 490)
								iItemConfigListIndex = atoi(token);

							// ¸¸¾à ÀÌ¹Ì ÀÌ·± ¾ÆÀÌ °ªÀ» °¡Áø ¾ÆÀÌÅÛÀÌ Á¤ÀÇµÇ¾î ÀÖ´Ù¸é ¿¡·¯ÀÌ´Ù.
							if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
								// ÀÌ¹Ì °°Àº °íÀ¯¹øÈ£¸¦ °¡Áø ¾ÆÀÌÅÛÀÌ Á¤ÀÇµÇ¾î ÀÖ´Ù. Áßº¹ Á¤ÀÇ ¿¡·¯!
								wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex] = new class CItem;
							m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
							cReadModeB = 2;
							break;
						case 2:
							// m_cName
							std::memset(m_pItemConfigList[iItemConfigListIndex]->m_cName, 0, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
							memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
							cReadModeB = 3;
							break;
						case 3:
							// m_cItemType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
							cReadModeB = 4;
							break;
						case 4:
							// m_cEquipPos
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
							cReadModeB = 5;
							break;
						case 5:
							// m_sItemEffectType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
							cReadModeB = 6;
							break;
						case 6:
							// m_sItemEffectValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
							cReadModeB = 7;
							break;
						case 7:
							// m_sItemEffectValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
							cReadModeB = 8;
							break;
						case 8:
							// m_sItemEffectValue3
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
							cReadModeB = 9;
							break;
						case 9:
							// m_sItemEffectValue4
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
							cReadModeB = 10;
							break;
						case 10:
							// m_sItemEffectValue5
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
							cReadModeB = 11;
							break;
						case 11:
							// m_sItemEffectValue6
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
							cReadModeB = 12;
							break;
						case 12:
							// m_wMaxLifeSpan
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD) atoi(token);
							cReadModeB = 13;
							break;
						case 13:
							// m_sSpecialEffect
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
							cReadModeB = 14;
							break;
						case 14:
							// m_sSprite
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
							cReadModeB = 15;
							break;
						case 15:
							// m_sSpriteFrame
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
							cReadModeB = 16;
							break;
						case 16:
							// m_wPrice
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iTemp = atoi(token);
							if (iTemp < 0)
								m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
							else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;

							m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
							cReadModeB = 17;
							break;
						case 17:
							// m_wWeight
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
							cReadModeB = 18;
							break;
						case 18:
							// Appr Value
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
							cReadModeB = 19;
							break;
						case 19:
							// m_cSpeed
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
							cReadModeB = 20;
							break;

						case 20:
							// m_sLevelLimit
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
							cReadModeB = 21;
							break;

						case 21:
							// m_cGederLimit
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
							cReadModeB = 22;
							break;

						case 22:
							// m_sSpecialEffectValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
							cReadModeB = 23;
							break;

						case 23:
							// m_sSpecialEffectValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
							cReadModeB = 24;
							break;

						case 24:
							// m_sRelatedSkill
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
							cReadModeB = 25;
							break;

						case 25:
							// m_cCategory
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
							cReadModeB = 26;
							break;

						case 26:
							// m_cItemColor
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				default:
					break;
			}
		} else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}

DICFC_STOPDECODING:
	;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName) {
	register int i;
	char cTmpName[21];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {
				// °°Àº ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛ ¼³Á¤À» Ã£¾Ò´Ù. ¼³Á¤°ªÀ» º¹»çÇÑ´Ù.
				std::memset(pItem->m_cName, 0, sizeof(pItem->m_cName));
				strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
				pItem->m_cItemType = m_pItemConfigList[i]->m_cItemType;
				pItem->m_cEquipPos = m_pItemConfigList[i]->m_cEquipPos;
				pItem->m_sItemEffectType = m_pItemConfigList[i]->m_sItemEffectType;
				pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
				pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
				pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
				pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
				pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
				pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
				pItem->m_wMaxLifeSpan = m_pItemConfigList[i]->m_wMaxLifeSpan;
				pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan; // ÃÖÃÊ·Î »ý¼ºµÈ ¾ÆÀÌÅÛÀÇ ¼ö¸íÀº ÃÖ´ëÄ¡ÀÌ´Ù.
				pItem->m_sSpecialEffect = m_pItemConfigList[i]->m_sSpecialEffect;

				pItem->m_sSprite = m_pItemConfigList[i]->m_sSprite;
				pItem->m_sSpriteFrame = m_pItemConfigList[i]->m_sSpriteFrame;
				pItem->m_wPrice = m_pItemConfigList[i]->m_wPrice;
				pItem->m_wWeight = m_pItemConfigList[i]->m_wWeight;
				pItem->m_cApprValue = m_pItemConfigList[i]->m_cApprValue;
				pItem->m_cSpeed = m_pItemConfigList[i]->m_cSpeed;
				pItem->m_sLevelLimit = m_pItemConfigList[i]->m_sLevelLimit;
				pItem->m_cGenderLimit = m_pItemConfigList[i]->m_cGenderLimit;

				pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
				pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

				pItem->m_sRelatedSkill = m_pItemConfigList[i]->m_sRelatedSkill;
				pItem->m_cCategory = m_pItemConfigList[i]->m_cCategory;
				pItem->m_sIDnum = m_pItemConfigList[i]->m_sIDnum;

				pItem->m_bIsForSale = m_pItemConfigList[i]->m_bIsForSale;
				pItem->m_cItemColor = m_pItemConfigList[i]->m_cItemColor;

				return TRUE;
			}
		}

	// ¾ÆÀÌÅÛ¸®½ºÆ®¸¦ ¸ðµÎ °Ë»öÇßÀ½¿¡µµ ¹ß°ßµÇÁö ¾Ê¾Ò´Ù.
	return FALSE;
}

BOOL CGame::_bGetIsStringIsNumber(char * pStr) {
	int i;
	for (i = 0; i < (int) strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char) '0') || (pStr[i] > (char) '9'))) return FALSE;

	return TRUE;
}

BOOL CGame::_bReadMapInfoFiles(int iMapIndex) {
	if (__bReadMapInfo(iMapIndex) == FALSE) {
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType) {
	register int i, iIndex, iMapIndex, iFollowIndex;
	char cTmpName[11], cFollowSide;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	iMapIndex = -1;
	iFollowIndex = -1;

	for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0)) {
			iIndex = i;
			iMapIndex = m_pNpcList[i]->m_cMapIndex;
			goto NEXT_STEP_SNFM1;
		}

NEXT_STEP_SNFM1:
	;

	switch (cFollowOwnerType) {
		case DEF_OWNERTYPE_NPC:
			for (i = 1; i < DEF_MAXNPCS; i++)
				if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0)) {
					// µû¶ó´Ù´Ò ´ë»óÀ» ¹ß°ßÇß´Ù.
					// ´Ù¸¥ ¸Ê¿¡ Á¸ÀçÇÏ´Â ´ë»óÀº µû¶ó´Ù´Ò ¼ö ¾ø´Ù.
					if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
					iFollowIndex = i;
					cFollowSide = m_pNpcList[i]->m_cSide;
					goto NEXT_STEP_SNFM2;
				}
			break;

		case DEF_OWNERTYPE_PLAYER:
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0)) {
					// µû¶ó´Ù´Ò ´ë»óÀ» ¹ß°ßÇß´Ù.
					// ´Ù¸¥ ¸Ê¿¡ Á¸ÀçÇÏ´Â ´ë»óÀº µû¶ó´Ù´Ò ¼ö ¾ø´Ù.
					if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
					iFollowIndex = i;
					cFollowSide = m_pClientList[i]->m_cSide;
					goto NEXT_STEP_SNFM2;
				}
			break;
	}

NEXT_STEP_SNFM2:
	;

	if ((iIndex == -1) || (iFollowIndex == -1)) return FALSE;

	m_pNpcList[iIndex]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
	m_pNpcList[iIndex]->m_cFollowOwnerType = cFollowOwnerType;
	m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
	m_pNpcList[iIndex]->m_cSide = cFollowSide;


	return TRUE;
}

int CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID) {
	register int i, t, j, k, iMapIndex;
	char cTmpName[11], cTxt[120];
	short sX, sY, sRange;
	BOOL bFlag;
	SYSTEMTIME SysTime;

	if (strlen(pName) == 0) return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;
	GetLocalTime(&SysTime);
	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {
			if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)
				iMapIndex = i;
		}

	if (iMapIndex == -1) return FALSE;

	for (i = 1; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] == NULL) {
			m_pNpcList[i] = new class CNpc(pName);
			if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) {
				wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
				PutLogList(cTxt);

				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;
			}

			if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
				if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek) {
					delete m_pNpcList[i];
					m_pNpcList[i] = NULL;
					return FALSE;
				}
			}

			switch (cMoveType) {
				case DEF_MOVETYPE_GUARD:
				case DEF_MOVETYPE_RANDOM:
					if ((poX != NULL) && (poY != NULL) && (*poX != 0) && (*poY != 0)) {
						sX = *poX;
						sY = *poY;
					} else {
						for (j = 0; j <= 30; j++) {
							// ¸¸µé ¼ö ÀÖ´Â ÁÂÇ¥°¡ ³ª¿Ã¶§ ±îÁö 30¹ø ¹Ýº¹
							sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
							sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

							bFlag = TRUE;
							for (k = 0; k < DEF_MAXMGAR; k++)
								if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
									// ÇÇÇØ¾ß ÇÒ ÁÂÇ¥°¡ ÀÖ´Ù.
									if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
											  (sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
											  (sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
											  (sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
										// Avoid Rect¾ÈÀÌ¹Ç·Î ÀÌ À§Ä¡¿¡´Â »ý¼º½ÃÅ³ ¼ö ¾ø´Ù.
										bFlag = FALSE;
									}
								}
							if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;

						}
						// ½ÇÆÐ!
						delete m_pNpcList[i];
						m_pNpcList[i] = NULL;
						return FALSE;

GET_VALIDLOC_SUCCESS:
						;
						// sX, sY¿¡ »ý¼º °¡´ÉÇÏ´Ù.
					}
					break;

				case DEF_MOVETYPE_RANDOMAREA:
					// pArea ¿µ¿ª ¾È¿¡¼­ »ý¼ºÇÑ´Ù.
					sRange = (short) (pArea->right - pArea->left);
					sX = (short) ((rand() % sRange) + pArea->left);
					sRange = (short) (pArea->bottom - pArea->top);
					sY = (short) ((rand() % sRange) + pArea->top);
					break;

				case DEF_MOVETYPE_RANDOMWAYPOINT:
					// 10°³ÀÇ »ý¼ºÀ§Ä¡Áß ÇÑ°÷À» ·£´ýÇÏ°Ô ¼±ÅÃ
					sX = (short) m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1, 10) - 1]].x;
					sY = (short) m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1, 10) - 1]].y;
					break;

				default:
					// poX, poY°¡ NULLÀÌ ¾Æ´Ï¶ó¸é WaypointList 0¹øÀÌ ½ÃÀÛÀ§Ä¡
					if ((poX != NULL) && (poY != NULL) && (*poX != 0) && (*poY != 0)) {
						// Æ÷ÀÎÅÍµµ NULLÀÌ ¾Æ´Ï°í ±× °ªµµ NULLÀÌ ¾Æ´Ï¶ó¸é ½ÃÀÛ À§Ä¡¸¦ ÇÒ´çÇÑ´Ù.
						sX = *poX;
						sY = *poY;
					} else {
						sX = (short) m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
						sY = (short) m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
					}
					break;
			}

			// À§Ä¡½ÃÅ³¸¸ÇÑ ÁÂÇ¥¸¦ ±¸ÇÑ´Ù. À§Ä¡½ÃÅ³ ¼ö ¾ø´Ù¸é ¸¸µéÁö ¾Ê´Â´Ù.
			if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) {

				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;
			}

			if ((bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0)) {
				// ÇÃ·¹ÀÌ¾î°¡ ÀÖ´Â ÀÚ¸®¿¡¼­´Â »ý¼ºµÇÁö ¾Ê´Â ¸ðµå¶ó¸é
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;
			}

			if ((poX != NULL) && (poY != NULL)) {
				// Æ÷ÀÎÅÍ°¡ NULLÀÌ ¾Æ´Ï¶ó¸é »ý¼ºÁÂÇ¥¸¦ ÀÔ·ÂÇÑ´Ù.
				*poX = sX;
				*poY = sY;
			}

			m_pNpcList[i]->m_sX = sX;
			m_pNpcList[i]->m_sY = sY;

			// Á¦ÀÚ¸®¿¡¼­ ¸Éµ¹°í ÀÖ´ÂÁö¸¦ È®ÀÎÇÏ±â À§ÇÑ ÁÂÇ¥ º¯¼ö
			m_pNpcList[i]->m_vX = sX;
			m_pNpcList[i]->m_vY = sY;

			// WaypointIndex¸¦ Ä«ÇÇÇÑ´Ù.
			for (t = 0; t < 10; t++)
				m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

			// ÃÑ WaypointIndexÀÇ ¼ö¸¦ °è»êÇÑ´Ù.
			m_pNpcList[i]->m_cTotalWaypoint = 0;
			for (t = 0; t < 10; t++)
				if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

			if (pArea != NULL) {
				// RANDOMAREA Copy
				SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
			}

			switch (cMoveType) {
				case DEF_MOVETYPE_GUARD:
					m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
					m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
					break;

				case DEF_MOVETYPE_SEQWAYPOINT:
					m_pNpcList[i]->m_cCurWaypoint = 1;

					m_pNpcList[i]->m_dX = (short) m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
					m_pNpcList[i]->m_dY = (short) m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
					break;

				case DEF_MOVETYPE_RANDOMWAYPOINT:
					m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;

					m_pNpcList[i]->m_dX = (short) m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
					m_pNpcList[i]->m_dY = (short) m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
					break;

				case DEF_MOVETYPE_RANDOMAREA:
					m_pNpcList[i]->m_cCurWaypoint = 0;

					sRange = (short) (m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
					m_pNpcList[i]->m_dX = (short) ((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
					sRange = (short) (m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
					m_pNpcList[i]->m_dY = (short) ((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
					break;

				case DEF_MOVETYPE_RANDOM:
					m_pNpcList[i]->m_dX = (short) ((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
					m_pNpcList[i]->m_dY = (short) ((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
					break;
			}

			m_pNpcList[i]->m_tmp_iError = 0;

			m_pNpcList[i]->m_cMoveType = cMoveType;

			switch (m_pNpcList[i]->m_cActionLimit) {
				case 2:
				case 3:
				case 5:
					// Á¦ÀÚ¸®¿¡¼­ ¿ÏÀü STOPÇÑ »óÅÂÀÇ NPC
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;

					switch (m_pNpcList[i]->m_sType) {
						case 15: // ShopKeeper-W
						case 19: // Gandlf
						case 20: // Howard
						case 24: // Tom
						case 25: // William
						case 26: // Kennedy
							m_pNpcList[i]->m_cDir = 4 + iDice(1, 3) - 1;
							break;

						default:
							m_pNpcList[i]->m_cDir = iDice(1, 8);
							break;
					}
					break;

				default:
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_cDir = 5;
					break;
			}

			m_pNpcList[i]->m_iFollowOwnerIndex = 0;
			m_pNpcList[i]->m_iTargetIndex = 0;
			m_pNpcList[i]->m_cTurn = (rand() % 2);

			switch (m_pNpcList[i]->m_sType) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					// ÀÎ°£Çü NPC¶ó¸é ÀüÅõ¸ðµå, ¹«±â, ¹æÆÐ ÇÃ·¡±×¸¦ ¼³Á¤ÇÑ´Ù.
					m_pNpcList[i]->m_sAppr2 = (short) 0xF000;
					m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4); // ¹«±â
					m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9); // ¹æÆÐ
					break;

				case 36: // AGT-Aresden/AGT-Elvine
				case 37: // CGT-Aresden/CGT-Elvine
				case 38: // MS-Aresden/MS-Elvine
				case 39: // DT-Aresden/DT-Elvine
					m_pNpcList[i]->m_sAppr2 = 3;
					break;

					//case 64: // Crop
					//	// Å©·ç¼¼ÀÌµå¿ë °ÇÃà¹°ÀÌ¶ó¸é 3´Ü°è·Î ¿Ï¼ºµÈ´Ù.
					//	m_pNpcList[i]->m_sAppr2 = 1;
					//	break;
					// appr2 = 2 seems to be enemy detection for crusade

					/*case 91: // gate
						// Å©·ç¼¼ÀÌµå¿ë °ÇÃà¹°ÀÌ¶ó¸é 3´Ü°è·Î ¿Ï¼ºµÈ´Ù.
						m_pNpcList[i]->m_sAppr2 = 0xF000; // 10 aura no sphere 13 no name movable with magic (crash) test to 29
						break;*/

				case 64: // Crop
					m_pNpcList[i]->m_sAppr2 = 1; // 1 bud; 2 grown; 3 large
					break;

					// case 66: // Wyvern
					//	m_pNpcList[i]->m_iStatus = 0x00000010;
					//	// m_pNpcList[i]->m_cSide = 2;
					//	break;

				default:
					m_pNpcList[i]->m_sAppr2 = 0;
					break;
			}

			m_pNpcList[i]->m_cMapIndex = (char) iMapIndex;
			m_pNpcList[i]->m_dwTime = timeGetTime() + (rand() % 10000);
			m_pNpcList[i]->m_dwActionTime += (rand() % 300);
			m_pNpcList[i]->m_dwMPupTime = timeGetTime();
			m_pNpcList[i]->m_dwHPupTime = m_pNpcList[i]->m_dwMPupTime;
			m_pNpcList[i]->m_sBehaviorTurnCount = 0;
			m_pNpcList[i]->m_bIsSummoned = bIsSummoned;
			m_pNpcList[i]->m_bIsMaster = bIsMaster;
			// ¼ÒÈ¯¸÷ »ý¼º ½Ã°£À» ±â·ÏÇÑ´Ù.
			if (bIsSummoned == TRUE)
				m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

			// °íÁ¤ Berserk »óÅÂ Ãß°¡.
			if (bFirmBerserk == TRUE) {
				m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
				m_pNpcList[i]->m_iStatus = m_pNpcList[i]->m_iStatus | 0x20;
				// °íÁ¤ Berserk »óÅÂÀÇ ¸÷Àº °æÇèÄ¡¸¦ 2¹è ´õ ¸¹ÀÌ °®´Â´Ù.
				//iExpRoll = iDice(m_pNpcList[i]->m_iExpDiceMin, m_pNpcList[i]->m_iExpDiceMax);
				//iExpRoll *= 2;
			}

			// !!!
			if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;

			m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
			m_pNpcList[i]->m_iSpotMobIndex = iSpotMobIndex;
			m_pNpcList[i]->m_iGuildGUID = iGuildGUID;
			//testcode
			if (iGuildGUID != 0) {
				wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
				PutLogList(G_cTxt);
			}

			m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
			m_pMapList[iMapIndex]->m_iTotalActiveObject++;
			m_pMapList[iMapIndex]->m_iTotalAliveObject++;

			// Å©·ç¼¼ÀÌµå¿ë °ÇÃà¹°ÀÌ¶ó¸é ÁöÈÖ°ü Åëº¸¿ë °ÇÃà¹° ¸®½ºÆ®¸¦ ÀÛ¼ºÇÑ´Ù.
			switch (m_pNpcList[i]->m_sType) {
				case 36: // AGT-Aresden/AGT-Elvine
				case 37: // CGT-Aresden/CGT-Elvine
				case 38: // MS-Aresden/MS-Elvine
				case 39: // DT-Aresden/DT-Elvine
				case 42: // ManaStone
					m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
					break;

				case 64:
					m_pMapList[iMapIndex]->bAddCropsTotalSum();
					break;
			}

			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë¸°´Ù.
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);
			return TRUE;
		}

	return FALSE;
}

void CGame::NpcProcess() {
	register int i, iMaxHP;
	DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXNPCS; i++) {

		if (m_pNpcList[i] != NULL) {
			// ¼Óµµ¸¦ Á¶Á¤ÇÑ´Ù. °ø°Ý½Ã¿¡´Â ¸ó½ºÅÍµéÀÇ ¼Óµµ°¡ »¡¶óÁø´Ù.
			if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
				switch (iDice(1, 7)) {
					case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime;
						break;
					case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100;
						break;
					case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200;
						break;
					case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300;
						break;
					case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400;
						break;
					case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600;
						break;
					case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700;
						break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			} else dwActionTime = m_pNpcList[i]->m_dwActionTime;

			// v1.42 ³Ãµ¿ »óÅÂ¶ó¸é ¿òÁ÷ÀÓÀÌ 50% ´À·ÁÁø´Ù.
			if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] != 0)
				dwActionTime += (dwActionTime / 2);
		}

		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			// ½Ã°£ ÀúÀå.
			m_pNpcList[i]->m_dwTime = dwTime;

			if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
				// ¸¶³ª¸¦ ¿Ã¸± ½Ã°£ÀÌ µÇ¾úÀ¸¸é ¿Ã¸°´Ù.
				if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
					m_pNpcList[i]->m_dwMPupTime = dwTime;

					//if (m_pNpcList[i]->m_bIsSummoned == FALSE) // ¼ÒÈ¯µÈ ¸ó½ºÅÍ´Â MP°¡ ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
					m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana / 5));

					if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
				}
			}

			// HP¸¦ ¿Ã¸± ½Ã°£ÀÌ µÇ¾úÀ¸¸é ¿Ã¸°´Ù.
			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
				// ½Ã°£ Àç °»½Å
				m_pNpcList[i]->m_dwHPupTime = dwTime;

				iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (m_pNpcList[i]->m_iHP < iMaxHP) {

					if (m_pNpcList[i]->m_bIsSummoned == FALSE) // ¼ÒÈ¯µÈ ¸ó½ºÅÍ´Â HP°¡ ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
						m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice); // Hit Point´Â 17ÃÊ¸¶´Ù 1D3¾¿ ¿Ã¶ó°£´Ù.

					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0) m_pNpcList[i]->m_iHP = 1;
				}
			}

			switch (m_pNpcList[i]->m_cBehavior) {
				case DEF_BEHAVIOR_DEAD:
					NpcBehavior_Dead(i);
					break;
				case DEF_BEHAVIOR_STOP:
					NpcBehavior_Stop(i);
					break;
				case DEF_BEHAVIOR_MOVE:
					NpcBehavior_Move(i);
					break;
				case DEF_BEHAVIOR_ATTACK:
					NpcBehavior_Attack(i);
					break;
				case DEF_BEHAVIOR_FLEE:
					NpcBehavior_Flee(i);
					break;
			}

			// !!! m_pNpcList´Â NULLÀÏ ¼ö ÀÖ´Ù.
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) {
				// ¸ó½ºÅÍÀÇ Á¾·ù¿¡ µû¶ó ¼ÒÈ¯ ½Ã°£ÀÌ ´Þ¶óÁø´Ù.
				switch (m_pNpcList[i]->m_sType) {
					case 29: // ¿À¿ì°Å: 1ºÐ 30ÃÊ
						if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000 * 90)
							NpcKilledHandler(0, 0, i, 0);
						break;

					default: // ÀÏ¹ÝÀûÀÎ °æ¿ì: ¼ÒÈ¯¸÷ÀÌ ½Ã°£ÀÌ ´Ù µÇ¾î »ç¶óÁ®¾ß ÇÑ´Ù.
						if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME)
							NpcKilledHandler(0, 0, i, 0);
						break;
				}
			}
		}
	}
}

// 05/29/2004 - Hypnotoad - GM chat tweak

void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize) {
	register int i, iRet;
	WORD * wp;
	char * cp;
	char cBuffer[256], cTemp[256], cSendMode = 0;

	m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 83 + 30) return;
	{
	}
	// v1.41 ShutUp TimeÀÌ °É·Á ÀÖÀ¸¸é ¿ÏÀüÈ÷ ¸»À» ÇÒ ¼ö ¾ø´Ù. °­·Â Á¦Àç
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;

	// º»ÀÎÀÇ ÀÌ¸§ÀÌ ±âÀÔµÇ¾î ÀÖÁö ¾Ê´Ù¸é ¸®ÅÏ
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;

	// °ü¶÷ÀÚ¶ó¸é Ã¤ÆÃÀ» ÇÒ ¼ö ¾ø´Ù.
	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù.
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
			case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++;
				break;
			case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;
				break;
			case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;
				break;
		}
	}
	// Ã¤ÆÃ ¸Þ½ÃÁöÀÇ ½ÃÀÛ À§Ä¡. ()
	cp = (char *) (pData + 21);

	switch (m_bLogChatOption) {
			// Chat Logs of only players
		case 1:
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
				std::memset(cTemp, 0, sizeof(cTemp));
				pData[dwMsgSize - 1] = 0;
				wsprintf(cTemp, "Loc(%s) IP(%s) PC(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			break;
			// Chat Logs of only GM
		case 2:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
				std::memset(cTemp, 0, sizeof(cTemp));
				pData[dwMsgSize - 1] = 0;
				wsprintf(cTemp, "Loc(%s) IP(%s) GM(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			break;
			// Chat logs of all
		case 3:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
				std::memset(cTemp, 0, sizeof(cTemp));
				pData[dwMsgSize - 1] = 0;
				wsprintf(cTemp, "Loc(%s) IP(%s) GM(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			} else {
				std::memset(cTemp, 0, sizeof(cTemp));
				pData[dwMsgSize - 1] = 0;
				wsprintf(cTemp, "Loc(%s) IP(%s) PC(%s):\"%s\"", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cp);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			break;
			// Chat logs of none
		case 4:

			break;
	}

	/*	// New 08/05/2004
	// Log GM Chats
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
		std::memset(cTemp, 0, sizeof(cTemp));
		pData[dwMsgSize-1] = 0;
		wsprintf(cTemp,"GM Chat(%s):\"%s\"",m_pClientList[iClientH]->m_cCharName,cp);
		bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
	}*/

	// ¸Þ½ÃÁö¿¡ ¸í·É¾î°¡ ¼¯¿© ÀÖ´ÂÁö °Ë»çÇÑ´Ù.
	switch (*cp) {
		case '@':
			// °°Àº ±æµå¿¡°Ô º¸³»´Â ¸Þ½ÃÁö
			*cp = 32;
			if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) &&
					  (m_pClientList[iClientH]->m_iSP >= 3)) {
				// ½ºÅ×¹Ì³Ê°¡ ÃæºÐÇÏ¸é ÀüÃ¼ ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				//v1.42
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 3;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, NULL);
				}
				cSendMode = 1;
			} else cSendMode = 0;

			// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é
			if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
			break;

			// New 08/05/2004
			// Party chat
		case '$':
			*cp = 32;

			if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3)) {
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 3;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, NULL);
				}
				cSendMode = 4;
			} else {
				cSendMode = 0;
			}

			if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) {
				cSendMode = 0;
			}
			break;

		case '^':
			// ÀüÃ¼ »ç¿ëÀÚ¿¡°Ô Àü´ÞµÇ´Â ¸Þ½ÃÁöÀÌ´Ù.
			// ¸¸¾à °ü¸®±ÇÇÑÀÌ ÀÖ°Å³ª ±æµå¸¶½ºÅÍÀÎ°æ¿ì ÀüÃ¼¼­¹ö¿¡ º¸³»´Â ¸Þ¼¼Áö
			*cp = 32;
			if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) &&
					  (m_pClientList[iClientH]->m_iSP > 5) && m_pClientList[iClientH]->m_iGuildRank != -1) {
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 3;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, NULL);
				}
				cSendMode = 1;
			} else cSendMode = 0;

			// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é
			if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;

			// v1.4334 ÀüÃ¼ ¿ÜÄ¡±â ¸·±â
			if (m_pClientList[iClientH]->m_iHP < 0) cSendMode = 0;

			// ¸¸¾à °ü¸®±ÇÇÑÀÌ ÀÖ´Ù¸é
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
			break;

		case '!':
			// ÀüÃ¼ »ç¿ëÀÚ¿¡°Ô Àü´ÞµÇ´Â ¸Þ½ÃÁöÀÌ´Ù.
			// °°Àº ±æµå¿¡°Ô º¸³»´Â ¸Þ½ÃÁö
			*cp = 32;
			if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) &&
					  (m_pClientList[iClientH]->m_iSP >= 5)) {
				// ½ºÅ×¹Ì³Ê°¡ ÃæºÐÇÏ¸é ÀüÃ¼ ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				//v1.42
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 5;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, NULL);
				}
				cSendMode = 2; // ¸Þ½ÃÁö Ã¢¿¡ ¶ç¿î´Ù.
			} else cSendMode = 0;

			// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é
			if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;

			// v1.4334 ÀüÃ¼ ¿ÜÄ¡±â ¸·±â
			if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;

			// ¸¸¾à °ü¸®±ÇÇÑÀÌ ÀÖ´Ù¸é
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 35; // GM Chat By Carlos
			break;

		case '~':
			// °°Àº Æí¿¡°Ô º¸³»´Â ¸Þ½ÃÁö
			*cp = 32;
			if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) &&
					  (m_pClientList[iClientH]->m_iSP >= 3)) {
				// ½ºÅ×¹Ì³Ê°¡ ÃæºÐÇÏ¸é ÀüÃ¼ ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				//v1.42
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 3;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, NULL);
				}
				cSendMode = 3;
			} else cSendMode = 0;

			// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é
			if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
			// v1.4334 ÀüÃ¼ ¿ÜÄ¡±â ¸·±â
			if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;
			break;

		case '/':
			// ¸í·É¾îÀÌ´Ù.
			std::memset(cBuffer, 0, sizeof(cBuffer));
			memcpy(cBuffer, cp, dwMsgSize - 21);
			cp = (char *) (cBuffer);

			// New 19/05/2004
			if (memcmp(cp, "/version", 8) == 0) {
				ShowVersion(iClientH);
				return;
			}

			// New 10/05/2004
			if (memcmp(cp, "/begincrusadetotalwar", 21) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
					GlobalStartCrusadeMode();
					wsprintf(cTemp, "(%s) GM Order(%s): begincrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				}
				return;
			}

			if (memcmp(cp, "/endcrusadetotalwar", 19) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
					ManualEndCrusadeMode(0);
					wsprintf(cTemp, "(%s) GM Order(%s): endcrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				}
				return;
			}

			// New 08/05/2004
			if (memcmp(cp, "/goto ", 6) == 0) {
				AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/unsummonboss", 13) == 0) {
				AdminOrder_UnsummonBoss(iClientH);
				return;
			}

			//Showdmg
			if (memcmp(cp, "/showdmg", 8) == 0) {
				PlayerOrder_ShowDamage(iClientH);
				return;
			}

			if (memcmp(cp, "/clearnpc", 9) == 0) {
				AdminOrder_ClearNpc(iClientH);
				return;
			}

			if (memcmp(cp, "/clearmap", 9) == 0) {
				AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
				return;
			}

			if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
				AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/enableadmincommand ", 20) == 0) {
				AdminOrder_EnableAdminCommand(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/monstercount", 13) == 0) {
				AdminOrder_MonsterCount(iClientH, cp, dwMsgSize - 21);
				return;
			}

			// New 07/05/2004
			if (memcmp(cp, "/createparty", 12) == 0) {
				RequestCreatePartyHandler(iClientH);
				return;
			}

			if (memcmp(cp, "/joinparty ", 11) == 0) {
				RequestJoinPartyHandler(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/dismissparty", 13) == 0) {
				RequestDismissPartyHandler(iClientH);
				return;
			}

			if (memcmp(cp, "/getpartyinfo", 13) == 0) {
				GetPartyInfoHandler(iClientH);
				return;
			}

			if (memcmp(cp, "/deleteparty", 12) == 0) {
				RequestDeletePartyHandler(iClientH);
				return;
			}

			if (memcmp(cp, "/who", 4) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelWho) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_TOTALUSERS, 0, 0, 0, NULL);
				}
				return;
			}

			//50Cent - Capture The Flag
			if (memcmp(cp, "/startctf", 9) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) StartCaptureTheFlag();
				return;
			}
			if (memcmp(cp, "/endctf", 7) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) EndCaptureTheFlag(0);
				return;
			}


			if (memcmp(cp, "/happyhour ", 11) == 0) { // MORLA 2.3 - Comando Happy Hour
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
				ManualStartHappyHour(iClientH, cp, dwMsgSize - 21);
				return;
			}


			if (memcmp(cp, "/porpatas", 3) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0)
					DeleteClient(iClientH, TRUE, TRUE);
				return;
			}

			if (memcmp(cp, "/desbug ", 8) == 0) {
				DesbugCharacter(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/dkset", 6) == 0) {
				GetDkSet(iClientH);
				return;
			}

			//criticals by MihD
			if (memcmp(cp, "/criticals", 10) == 0) {
				PlayerOrder_GetCrits(iClientH);
				return;
			}

			if (memcmp(cp, "/addmaster ", 11) == 0) {
				PlayerCommandAddMaster(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/deletemaster ", 13) == 0) {
				PlayerOrder_DeleteGuildMaster(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/balltrade ", 7) == 0) {
				_TradeItem(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/ballpoints", 10) == 0) {
				char cInfoString[50];
				wsprintf(cInfoString, " You have got:(%d) Ball Points. ", m_pClientList[iClientH]->m_iBallPoints);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_IPACCOUNTINFO, 0, 0, 0, cInfoString);
				return;
			}

			if (memcmp(cp, "/setcrit", 6) == 0) {
				AdminOrder_SetCrit(iClientH, cp, dwMsgSize - 21);
				;
				return;
			}

			if (memcmp(cp, "/setek", 6) == 0) {
				AdminOrder_SetEK(iClientH, cp, dwMsgSize - 21);
				;
				return;
			}

			if (memcmp(cp, "/setmaj", 7) == 0) {
				AdminOrder_SetMAJ(iClientH, cp, dwMsgSize - 21);
				;
				return;
			}

			if (memcmp(cp, "/setrep", 7) == 0) {
				AdminOrder_SetRep(iClientH, cp, dwMsgSize - 21);
				;
				return;
			}

			if (memcmp(cp, "/setpk", 6) == 0) {
				AdminOrder_SetPK(iClientH, cp, dwMsgSize - 21);
				;
				return;
			}

			if (memcmp(cp, "/fi ", 4) == 0) {
				// Æ¯Á¤ »ç¿ëÀÚ°¡ Á¢¼ÓÁßÀÎÁö¸¦ ¹¯´Â °ÍÀÌ´Ù.
				CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/to", 3) == 0) {
				// ±Ó¼Ó¸»À» ¼³Á¤ÇÑ´Ù.
				ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/setpf ", 7) == 0) {
				// ÇÃ·¹ÀÌ¾î ÇÁ·ÎÇÊÀ» ¼³Á¤ÇÑ´Ù.
				SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/weather", 8) == 0) {
				AdminOrder_Weather(iClientH, cp, dwMsgSize - 21);
				return;
			}
			if (memcmp(cp, "/pf ", 4) == 0) {
				// ÇÃ·¹ÀÌ¾îÀÇ ÇÁ·ÎÇÊÀ» º¸°íÀÚ ÇÑ´Ù.
				GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/shutup ", 8) == 0) {
				// ÇÃ·¹ÀÌ¾îÀÇ ÀüÃ¼ Ã¤ÆÃ±â´ÉÀ» ¸·´Â´Ù.
				ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/rep+ ", 6) == 0) {
				// ÇÃ·¹ÀÌ¾îÀÇ ÁÁÀº Æò°¡¸¦ ³»¸°´Ù.
				SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
				return;
			}


			if (memcmp(cp, "/time ", 6) == 0) {
				AdminOrder_Time(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/checkrep", 9) == 0) {
				AdminOrder_CheckRep(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/checkstatus ", 13) == 0) {
				AdminOrder_CheckStats(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/send ", 5) == 0) {
				AdminOrder_Pushplayer(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/rep- ", 6) == 0) {
				// ÇÃ·¹ÀÌ¾îÀÇ ³ª»Û Æò°¡¸¦ ³»¸°´Ù.
				SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/hold", 5) == 0) {
				SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/tgt ", 5) == 0) {
				SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
				return;
			}

			if (memcmp(cp, "/free", 5) == 0) {
				SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/summonall ", 11) == 0) {
				AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
				return;
			}


			/*		if (memcmp(cp, "/summonguild ", 13) == 0) {
						AdminOrder_SummonGuild(iClientH, cp, dwMsgSize - 21);
						return;
					}*/

			if (memcmp(cp, "/summonplayer ", 14) == 0) {
				AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/storm ", 7) == 0) {
				AdminOrder_SummonStorm(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/summondeath ", 13) == 0) {
				AdminOrder_SummonDeath(iClientH);
				return;
			}

			if (memcmp(cp, "/kill ", 6) == 0) {
				AdminOrder_Kill(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/revive ", 8) == 0) {
				AdminOrder_Revive(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/closeconn ", 11) == 0) {
				// °æºñ¸¦ ¼ÒÈ¯ÇÏ¿© °ø°ÝÇÑ´Ù.
				AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
				return;
			}

			// v1.4311-3 º¯°æ expire -> ban
			if (memcmp(cp, "/ban", 4) == 0) {
				UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
				return;
			}

			// v1.4311-3 Ãß°¡ reservefightzone ¿î¿µÀÚ°¡ »çÅõÀåÀ» ¿¹¾àÇØ ³õ´Â´Ù.
			if (memcmp(cp, "/reservefightzone", 17) == 0) {
				AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/dissmiss ", 9) == 0) {
				UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/attack ", 8) == 0) {
				// °æºñ¸¦ ¼ÒÈ¯ÇÏ¿© °ø°ÝÇÑ´Ù.
				AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/createfish ", 12) == 0) {
				AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) {
				AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/summondemon ", 13) == 0) {
				AdminOrder_SummonDemon(iClientH);
				return;
			}

			if (memcmp(cp, "/unsummonall ", 13) == 0) {
				AdminOrder_UnsummonAll(iClientH);
				return;
			}

			if (memcmp(cp, "/unsummondemon ", 15) == 0) {
				AdminOrder_UnsummonDemon(iClientH);
				return;
			}

			if (memcmp(cp, "/checkip ", 9) == 0) {
				AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/polymorph ", 11) == 0) {
				AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/setinvi ", 9) == 0) {
				AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/gns ", 4) == 0) {
				AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/setattackmode ", 15) == 0) {
				AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/summon ", 8) == 0) {
				AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/setzerk ", 9) == 0) {
				AdminOrder_SetZerk(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/setfreeze ", 11) == 0) {
				AdminOrder_SetFreeze(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/setstatus ", 11) == 0) {
				AdminOrder_SetStatus(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/disconnectall ", 15) == 0) {
				AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/createitem ", 12) == 0) {
				AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
				return;
			}

			if (memcmp(cp, "/energysphere ", 14) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelEnergySphere) EnergySphereProcessor(TRUE, iClientH);
				return;
			}
			if (memcmp(cp, "/banip ", 7) == 0) {
				AdminOrder_BanIP(iClientH, cp, dwMsgSize - 21);
				return;
			}
			if (memcmp(cp, "/roll", 5) == 0) {


				CStrTok * pStrTok = new class CStrTok(cp, " ");
				char * token;
				token = pStrTok->pGet();
				token = pStrTok->pGet();

				if (token == NULL) {
					delete pStrTok;
					return;
				}

				delete pStrTok;
				return;
			}

			if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown)) {
				// Ä¿¸Çµå¿¡ ÀÇÇÑ ¼­¹ö ¼Ë´Ù¿î ¸í·É ºñ»ó»çÅÂ¿¡ ´ëºñÇÏ±â À§ÇÔÀÌ´Ù.
				m_cShutDownCode = 2;
				m_bOnExitProcess = TRUE;
				m_dwExitProcessTime = timeGetTime();
				// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù.
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
				// ·Î±× ¼­¹ö¿¡°Ô ÇöÀç ¼­¹ö°¡ ¼Ë´Ù¿î ÁßÀÓÀ» ¾Ë¸°´Ù.
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);
				// OccupyFlag µ¥ÀÌÅÍ ÀúÀå
				if (m_iMiddlelandMapIndex > 0) {
					// Crusade
					SaveOccupyFlagData();
					//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
					//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
				}
				return;
			}

			if ((memcmp(cp, "/setobservermode ", 17) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelObserver)) {
				// °ü¶÷ÀÚ ¸ðµå·Î ÀüÈ¯
				AdminOrder_SetObserverMode(iClientH);
				return;
			}

			if ((memcmp(cp, "/getticket ", 11) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)) {
				AdminOrder_GetFightzoneTicket(iClientH);
				return;
			}

			if (memcmp(cp, "/beginapocalypse", 16) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
					if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
					GlobalStartApocalypseMode();
					wsprintf(cTemp, "GM Order(%s): beginapocalypse", m_pClientList[iClientH]->m_cCharName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				}
				return;
			}

			if (memcmp(cp, "/endapocalypse", 14) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
					if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;
					GlobalEndApocalypseMode();
					wsprintf(cTemp, "GM Order(%s): endapocalypse", m_pClientList[iClientH]->m_cCharName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
				}
				return;
			}

			if (memcmp(cp, "/beginheldenian ", 16) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
					ManualStartHeldenianMode(iClientH, cp, dwMsgSize - 21);
				}
				return;
			}

			if (memcmp(cp, "/endheldenian ", 14) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
					ManualEndHeldenianMode(iClientH, cp, dwMsgSize - 21);
				}
				return;
			}

			if (memcmp(cp, "/beginheldenianfight", 20) == 0) {
				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 2) && (m_bIsHeldenianMode == 1)) {
					NotifyStartHeldenianFightMode();
				}
				return;

			}

			return;
	}

	// ¸ÕÀú ½ºÆ®¸µÀÇ ³¡¿¡ NULL ´Ù½Ã Áý¾î ³Ö¾î È®ÀÎÇÑ´Ù.
	pData[dwMsgSize - 1] = 0;

	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1) && (iDice(1, 3) != 2)) {
		// Confuse Language¿¡ °É¸° »óÅÂ. ¸Þ½ÃÁö¸¦ ¿Ö°î½ÃÅ²´Ù.
		cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 17);

		while (*cp != 0) {
			if ((cp[0] != 0) && (cp[0] != ' ') && (cp[1] != 0) && (cp[1] != ' ')) {
				switch (iDice(1, 3)) {
					case 1: memcpy(cp, "¿ö", 2);
						break;
					case 2: memcpy(cp, "¿ì", 2);
						break;
					case 3: memcpy(cp, "¿ù", 2);
						break;
				}
				cp += 2;
			} else cp++;
		}
	}

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 17);

	if ((cSendMode == 0) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		// ÀÏ¹Ý ¸Þ½ÃÁöÀÌ°í ±Ó¼Ó¸» ¸ðµå¶ó¸é º»ÀÎ°ú »ó´ë¹æ¿¡°Ô¸¸ Àü¼ÛÇÑ´Ù.
		cSendMode = 20;

		// ±Ó¼Ó¸» Å»Äð ÄÚµå°¡ ÀÖ´Ù¸é ÀÏ¹Ý ´ëÈ­°¡ µÈ´Ù.
		if (*cp == '#') cSendMode = 0;

		// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é ±Ó¼Ó¸» ¶ÇÇÑ ÇÒ ¼ö ¾ø´Ù.
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = 0;
	}

	// Ã¤ÆÃ ¸Þ½ÃÁö¸¦ ±×´ë·Î ÀÎÁ¢ÇÑ ÇÃ·¹ÀÌ¾îµé¿¡°Ô ¹ß¼ÛÇÑ´Ù.
	// ´Ü, MSGTYPEÀ§Ä¡¿¡ ¿ÀºêÁ§Æ® ¾ÆÀÌµð¸¦ ÀÔ·ÂÇÑ´Ù.
	wp = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD) iClientH;
	// ±×¸®°í ¸Þ½ÃÁö Å¸ÀÔÀ» ÀÔ·ÂÇÑ´Ù.
	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				switch (cSendMode) {
					case NULL:
						if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

						if ((m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
								  (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
								  (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
								  (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
								  (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7)) {

							// Crusade
							if (m_bIsCrusadeMode == TRUE) {
								if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
										  (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
									// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­´Â ¼­·Î ÆíÀÌ ´Ù¸£¸é ¸»À» ÇÒ ¼ö ¾ø´Ù.
								} else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							} else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						}
						break;

					case 1:
						if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

						if ((memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
								  (memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0)) {

							// Crusade
							if (m_bIsCrusadeMode == TRUE) {
								if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
										  (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
									// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­´Â ¼­·Î ÆíÀÌ ´Ù¸£¸é ¸»À» ÇÒ ¼ö ¾ø´Ù.
								} else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							} else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						}
						break;

					case 2:
					case 10:
					case 35: // GM Chat By Carlos
						// Crusade
						if (m_bIsCrusadeMode == TRUE) {
							if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
									  (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
								// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­´Â ¼­·Î ÆíÀÌ ´Ù¸£¸é ¸»À» ÇÒ ¼ö ¾ø´Ù.
							} else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						} else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						break;

					case 3:
						if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

						if ((m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide))
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						break;

					case 4:
						if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
						if ((m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID))
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						break;
				}

				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						// Á¦°ÅÇÏÁö ¾Ê°í ³ÀµÐ´Ù. Time OutÀ¸·Î Á¦°ÅµÇ´Â °ÍÀ» À¯µµ.
						//DeleteClient(i, TRUE, TRUE);
						break;
				}
			}
	} else {
		// New 16/05/2004
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);

		if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL &&
				  strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0) {
			iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);
			switch (m_bLogChatOption) {

				case 1:
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel == 0) {
						std::memset(cTemp, 0, sizeof(cTemp));
						wsprintf(cTemp, "GM Whisper   (%s):\"%s\"\tto Player(%s)", m_pClientList[iClientH]->m_cCharName, pData + 21, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
					}
					break;

				case 2:
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
						std::memset(cTemp, 0, sizeof(cTemp));
						wsprintf(cTemp, "GM Whisper   (%s):\"%s\"\tto GM(%s)", m_pClientList[iClientH]->m_cCharName, pData + 21, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
					}
					break;

				case 3:
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
						std::memset(cTemp, 0, sizeof(cTemp));
						wsprintf(cTemp, "GM Whisper   (%s):\"%s\"\tto GM(%s)", m_pClientList[iClientH]->m_cCharName, pData + 21, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
					} else {
						std::memset(cTemp, 0, sizeof(cTemp));
						wsprintf(cTemp, "Player Whisper   (%s):\"%s\"\tto Player(%s)", m_pClientList[iClientH]->m_cCharName, pData + 21, m_pClientList[iClientH]->m_cWhisperPlayerName);
						bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
					}
					break;

				case 4:
					break;
			}
		}

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				// Á¦°ÅÇÏÁö ¾Ê°í ³ÀµÐ´Ù. Time OutÀ¸·Î Á¦°ÅµÇ´Â °ÍÀ» À¯µµ.
				//DeleteClient(i, TRUE, TRUE);
				break;
		}
	}
}

void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize) {
	register int i;
	DWORD * dwp;
	WORD * wp;
	short * sp;
	char * cp, cTemp[256];

	std::memset(cTemp, 0, sizeof(cTemp));

	dwp = (DWORD *) cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp = (WORD *) (cTemp + DEF_INDEX2_MSGTYPE);
	*wp = 0;

	cp = (char *) (cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp = (short *) cp;
	*sp = 0;
	cp += 2;

	sp = (short *) cp;
	*sp = 0;
	cp += 2;

	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char) iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
		case 1: // ´Ù¸¥ ¼­¹ö¿¡¼­ ¿Â ±æµå ¸Þ½ÃÁö
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if (m_pClientList[i] != NULL) {
					if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
					if ((m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
						// °°Àº ±æµå ¸Þ½ÃÁö Àü¼Û
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
					}
				}
			break;

		case 2: // ´Ù¸¥ ¼­¹ö¿¡¼­ ¿Â ÀüÃ¼ ¸Þ½ÃÁö
		case 10: // ´Ù¸¥ ¼­¹ö¿¡¼­ ¿Â °øÁö ¸Þ½ÃÁö
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if (m_pClientList[i] != NULL) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
				}
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)
//  description			:: controls player attack
//	return value		:: int
//  last updated		:: October 29, 2004; 8:06 PM; Hypnotoad
//  commentary			:: - contains attack hack detection
//						   - added checks for Firebow and Directionbow to see if player is m_bIsInsideOwnTown
//						   - added ability to attack moving object
//						   - fixed attack unmoving object
/////////////////////////////////////////////////////////////////////////////////////
// Incomplete:
//			- Direction Bow damage disabled
//
/////////////////////////////////////////////////////////////////////////////////////

int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash) {
	char cData[100];
	DWORD * dwp, dwTime;
	WORD * wp;
	int iRet, iExp, tdX = 0, tdY = 0, i;
	short sOwner, sAbsX, sAbsY;
	char cOwnerType;
	BOOL bNearAttack = FALSE, var_AC = FALSE;
	short sItemIndex;
	int tX, tY, iErr, iStX, iStY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8)) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (3500)) {
				DeleteClient(iClientH, TRUE, TRUE, TRUE);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}

	if ((wTargetObjectID != 0) && (wType != 2)) {
		if (wTargetObjectID < DEF_MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		} else if ((wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS))) {
			if (m_pNpcList[wTargetObjectID - 10000] != NULL) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if (sOwner == (wTargetObjectID - 10000)) {
			tdX = m_pNpcList[sOwner]->m_sX;
			dX = tdX;
			tdY = m_pNpcList[sOwner]->m_sY;
			dY = tdY;
			bNearAttack = FALSE;
			var_AC = TRUE;
		}
		if (var_AC != TRUE) {
			if ((tdX == dX) && (tdY == dY)) {
				bNearAttack = FALSE;
			} else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
				dX = tdX;
				dY = tdY;
				bNearAttack = TRUE;
			}
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
			  (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
			case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++;
				break;
			case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;
				break;
			case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;
				break;
		}
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if (var_AC == FALSE) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
					if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
				} else {
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			} else {
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		} else if (var_AC != FALSE) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
					cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
					if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(sX, sY, cDir, sOwner)) != FALSE) {
						wType = 0;
					}
				} else {
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			} else {
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		} else {
			if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
		}
	}


	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;

	iExp = 0;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

	if (sOwner != 0) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) {
			if ((m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) && (m_pClientList[iClientH]->m_bIsInsideOwnTown == FALSE)) {
				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874) { // Directional bow
						iErr = 0;
						for (i = 1; i < 2; i++) {
							m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash, TRUE); // 1
							if (((abs(tdX - dX) >= 1) && (abs(tdY - dY) >= 1)) || ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1))) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) {
									dX += 4;
									dY += 4;
									tY += 4;
									tX += 4;
								}
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) {
									dX += 4;
									dY += 4;
									tY += 4;
									tX += 4;
								}
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) {
									dX += 4;
									dY += 4;
									tY += 4;
									tX += 4;
								}
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) {
									dX += 4;
									dY += 4;
									tY += 4;
									tX += 4;
								}
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) {
									dX += 4;
									dY += 4;
									tY += 4;
									tX += 4;
								}
								while (((tdX - dX) >= 1) && ((tdY - dY) >= 1)) {
									dX += 4;
									dY += 4;
									tY += 4;
									tX += 4;
								}
							}
						}
					} else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873) { // Firebow
						if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) ||
								  (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) ||
								  (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) ||
								  (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE);
						} else {

							if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {
								if (m_bHeldenianInitiated != 1) {
									iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1, 7) + 3)*1000, 8);
								}
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
							}
						}
					} else {
						iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
					}
				} else {
					iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
				}
			} else {
				iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
			}
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	} else _CheckMiningAction(iClientH, dX, dY);

	if (iExp != 0) {
		GetExp(iClientH, iExp, TRUE);
	}

	if (bResponse == TRUE) {
		dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOTION_ATTACK_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
		}
	}

	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError) {
	char cDir, cTmpDir;
	int aX, aY, dX, dY;
	int i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;

	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	} else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
		for (i = cDir; i <= cDir + 7; i++) {
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}

	if (cTurn == 1)
		for (i = cDir; i >= cDir - 7; i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
		}

	return 0;
}


char _tmp_cEmptyPosX[] = {0, 1, 1, 0, -1, -1, -1, 0, 1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2};
char _tmp_cEmptyPosY[] = {0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2};

BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex) {
	register int i;
	short sX, sY;
	// ÇÃ·¹ÀÌ¾î³ª NPC°¡ À§Ä¡ÇÒ ¼ö ÀÖ´Â ¿µ¿ªÀ» Ã£´Â´Ù.

	for (i = 0; i < 25; i++)
		if ((m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
				  (m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE)) {
			sX = *pX + _tmp_cEmptyPosX[i];
			sY = *pY + _tmp_cEmptyPosY[i];
			*pX = sX;
			*pY = sY;
			return TRUE;
		}

	// À§Ä¡½ÃÅ³¸¸ÇÑ ¿µ¿ªÀÌ ¾øÀ¸¹Ç·Î ÇØ´ç ¸ÊÀÇ InitPoint¿¡ ÇÒ´çÇÑ´Ù.

	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return FALSE;
}

void CGame::NpcBehavior_Move(int iNpcH) {
	char cDir;
	short sX, sY, dX, dY, absX, absY;
	short sTarget, sDistance;
	char cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	// ��ȯ���� ���� ���°� Hold��� �̵����� �ʴ´�.
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) &&
			  (m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;

	// �̵��� �� ��� NPC�� ����
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
		case 2:
		case 3:
		case 5:
			m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_STOP;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
	}

	// v1.432-2 �� ���� ������ �����Ѵ�.
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;
	}

	// �� ī��Ʈ ����.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		// ���� �� ī��Ʈ Ŭ����.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;

		// ���ڸ����� ��� �ɵ��� �ִ��� �Ǵ��Ѵ�.
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);

		if ((absX <= 2) && (absY <= 2)) {
			// ���ڸ��� �ɵ��� �ִ�. ���� WayPoint�� �������� �ٲ۴�.
			CalcNextWayPointDestination(iNpcH);
		}

		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}

	// ����� ����� �˻��Ѵ�.
	TargetSearch(iNpcH, &sTarget, &cTargetType);
	if (sTarget != 0) {
		// ��ݸ�ǥ �߰�.
		if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) {
			// �׼� ���ǵ� 1000ms �̸��� NPC�� 33% Ȯ��� ��ǥ�� ȹ���Ѵ�.
			if (iDice(1, 3) == 3) {
				m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
				// ���⼭ ǥȿ ���۰������� ���� �޽��� �߼�.
				return;
			}
		} else {
			// �׼� ���ǵ� 1000ms �̻��� NPC�� ��ǥ���� �߰ߵǸ� ������ �Ҵ��Ѵ�.
			m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
			// ���⼭ ǥȿ ���۰������� ���� �޽��� �߼�.
			return;
		}
	}

	// ������ ���� �̵� �ӵ��� ������.
	if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1, 3) == 2)) return;

	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
		// ��� ��ü�� ��ġ�� ��� �̵��� �����Ѵ�.
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				// ���ٴϴ� ��ü�� ������ �����̵����� ��ȯ.
				if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
					m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
					return;
				}

				dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
				dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
				break;
			case DEF_OWNERTYPE_NPC:
				// ���ٴϴ� ��ü�� ������ �����̵����� ��ȯ. -> 01-12-19 �ֺ��� �ٸ� ���� ���͸� �����ͷ� �����Ѵ�. ã�� �� ���ٸ� ���� ����
				if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
					m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
					m_pNpcList[iNpcH]->m_iFollowOwnerIndex = 0;
					//bSerchMaster(iNpcH);
					return;
				}

				dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
				dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
				break;
		}

		if (abs(sX - dX) >= abs(sY - dY))
			sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);

		if (sDistance >= 3) {
			// ��� ����� �Ӱ�ġ �̻� ������ ������ �̵��Ѵ�.
			cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				// �̵��� �� ���.
			} else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				// ���� ��ġ���� �����.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				// �� ��ġ�� ǥ���Ѵ�.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[iNpcH]->m_sX = dX;
				m_pNpcList[iNpcH]->m_sY = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
			}
		}
	} else {
		// ���� �̵� ������ ���Ѵ�.
		cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
				  m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY,
				  m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);

		if (cDir == 0) {
			// ���� �̵����� ���Ѵ�. ������ �� ���� ���ڸ����� ��� �ӹ��� ����
			if (iDice(1, 10) == 3) CalcNextWayPointDestination(iNpcH);
		} else {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// ���� ��ġ���� �����.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// �� ��ġ�� ǥ���Ѵ�.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX = dX;
			m_pNpcList[iNpcH]->m_sY = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
		}
	}
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType) {
	register int ix, iy, iPKCount;
	register short sX, sY, rX, rY, dX, dY;
	short sOwner, sTargetOwner, sDistance, sTempDistance;
	char cOwnerType, cTargetType, cTargetSide;
	int iInv;

	sTargetOwner = 0;
	cTargetType = 0;
	sDistance = 100;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	// ÀÎµ¦½º iNpcH¿¡ ÇØ´çÇÏ´Â NPC°¡ °ø°Ý´ë»óÀ» Ã£´Â´Ù.
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;

	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange * 2 + 1; ix++)
		for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange * 2 + 1; iy++) {

			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
			if (sOwner != 0) {
				// ¹«¾ð°¡ ¹ß°ßµÇ¾ú´Ù.
				if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break; // ÀÚ±â ÀÚ½ÅÀÌ¸é ¹«½Ã

				// ¸ñÇ¥ ¼³Á¤
				// À§Ä¡¸¦ ±¸ÇÑ´Ù.
				iPKCount = 0;
				switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwner] == NULL) {
							// Àß¸øµÈ ÀÎµ¦½º¸¦ °¡Áø °ªÀÌ´Ù. Å¬¸®¾îÇÑ´Ù.
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
						} else {
							if (m_pClientList[sOwner]->m_iAdminUserLevel > 0) goto SKIP_SEARCH;
							if (m_pClientList[sOwner]->m_cSide == 0) goto SKIP_SEARCH; // v2.24 ��ǥ��� NETURAL ����* �����
							dX = m_pClientList[sOwner]->m_sX;
							dY = m_pClientList[sOwner]->m_sY;
							cTargetSide = m_pClientList[sOwner]->m_cSide;
							iPKCount = m_pClientList[sOwner]->m_iPKCount;
							iInv = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwner] == NULL) {
							// Àß¸øµÈ ÀÎµ¦½º¸¦ °¡Áø °ªÀÌ´Ù. Å¬¸®¾îÇÑ´Ù.
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
						} else {
							dX = m_pNpcList[sOwner]->m_sX;
							dY = m_pNpcList[sOwner]->m_sY;
							cTargetSide = m_pNpcList[sOwner]->m_cSide;
							iPKCount = 0;
							iInv = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];

							if (m_pNpcList[iNpcH]->m_sType == 21) {
								// ¸¸¾à °æºñ°¡ NPC¸¦ ¸ñÇ¥¹°À» Ã£´Â °ÍÀÌ¶ó¸é NPCÁÖÀ§¿¡ ÇÃ·¹ÀÌ¾î°¡ ¸¹ÀÌ ÀÖ´Ù¸é °ø°ÝÇÏÁö ¾Ê´Â´Ù.
								if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
									sOwner = 0;
									cOwnerType = 0;
								}
							}
						}
						break;
				}

				if (m_pNpcList[iNpcH]->m_cSide < 10) {
					// NPCÀÇ Side°¡ 10º¸´Ù ÀÛ´Ù´Â °ÍÀº NPC°¡ ÇÑ ¸¶À»¿¡ ¼Ò¼ÓµÇ¾ú´Ù´Â ¶æ.  Ex: Guard È¤Àº ¼ÒÈ¯¸÷
					if (cTargetSide == 0) {
						// ¸ñÇ¥¹°ÀÌ Áß¸³ÀÌ´Ù. PK°¡ ¾Æ´Ï¶ó¸é °ø°ÝÇÏÁö ¾Ê´Â´Ù.
						if (iPKCount == 0) goto SKIP_SEARCH;
					} else {
						// ¸ñÇ¥¹°ÀÌ ¸¶À» ¼Ò¼ÓÀÌ´Ù. Side°¡ ´Ù¸£´Ù¸é °ø°ÝÇÑ´Ù. v1.12
						if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
						// Áß¸³¸÷Àº ¸¶À» ¼Ò¼Ó ¸ñÇ¥¹°À» °ø°ÝÇÏÁö ¾Ê´Â´Ù. v1.12
						if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
					}
				} else {
					// ÀÏ¹Ý ¸ó½ºÅÍµéÀÌ´Ù. ÀÚ±â¿Í Side°¡ °°À¸¸é ¹«½Ã.
					if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
					if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
				}

				// ¸¸¾à INVISIBILITY°¡ µÇ¾î ÀÖ°í Åõ¸í Å½Áö ´É·ÂÀÌ ¾ø´Ù¸é
				if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

				if (abs(sX - dX) >= abs(sY - dY))
					sTempDistance = abs(sX - dX);
				else sTempDistance = abs(sY - dY);

				if (sTempDistance < sDistance) {
					sDistance = sTempDistance;
					sTargetOwner = sOwner;
					cTargetType = cOwnerType;
				}
SKIP_SEARCH:
				;
			}
		}

	*pTarget = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}

void CGame::NpcBehavior_Attack(int iNpcH) {
	int iMagicType;
	short sX, sY, dX, dY;
	char cDir;
	DWORD dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
		case 1:
		case 2:
		case 3:
		case 4:
			return;

		case 5:
			if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
	}

	// v1.432-2 �� ���� ������ �����Ѵ�.
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;
	}

	// ���� ��� ī��Ʈ �ʱ�ȭ
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0)
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

	// �� ī��Ʈ ����.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
		// 20ȸ �̻� ��ݵ����� �����ϸ� �ٽ� �̵����� ����. �� ���� ��� ��尡 �ƴ϶��
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;

		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
			m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;

		// ���⼭ ǥȿ�����̳� ���������� ���ϱ� ���� �޽����� �߼��� ���� �ִ�.
		return;
	}

	// ��ġ�� ���Ѵ�.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	switch (m_pNpcList[iNpcH]->m_cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
				// ��ǥ���� �������.
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
				return;
			}
			dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
				// ��ǥ���� �������.
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
				return;
			}
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
			break;
	}

	// ��ǥ�� ������ ���� ������ ����ģ��. �� ���๰(5)�� ����
	if ((iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) &&
			  (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
			  (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
		return;
	}

	// �������� ���� Bravery�� ������ ����ģ��. �� ���๰(5)�� ����
	if ((m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1, m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
			  (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
			  (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
		return;
	}

	// ��ǥ���� ���¸� �Ǵ��Ѵ�.
	if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) {
		// ������ �ִ�.	�ٰŸ� ���⸦ �����ϰ� �ִٸ� ��ݰ���.

		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		// ������ �ٲٰ� ��ݵ���
		m_pNpcList[iNpcH]->m_cDir = cDir;

		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
			// ����� �ǹ��� ���
			switch (m_pNpcList[iNpcH]->m_sType) {
				case 89:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1);
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;

				case 87:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2);
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;

				case 36: // Crossbow Guard Tower: Ȱ ���
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2); // Ȱ
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE);
					break;

				case 37: // Cannon Guard Tower:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1);
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
			}
		} else {
			// �Ϲ� NPC�� ���
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į���� ��������� ����ϴ� �ǹ�
			iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1, FALSE, FALSE); // ��ݿ� ���� ȿ�� ����Ѵ�.
		}
		// ���� ��� ī��Ʈ ����.
		m_pNpcList[iNpcH]->m_iAttackCount++;

		// ��� ���� Ÿ�Կ� �� ���� �ൿ. ���� ��� ��忡�� �ش���� �ʴ´�.
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
				case DEF_ATTACKAI_EXCHANGEATTACK:
					// ��� -> ���� -> ��� -> ���� -> ...
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
					break;

				case DEF_ATTACKAI_TWOBYONEATTACK:
					// ��� -> ��� -> ���� -> ��� -> ��� -> ���� -> ...
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
					}
					break;
			}
		}
	} else {
		// ������ �ִ�.
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;

		// ���� �ɷ��� �־�� �ϰ� �����Ÿ� ������ �Ѵ�.
		if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1, 2) == 1) &&
				  (abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) { // �� ��Ŭ���� ���� ����� �������� �Ǵ��� ó��.
				case 1:
					if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 0;
					break;

				case 2:
					if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 10;
					else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 0;
					break;

				case 3: // Orc-Mage
					if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 20;
					else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 10;
					break;

				case 4:
					if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 30;
					else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 37;
					else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 20;
					else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 10;
					break;

				case 5: // Rudolph, Cannibal-Plant, Cyclops
					if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 43;
					else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 30;
					else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 37;
					else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 20;
					else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 10;
					break;

				case 6: // Tentocle, Liche
					if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 51;
					else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 43;
					else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 30;
					else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 37;
					else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 20;
					else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 10;
					break;

				case 7: // Barlog, Fire-Wyvern, MasterMage-Orc , LightWarBeatle, GHK, GHKABS, TK, BG
					// Sor, Gagoyle, Demon
					if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 5) == 3))
						iMagicType = 70;
					else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 61;
					else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 60;
					else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 51;
					else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 43;
					break;

				case 8: // Unicorn, Centaurus
					if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2))
						iMagicType = 35;
					else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 60;
					else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 51;
					else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 43;
					break;

				case 9: // Tigerworm
					if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2))
						iMagicType = 74; // Lightning-Strike
					break;

				case 10: // Frost, Nizie
					break;

				case 11: // Ice-Golem
					break;

				case 12: // Wyvern
					if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2))
						iMagicType = 91; // Blizzard
					else if (m_pMagicConfigList[63]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 63; // Mass-Chill-Wind
					break;

				case 13: // Abaddon
					if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2))
						iMagicType = 92; // Earth Shock Wave
					else if (m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
						iMagicType = 96; // Metoer Strike
					break;

			}

			if (iMagicType != -1) {

				// ������ AI�� 2�̻��̰� ���� ��� ��밡 ���� ��ȣ�� �ɷ� �ִٸ� ������� �ʴ´�.
				if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
								// ���� ��ȣ�� �ɷ����� ������� ������ �߰��ϰų� �̵����� ��ȯ, ���ο� ��ǥ���� �˻�
								if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
									m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
									m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
									return;
								} else goto NBA_CHASE;
							}
							// �з������ε� ��ǥ���� �̹� �з����¶�� ���� ��� ����.
							if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
								// ���� ��ȣ�� �ɷ����� ������� ������ �߰����� �ʰ� �̵����� ��ȯ, ���ο� ��ǥ���� �˻�
								if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
									m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
									m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
									return;
								} else goto NBA_CHASE;
							}
							// �з������ε� ��ǥ���� �̹� �з����¶�� ���� ��� ����.
							if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
							break;
					}
				}

				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į���� ��������� ����ϴ� �ǹ�
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000;
				return;
			}
		}

		// ������ ���� ����� ������ ��� (MagicLevel�� ������ ���)
		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1, 2) == 1) &&
				  (abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
				iMagicType = 43;
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
				iMagicType = 37;
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana)
				iMagicType = 0;

			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į���� ��������� ����ϴ� �ǹ�
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000;
				return;
			}
		}

		// v1.41 ���� �ɷ��� ������ ��Ÿ� ����� �����ϴٸ�
		if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) &&
				  (abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {

			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			// ������ �ٲٰ� ��ݵ���
			m_pNpcList[iNpcH]->m_cDir = cDir;

			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				switch (m_pNpcList[iNpcH]->m_sType) {
					case 36: // Crossbow Guard Tower
						SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2);
						iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
						break;

					case 37: // Cannon Guard Tower: �Ž� ���̾� ��Ʈ����ũ ���
						SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1);
						m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
						NpcMagicHandler(iNpcH, dX, dY, 61);
						break;
				}
			} else {
				switch (m_pNpcList[iNpcH]->m_sType) {
					case 51: // v2.05 Catapult: �Ž� ���̾� ��Ʈ����ũ ���
						SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1);
						m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
						NpcMagicHandler(iNpcH, dX, dY, 61);
						break;

					case 54: // Dark Elf: Ȱ ����� �Ѵ�.
						SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); // 2: Ȱ���
						iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
						break;

					case 63: // Frost
					case 79: // Nizie
						switch (m_pNpcList[iNpcH]->m_cTargetType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
								if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2))
									NpcMagicHandler(iNpcH, dX, dY, 57);
								// Ÿ���� ����ְ� ���� ���׿� �����ߴٸ� ���ٴ´�.
								if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) &&
										  (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
									if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
										// ȿ�� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5 * 1000),
												  m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
										// ����� �÷��̾��� ��� �˷��ش�.
										SendNotifyMsg(0, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
								if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2))
									NpcMagicHandler(iNpcH, dX, dY, 57);
								if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) &&
										  (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
									if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
										// ȿ�� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5 * 1000),
												  m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, 0, 0, 0, 1, 0, 0);
									}
								}
								break;
						}
					case 53: //Beholder: �õ� ����� �Ѵ�.
						switch (m_pNpcList[iNpcH]->m_cTargetType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
								// Ÿ���� ����ְ� ���� ���׿� �����ߴٸ� ���ٴ´�.
								if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) &&
										  (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
									if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
										// ȿ�� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5 * 1000),
												  m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
										// ����� �÷��̾��� ��� �˷��ش�.
										SendNotifyMsg(0, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, 0, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
								if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) &&
										  (bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
									if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
										// ȿ�� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5 * 1000),
												  m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, 0, 0, 0, 1, 0, 0);
									}
								}
								break;
						}
NBA_BREAK1:
						;
						SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: �ʻ��
						iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
						break;

					default:
						SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: �ʻ��
						// ��ݿ� ���� ȿ�� ����Ѵ�.
						iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
						break;
				}
			}
			// ���� ��� ī��Ʈ ����.
			m_pNpcList[iNpcH]->m_iAttackCount++;

			// ��� ���� Ÿ�Կ� �� ���� �ൿ. ���� ��� ��忡�� �ش���� �ʴ´�.
			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
					case DEF_ATTACKAI_EXCHANGEATTACK:
						// ��� -> ���� -> ��� -> ���� -> ...
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
						break;

					case DEF_ATTACKAI_TWOBYONEATTACK:
						// ��� -> ��� -> ���� -> ��� -> ��� -> ���� -> ...
						if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
							m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
							m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
						}
						break;
				}
			}
			return;
		}

		// ������ ������� �ʾҴٸ� �߰��Ѵ�.
NBA_CHASE:
		;

		if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;

		// ���� ��� ī��Ʈ �ʱ�ȭ
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

		{
			// �̵���尡 Follow�� �ƴ϶�� ��ݸ�ǥ�� ������ �߰��Ѵ�.	�����ӿ� ������ ���.
			cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				return;
			}
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// ���� ��ġ���� �����.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// �� ��ġ�� ǥ���Ѵ�.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX = dX;
			m_pNpcList[iNpcH]->m_sY = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
		}
	}
}

void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode) {
	register int i;
	DWORD dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			// Crusade ¸¸¾à ÁöÈÖ°üÀÌ »ç¸ÁÇÑ °æ¿ì ÁöÈÖ°ü »êÇÏ NPCµéÀº ¼ÒÈ¯¸÷ ¸ðµå·Î ÀüÈ¯µÇ¾î ÀÏÁ¤½Ã°£
			// ÀÌÈÄ¿¡ ÀÚµ¿ ÆøÆÄµÈ´Ù. ¸÷ÀÌ ³ÑÃÄ³ª´Â °ÍÀ» ¸·±â À§ÇÔ.
			if ((m_pNpcList[i]->m_iGuildGUID != 0) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
					  (m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

				if (m_pNpcList[i]->m_cActionLimit == 0) {
					// ÀÌµ¿ °¡´ÉÇÑ NPC¸¸ ¼ÒÈ¯ ¸ðµå·Î ÀüÈ¯
					m_pNpcList[i]->m_bIsSummoned = TRUE;
					m_pNpcList[i]->m_dwSummonedTime = dwTime;
				}
			}

			if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) &&
					  (m_pNpcList[i]->m_cTargetType == cTargetType)) {

				switch (iCode) {
					case DEF_MAGICTYPE_INVISIBILITY:
						if (m_pNpcList[i]->m_cSpecialAbility == 1) {
							// Åõ¸í Å½Áö ´É·ÂÀÌ ÀÖ´Â ¸ó½ºÅÍ´Â ¸ñÇ¥¸¦ ³õÄ¡Áö ¾Ê´Â´Ù.
						} else {
							m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
							m_pNpcList[i]->m_iTargetIndex = 0;
							m_pNpcList[i]->m_cTargetType = 0;
						}
						break;

					default:
						m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
						m_pNpcList[i]->m_iTargetIndex = 0;
						m_pNpcList[i]->m_cTargetType = 0;
						break;
				}
			}
		}
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage) {
	short sAttackerWeapon;
	int i, iQuestIndex, iExp, iConstructionPoint, iWarContribution;
	double dTmp1, dTmp2, dTmp3;
	char cQuestRemain;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	// ¸ÊÀÇ »ì¾ÆÀÖ´Â °´Ã¼¼ö¸¦ ÁÙÀÎ´Ù.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	// ÇöÀç ÀÌ NPC¸¦ °ø°Ý´ë»óÀ¸·Î »ï°íÀÖ´Â °´Ã¼µéÀ» ÇØÁ¦ÇÑ´Ù.
	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	// ÇöÀç ÀÌ NPC¸¦ µû¸£°í ÀÖ´ø NPCµéÀÇ ÀÌµ¿¹æ½ÄÀ» º¯°æÇÑ´Ù.
	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC);

	// ÇöÀç ¸ñÇ¥·Î »ï°í ÀÖ´ø °´Ã¼¸¦ ÇØÁ¦ÇÑ´Ù.
	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType = 0;
	// Á×´Â µ¿ÀÛ Àü¼Û.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
	} else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, 0);
	// Á¤»ó À§Ä¡¿¡¼­ Áö¿î´Ù.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// Á×Àº À§Ä¡ Ç¥½Ã¸¦ ÇÑ´Ù.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// Á×Àº NPC´Â ÀÌµ¿ÇÒ ¼ö ¾ø´Ù.
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;

	// ÅÏ Ä«¿îÆ® ÃÊ±âÈ­.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	// Á×Àº ½Ã°£ ±â·Ï
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

	// Æ÷»óÀÌ ¾ø´Â ¸ÊÀÌ¶ó¸é ¾ÆÀÌÅÛÀ» »ý¼º½ÃÅ°Áö ¾Ê´Â´Ù.
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;

	// v1.42 ¾ÆÀÌÅÛ µå·ÓÀ» °üÀåÇÑ´Ù.
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);

	// »õ·Î¿î °æÇèÄ¡ ¹èºÐ °ø½Ä.
	// NPC¿¡ ´ëÇÑ °ø°ÝÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é ÀÔÈù ´ë¹ÌÁö ¸¸Å­ÀÇ °æÇèÄ¡¸¦ °ø°ÝÀÚ¿¡°Ô ÁØ´Ù.
	if ((m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) &&
			  (m_pClientList[sAttackerH] != NULL)) {
		// NPC°¡ ÇÃ·¹ÀÌ¾îÀÇ °ø°Ý¿¡ Á×¾ú´Ù¸é ExpStockÀ» ¿Ã¸°´Ù.
		// ´Ü ¼ÒÈ¯¸÷ÀÎ °æ¿ì °æÇèÄ¡¸¦ ¿Ã¸®Áö ¾Ê´Â´Ù.	 ³ª¸ÓÁö °æÇèÄ¡¸¦ ¿Ã¸°´Ù.
		//Happy Hour para vos 
		if (m_bHappyHour == TRUE) {
			iExp = (m_pNpcList[iNpcH]->m_iExp);
		} else {
			iExp = (m_pNpcList[iNpcH]->m_iExp / 3);
		}
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

		//v1.42 °æÇèÄ¡ Áõ°¡
		if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
			dTmp1 = (double) m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double) iExp;
			dTmp3 = (dTmp1 / 100.0f) * dTmp2;
			iExp += (int) dTmp3;
		}

		if (m_pNpcList[iNpcH]->m_sType == 81) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL) {
					SendNotifyMsg(sAttackerH, i, DEF_NOTIFY_ABADDONKILLED, 0, 0, 0, NULL, 0, 0, 0, 0, 0, 0, NULL);
				}
			}
		}

		// Å©·ç¼¼ÀÌµå ¸ðµåÀÏ¶§ ¸ó½ºÅÍ¸¦ Á×¿©¼­ ¾òÀ» ¼ö ÀÖ´Â °æÇèÄ¡´Â 1/3
		if (m_bIsCrusadeMode == TRUE) {
			if (iExp > 10) iExp = iExp / 3;
		}

		if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] == 1) {
			iExp *= 2;
		}

		// New 09/05/2004
		//m_pClientList[sAttackerH]->m_iExpStock += iExp;
		GetExp(sAttackerH, iExp, TRUE);

		// Quest ¿©ºÎ¸¦ ÆÇ´ÜÇÑ´Ù.
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != 0) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
					case DEF_QUESTTYPE_MONSTERHUNT:
						if ((m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) &&
								  (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType)) {
							// Á¶°Ç¿¡ ÇÕ´çÇÏ´Ù. Ä«¿îÆ® Áõ°¡ÈÄ ÆÇ´Ü.
							m_pClientList[sAttackerH]->m_iCurQuestCount++;
							cQuestRemain = (m_pQuestConfigList[m_pClientList[sAttackerH]->m_iQuest]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
							SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, NULL);
							_bCheckIsQuestCompleted(sAttackerH);
						}
						break;
				}
			}
		}
	}

	// v1.41 Æ¯¼ö¸ó½ºÅÍ°¡ Á×¾úÀ» °æ¿ìÀÇ Ã³¸®
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		switch (m_pNpcList[iNpcH]->m_sType) {
			case 32:
				// À¯´ÏÄÜÀÌ Á×¾ú´Ù. Á×ÀÎ ÀÚ¿¡°Ô Æä³ÎÆ¼¸¦ ¹°¸°´Ù.
				m_pClientList[sAttackerH]->m_iRating -= 0;
				// v1.41 Rating �϶� 
				m_pClientList[sAttackerH]->m_iRating -= 0;
				if (m_pClientList[sAttackerH]->m_iRating > 10000) m_pClientList[sAttackerH]->m_iRating = 10000;
				if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;
				break;

			case 33:
				break;
		}
	}

	// Crusade
	iConstructionPoint = 0;
	switch (m_pNpcList[iNpcH]->m_sType) {
			// Å©·ç¼¼ÀÌµå¿ë À¯´ÏÆ®µéÀÌ´Ù. °Ç¼³ Æ÷ÀÎÆ®, º¸³Ê½º °æÇèÄ¡ °è»ê
		case 1: iConstructionPoint = 50;
			iWarContribution = 100;
			break;
		case 2: iConstructionPoint = 50;
			iWarContribution = 100;
			break;
		case 3: iConstructionPoint = 50;
			iWarContribution = 100;
			break;
		case 4: iConstructionPoint = 50;
			iWarContribution = 100;
			break;
		case 5: iConstructionPoint = 50;
			iWarContribution = 100;
			break;
		case 6: iConstructionPoint = 50;
			iWarContribution = 100;
			break; // ¸Ó¼­³Ê¸®
		case 36: iConstructionPoint = 700;
			iWarContribution = 4000;
			break; // ¾Ö·Î¿ì °¡µå Å¸¿ö
		case 37: iConstructionPoint = 700;
			iWarContribution = 4000;
			break; // Ä³³í °¡µå Å¸¿ö
		case 38: iConstructionPoint = 500;
			iWarContribution = 2000;
			break; // ¸¶³ª ÄÝ·ºÅÍ
		case 39: iConstructionPoint = 500;
			iWarContribution = 2000;
			break; // µðÅØÅÍ
		case 40: iConstructionPoint = 1500;
			iWarContribution = 5000;
			break; // ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ
		case 41: iConstructionPoint = 5000;
			iWarContribution = 10000;
			break; // ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ
		case 43: iConstructionPoint = 500;
			iWarContribution = 1000;
			break; // ¶óÀÌÆ® ¿ö ºñÆ²
		case 44: iConstructionPoint = 1000;
			iWarContribution = 2000;
			break; // °íÁî ÇÚµå ³ªÀÌÆ®
		case 45: iConstructionPoint = 1500;
			iWarContribution = 3000;
			break; // °íÁî ÇÚµå ±âº´
		case 46: iConstructionPoint = 1000;
			iWarContribution = 2000;
			break; // ÅÛÇÃ ³ªÀÌÆ®
		case 47: iConstructionPoint = 1500;
			iWarContribution = 3000;
			break; // ¹èÆ² °ñ·½
		case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum();
			break;

	}

	// Crusade
	if (iConstructionPoint != 0) {
		switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
					// »çÀÌµå°¡ ´Þ¶ó¾ß¸¸ °Ç¼³ Æ÷ÀÎÆ®°¡ °è»êµÈ´Ù.
					m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

					if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
						m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

					m_pClientList[sAttackerH]->m_iWarContribution += iWarContribution;
					if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
						m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

					//testcode
					wsprintf(G_cTxt, "Enemy NULLNpc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
					PutLogList(G_cTxt);

					SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 0, NULL);
				} else {
					// °°ÀºÆí NPC¸¦ Á×ÀÌ¸é ÀüÀï °øÇåµµ°¡ 2¹è·Î ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iWarContribution -= (iWarContribution * 2);
					if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
						m_pClientList[sAttackerH]->m_iWarContribution = 0;

					//testcode
					wsprintf(G_cTxt, "Friendly Npc Killed by player! WarContribution: -%d", iWarContribution);
					PutLogList(G_cTxt);

					SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 0, NULL);
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_iGuildGUID != 0) {
					if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
						// ÀüÀï¿ë ±¸Á¶¹° È¤Àº À¯´ÏÆ®°¡ Àû NPC¸¦ Á×¿´´Ù. ¹Ù·Î Åëº¸ÇÑ´Ù.
						// ÇöÀç ¼­¹ö¿¡ ÁöÈÖ°üÀÌ ÀÖ´Ù¸é °ð¹Ù·Î Åëº¸. ¾øÀ¸¸é ´Ù¸¥ ¼­¹ö·Î ¾Ë·ÁÁÜ.
						for (i = 1; i < DEF_MAXCLIENTS; i++)
							if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
									  (m_pClientList[i]->m_iCrusadeDuty == 3)) {

								m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
								if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
									m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

								//testcode
								wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
								PutLogList(G_cTxt);
								// ÁöÈÖ°ü¿¡°Ô ¹Ù·Î Åëº¸.
								SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, NULL);
								goto NKH_GOTOPOINT1;
							}
					}
				}
				break;
		}
	}

	// new - heldenian
	if ((m_bIsHeldenianMode == TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide)) {
		switch (m_pNpcList[iNpcH]->m_sType) {
			case 82: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
			case 83: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
			case 84: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
			case 85: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
			case 86: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
			case 87: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
			case 88: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
			case 89: iConstructionPoint = 0;
				iWarContribution = 1000;
				break;
		}
		if (iWarContribution > 0) m_pClientList[sAttackerH]->m_iWarContribution += iWarContribution;
		if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION) m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
		SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 1, 0, 0, 0);
	}

NKH_GOTOPOINT1:
	;

	// v1.411 ¸¸¾à ExplosiveÇÑ ¸ó½ºÅÍ°¡ Á×Àº °Å¶ó¸é Explosive
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30);
	} else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61);
	}

	if ((m_bIsHeldenianMode == TRUE) && (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) && (m_cHeldenianModeType == 1)) {
		if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89)) {
			if (m_pNpcList[iNpcH]->m_cSide == 1) {
				m_iHeldenianAresdenLeftTower--;
				wsprintf(G_cTxt, "Aresden Tower Broken, Left TOWER %d", m_iHeldenianAresdenLeftTower);
			} else if (m_pNpcList[iNpcH]->m_cSide == 2) {
				m_iHeldenianElvineLeftTower--;
				wsprintf(G_cTxt, "Elvine Tower Broken, Left TOWER %d", m_iHeldenianElvineLeftTower);
			}
			PutLogList(G_cTxt);
			UpdateHeldenianStatus();
		}
		if ((m_iHeldenianElvineLeftTower == 0) || (m_iHeldenianAresdenLeftTower == 0)) {
			GlobalEndHeldenianMode();
		}
	}
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY) {
	register int ix, iy, iDangerValue;
	short sOwner, sDOType;
	char cOwnerType;
	DWORD dwRegisterTime;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
		for (iy = dY - 2; iy <= dY + 2; iy++) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sDOType, &dwRegisterTime);

			if (sDOType == 1) iDangerValue++;

			switch (cOwnerType) {
				case NULL:
					break;
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwner] == NULL) break;
					if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide)
						iDangerValue++;
					else iDangerValue--;
					break;
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwner] == NULL) break;
					if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide)
						iDangerValue++;
					else iDangerValue--;
					break;
			}
		}

	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH) {
	char cDir;
	short sX, sY, dX, dY;
	short sTarget;
	char cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	// �� ī��Ʈ ����.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	// ��� �ΰ����ɿ� ���� ȿ����.
	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
		case DEF_ATTACKAI_EXCHANGEATTACK: // ��� -> ���� -> ...
		case DEF_ATTACKAI_TWOBYONEATTACK: // ��� -> ��� -> ���� -> ...
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
				// �ٽ� ��� ���� ��ȯ.
				m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				return;
			}
			break;

		default:
			if (iDice(1, 2) == 1) NpcRequestAssistance(iNpcH);
			break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		// 10���� �ϸ� ������ �� �ٽ� �̵����� ��ȯ.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); // ! ������ �������� ���������� ���������� ���������Ƿ� ������ ����.
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	// ����ġ�µ� ������ �Ǵ� ����� ��ǥ���� �˻��Ѵ�.
	TargetSearch(iNpcH, &sTarget, &cTargetType);
	if (sTarget != 0) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
	}

	// ��ǥ���� �ڽ��� ��ġ�� ���Ѵ�. �ݴ�������� ����ġ�� ����.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
			break;
		case DEF_OWNERTYPE_NPC:
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
			break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
		// �̵��� �� ���.
	} else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		// ���� ��ġ���� �����.
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		// �� ��ġ�� ǥ���Ѵ�.
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX = dX;
		m_pNpcList[iNpcH]->m_sY = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
	}
}

void CGame::MsgProcess() {
	char * pData, cFrom, cKey;
	DWORD dwMsgSize, * dwpMsgID;
	WORD * wpMsgType;
	int i, iClientH;
	char m_msgBuff[1000];
	DWORD dwTime;
	dwTime = timeGetTime();


	if ((m_bF5pressed == TRUE) && (m_bF1pressed == TRUE)) {
		PutLogList("(XXX) RELOADING CONFIGS MANUALY...");
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
			}
		bInit();
	}

	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
		// ¸ðµç Å¬¶óÀÌ¾ðÆ®ÀÇ µ¥ÀÌÅÍ¸¦ ÀúÀåÇÑ ÈÄ ÇÁ·Î±×·¥À» Á¾·áÇØ¾ß ÇÑ´Ù.
		m_cShutDownCode = 2;
		m_bOnExitProcess = TRUE;
		m_dwExitProcessTime = timeGetTime();
		// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù.
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		// ·Î±× ¼­¹ö¿¡°Ô ÇöÀç ¼­¹ö°¡ ¼Ë´Ù¿î ÁßÀÓÀ» ¾Ë¸°´Ù.
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);
		// OccupyFlag µ¥ÀÌÅÍ ÀúÀå
		if (m_iMiddlelandMapIndex > 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}

		return;
	}

	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE + 1);
	pData = (char *) m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {

		//v1.31 Ã³¸®ÇÏ°í ÀÖ´Â ¸Þ½ÃÁö °¹¼ö¸¦ Ä«¿îÆ®ÇÑ´Ù.
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {


			case DEF_MSGFROM_CLIENT:
				/*m_pClientList[iClientH]->m_cConnectionCheck++;
				if (m_pClientList[iClientH]->m_cConnectionCheck > 3) {
					wsprintf(G_cTxt, "Client Hex Edit: (%s) Player: (%s) - has removed 3203203 (check connection handler).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}*/


				dwpMsgID = (DWORD *) (pData + DEF_INDEX4_MSGID);
				switch (*dwpMsgID) { // 84148741

					case DEF_REQUEST_RESURRECTPLAYER_YES:
						RequestResurrectPlayer(iClientH, TRUE);
						break;

					case DEF_REQUEST_RESURRECTPLAYER_NO:
						RequestResurrectPlayer(iClientH, FALSE);
						break;

						//Shorcut para Criticals by 
					case DEF_REQUEST_CRITICALSADD:
						PlayerOrder_GetCrits(iClientH);
						break;

						//Shorcut para Criticals by 
					case DEF_REQUEST_SHOWBALLPOINTS:
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_IPACCOUNTINFO, 0, 0, 0, NULL);
						;
						break;

					case DEF_REQUEST_ANGEL: // Angels by Snoopy...
						GetAngelHandler(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_SELLITEMLIST:
						RequestSellItemListHandler(iClientH, pData);
						break;

					case MSGID_REQUEST_RESTART:
						RequestRestartHandler(iClientH);
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTYMEMBERSTATUS, 0, 0, 0, NULL);
						break;

					case MSGID_REQUEST_PANNING:
						iRequestPanningMapDataRequest(iClientH, pData);
						break;

					case MSGID_REQUEST_NOTICEMENT:
						RequestNoticementHandler(iClientH, pData);
						break;

					case MSGID_BWM_COMMAND_SHUTUP:
						_BWM_Command_Shutup(pData);
						break;

					case MSGID_BWM_INIT:
						_BWM_Init(iClientH, pData);
						break;

					case MSGID_REQUEST_SETITEMPOS:
						_SetItemPos(iClientH, pData);
						break;

					case MSGID_ADMINUSER:
						RequestAdminUserMode(iClientH, pData);
						break;

					case MSGID_REQUEST_FULLOBJECTDATA:
						RequestFullObjectData(iClientH, pData);
						break;

					case MSGID_REQUEST_RETRIEVEITEM:
						RequestRetrieveItemHandler(iClientH, pData);
						break;

					case MSGID_REQUEST_CIVILRIGHT:
						RequestCivilRightHandler(iClientH, pData);
						break;

					case MSGID_REQUEST_TELEPORT:
						RequestTeleportHandler(iClientH, pData);
						break;

					case MSGID_REQUEST_INITPLAYER:
						RequestInitPlayerHandler(iClientH, pData, cKey);
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTYMEMBERSTATUS, 0, 0, 0, NULL);
						break;

					case MSGID_REQUEST_INITDATA:
						// Anti Bump
						if (m_pClientList[iClientH]->m_bIsClientConnected == TRUE) {
							if (m_pClientList[iClientH] == NULL) break;
							wsprintf(G_cTxt, "(!!!) Client (%s) connection closed!. Sniffer suspect!.", m_pClientList[iClientH]->m_cCharName);
							PutLogList(G_cTxt);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
							bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);

							bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, FALSE);
							if ((dwTime - m_dwGameTime2) > 3000) { // 3 segs
								m_pClientList[iClientH]->m_bIsClientConnected = FALSE;
								m_iTotalClients--;
								delete m_pClientList[iClientH];
								m_pClientList[iClientH] = NULL;
							}
							break;
						} else {
							m_pClientList[iClientH]->m_bIsClientConnected = TRUE;
							RequestInitDataHandler(iClientH, pData, cKey);
						}
						break;

					case MSGID_COMMAND_COMMON:
						ClientCommonHandler(iClientH, pData);
						break;

					case MSGID_COMMAND_MOTION:
						ClientMotionHandler(iClientH, pData);
						break;

					case MSGID_COMMAND_CHECKCONNECTION:
						CheckConnectionHandler(iClientH, pData);
						break;

					case MSGID_COMMAND_CHATMSG:
						ChatMsgHandler(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_CREATENEWGUILD:
						RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_DISBANDGUILD:
						RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_FIGHTZONE_RESERVE:
						FightzoneReserveHandler(iClientH, pData, dwMsgSize);
						break;

					case MSGID_LEVELUPSETTINGS:
						LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
						break;

					case MSGID_STATECHANGEPOINT:
						StateChangeHandler(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_HELDENIANTELEPORT:
						RequestHeldenianTeleport(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_NPCSPEAKTELEPORT:
						RequestNpcSpeakTeleport(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_HELDENIAN_SCROLL:
						RequestHeldenianScroll(iClientH, pData, dwMsgSize);
						break;

					case MSGID_REQUEST_CITYHALLTELEPORT:
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
							RequestTeleportHandler(iClientH, "2   ", "elvine", 205, 63);
						} else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) {
							RequestTeleportHandler(iClientH, "2   ", "aresden", 49, 49);
						}
						break;

					default:
						wsprintf(m_msgBuff, "Unknown message received! (0x%.8X) Delete Client", *dwpMsgID);
						PutLogList(m_msgBuff);
						DeleteClient(iClientH, TRUE, TRUE); // v1.4
						break;
				}
				break;

			case DEF_MSGFROM_LOGSERVER:
				dwpMsgID = (DWORD *) (pData + DEF_INDEX4_MSGID);
				wpMsgType = (WORD *) (pData + DEF_INDEX2_MSGTYPE);

				switch (*dwpMsgID) {
					case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_CHECKACCOUNTPASSWORD");
						// °èÁ¤ÀÇ ÆÐ½º¿öµå¸¦ ºñ±³
						RequestCheckAccountPasswordHandler(pData, dwMsgSize);
						break;

					case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_FORCEDISCONECTACCOUNT");
						// °­Á¦ °èÁ¤ Á¢¼Ó Á¾·á. µ¥ÀÌÅÍ¸¦ ÀúÀåÇÏ°í Á¢¼ÓÀ» Á¾·á½ÃÅ²´Ù.
						wpMsgType = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
						ForceDisconnectAccount((char *) (pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
						break;

					case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_SAVEPLAYERDATA_REPLY");
						// Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍ°¡ ÀúÀåµÇ¾úÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö
						ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
						break;

					case MSGID_GUILDNOTIFY:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_GUILDNOTIFY");
						// ´Ù¸¥ °ÔÀÓ¼­¹ö¿¡¼­ ¹ß»ýÇÑ ±æµå ÀÌº¥Æ®¿¡ ´ëÇÑ Åëº¸(±æµå¿ø °¡ÀÔ, ±æµå¿ø Å»Åð, ±æµå ÇØ»ê µî)
						GuildNotifyHandler(pData, dwMsgSize);
						break;

					case MSGID_RESPONSE_DISBANDGUILD:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_DISBANDGUILD");
						// ±æµå ÇØ»ê¿ä±¸¿¡ ´ëÇÑ ÀÀ´ä
						ResponseDisbandGuildHandler(pData, dwMsgSize);
						break;

					case MSGID_RESPONSE_CREATENEWGUILD:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_CREATENEWGUILD");
						// Ä³¸¯ÅÍÀÇ ±æµå»ý¼º ¿ä±¸¿¡ ´ëÇÑ ÀÀ´ä.
						ResponseCreateNewGuildHandler(pData, dwMsgSize);
						break;

					case MSGID_RESPONSE_REGISTERGAMESERVER:
						switch (*wpMsgType) {
							case DEF_MSGTYPE_CONFIRM:
								//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
								PutLogList("(!) Game Server registration to Log Server - Success!");
								m_bIsLogSockAvailable = TRUE;
								break;

							case DEF_MSGTYPE_REJECT:
								//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
								PutLogList("(!) Game Server registration to Log Server - Fail!");
								break;
						}

						if (m_bIsBuildItemAvailable == FALSE) {
							// ¸¸¾à ºôµå¾ÆÀÌÅÛ Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
							PutLogList(" ");
							PutLogList("(!!!) STOPPED! Build-Item configuration error.");
						}

						if (m_bIsItemAvailable == FALSE) {
							// ¸¸¾à ¾ÆÀÌÅÛ Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
							PutLogList(" ");
							PutLogList("(!!!) STOPPED! Item configuration error.");
						}

						if (m_bIsNpcAvailable == FALSE) {
							// ¸¸¾à ¾ÆÀÌÅÛ Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
							PutLogList(" ");
							PutLogList("(!!!) STOPPED! Npc configuration error.");
						}

						if (m_bIsMagicAvailable == FALSE) {
							// ¸¸¾à MAGIC Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
							PutLogList(" ");
							PutLogList("(!!!) STOPPED! MAGIC configuration error.");
						}

						if (m_bIsSkillAvailable == FALSE) {
							// ¸¸¾à SKILL Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
							PutLogList(" ");
							PutLogList("(!!!) STOPPED! SKILL configuration error.");
						}

						if (m_bIsQuestAvailable == FALSE) {
							// ¸¸¾à SKILL Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
							PutLogList(" ");
							PutLogList("(!!!) STOPPED! QUEST configuration error.");
						}

						if (m_bIsPortionAvailable == FALSE) {
							// ¸¸¾à Portion Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
							PutLogList(" ");
							PutLogList("(!!!) STOPPED! PORTION configuration error.");
						}

						//wsprintf(G_cTxt, "%d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, , (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
						//PutLogList(G_cTxt);

						/*
						if ((m_bIsGameStarted == FALSE) && (m_bIsItemAvailable == TRUE) &&
							(m_bIsNpcAvailable == TRUE) && (m_bIsLogSockAvailable == TRUE) && 
							(m_bIsMagicAvailable == TRUE) &&
							(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
							(m_bIsQuestAvailable == TRUE) ) {
							// °ÔÀÓÀ» ½ÃÀÛÇÒ ÁØºñ°¡ µÇ¾ú´Ù. ¸Þ½ÃÁö¸¦ º¸³½´Ù.
							SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
							m_bIsGameStarted = TRUE;
						}
						 */
						break;

					case MSGID_RESPONSE_PLAYERDATA:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_PLAYERDATA");
						// ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù.
						ResponsePlayerDataHandler(pData, dwMsgSize);
						break;

					case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_BUILDITEMCONFIGURATIONCONTENTS");
						// Build Item contents
						PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
						m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

					case MSGID_ITEMCONFIGURATIONCONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_ITEMCONFIGURATIONCONTENTS");
						// ·Î±×¼­¹ö·ÎºÎÅÍ ¾ÆÀÌÅÛ ÄÁÇÇ±Ô·¹ÀÌ¼Ç µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù.
						PutLogList("(!) ITEM configuration contents received. Now decoding...");
						m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

					case MSGID_NPCCONFIGURATIONCONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NPCCONFIGURATIONCONTENTS");
						// NPC ÄÁÇÇ±Ô·¹ÀÌ¼Ç µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù.
						PutLogList("(!) NPC configuration contents received. Now decoding...");
						m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

					case MSGID_MAGICCONFIGURATIONCONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_MAGICCONFIGURATIONCONTENTS");
						PutLogList("(!) MAGIC configuration contents received. Now decoding...");
						m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

					case MSGID_SKILLCONFIGURATIONCONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_SKILLCONFIGURATIONCONTENTS");
						PutLogList("(!) SKILL configuration contents received. Now decoding...");
						m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

					case MSGID_QUESTCONFIGURATIONCONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_QUESTCONFIGURATIONCONTENTS");
						PutLogList("(!) QUEST configuration contents received. Now decoding...");
						m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

					case MSGID_PORTIONCONFIGURATIONCONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_PORTIONCONFIGURATIONCONTENTS");
						PutLogList("(!) PORTION configuration contents received. Now decoding...");
						m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

						// Crusade
						//case MSGID_ARESDENOCCUPYFLAGSAVEFILECONTENTS:
						//PutLogList("(!) Aresden OccupyFlag save file contents received. Now decoding...");
						//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 1);
						//break;

						// Crusade
						//case MSGID_ELVINEOCCUPYFLAGSAVEFILECONTENTS:
						//PutLogList("(!) Elvine OccupyFlag save file contents received. Now decoding...");
						//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 2);
						//break;

					case MSGID_DUPITEMIDFILECONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_DUPITEMIDFILECONTENTS");
						PutLogList("(!) DupItemID file contents received. Now decoding...");
						_bDecodeDupItemIDFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

					case MSGID_NOTICEMENTFILECONTENTS:
						//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NOTICEMENTFILECONTENTS");
						PutLogList("(!) Noticement file contents received. Now decoding...");
						_bDecodeNoticementFileContents((char *) (pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
						break;

						// v2.17 2002-8-7 // 2002-09-06 #1
						/*case MSGID_NPCITEMCONFIGCONTENTS:
							PutLogList("(!) NpcItemConfig file contents received. Now decoding...");
							_bDecodeNpcItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
							break;*/

				}
				break;
		}
	}

}

BOOL CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey) {
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // ¹ÂÅØ½º°¡ »ý¼ºµÇ¾î ÀÖ´Ù. ¾îµð¼±°¡ Å¥¸¦ Á¶ÀÛÁßÀÌ´Ù. ±×³É ¸®ÅÏ

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	 */
	// ¸Þ½ÃÁö Å¥°¡ ´Ù Ã¡´Ù¸é ¿¡·¯
	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;

	// ¸Þ¸ð¸® ÇÒ´çÀÌ Àß¸øµÇ¾îµµ ¿¡·¯
	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;

	// ¹ÂÅØ½º ¹ÝÈ¯
	//ReleaseMutex(hMutex);

	return TRUE;
}

BOOL CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey) {
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // ¹ÂÅØ½º°¡ »ý¼ºµÇ¾î ÀÖ´Ù. ¾îµð¼±°¡ Å¥¸¦ Á¶ÀÛÁßÀÌ´Ù. ±×³É ¸®ÅÏ

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	 */
	// °¡Á®°¥ ¸Þ½ÃÁö°¡ ¾øÀ¸¸é ¿¡·¯
	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

	// ¹ÂÅØ½º ¹ÝÈ¯
	//ReleaseMutex(hMutex);

	return TRUE;
}

void CGame::ClientCommonHandler(int iClientH, char * pData) {
	WORD * wp, wCommand;
	short * sp, sX, sY;
	int * ip, iV1, iV2, iV3, iV4;
	char * cp, cDir, * pString;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *) cp;
	sX = *sp;
	cp += 2;

	sp = (short *) cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	ip = (int *) cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *) cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *) cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;

	ip = (int *) cp;
	iV4 = *ip;
	cp += 4;

	switch (wCommand) {



			// New 15/05/2004
		case DEF_COMMONTYPE_REQ_CREATESLATE:
			ReqCreateSlateHandler(iClientH, pData);
			break;

			// 2.06 - by KLKS
		case DEF_COMMONTYPE_REQ_CHANGEPLAYMODE:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> MSGID_REQUEST_CIVILRIGHT");
			RequestChangePlayMode(iClientH);
			break;
			//

		case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDTELEPORTLOC");
			RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, "middleland");
			break;

		case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC");
			RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
			break;

		case DEF_COMMONTYPE_GUILDTELEPORT:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GUILDTELEPORT");
			RequestGuildTeleportHandler(iClientH);
			break;

		case DEF_COMMONTYPE_SUMMONWARUNIT:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SUMMONWARUNIT");
			RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
			break;

		case DEF_COMMONTYPE_REQUEST_HELP:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_HELP");
			RequestHelpHandler(iClientH);
			break;

		case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_MAPSTATUS");
			MapStatusHandler(iClientH, iV1, pString);
			break;

		case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY");
			SelectCrusadeDutyHandler(iClientH, iV1);
			break;

		case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_CANCELQUEST");
			CancelQuestHandler(iClientH);
			break;

		case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY");
			ActivateSpecialAbilityHandler(iClientH);
			break;

		case DEF_COMMONTYPE_REQUEST_JOINPARTY:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_JOINPARTY");
			JoinPartyHandler(iClientH, iV1, pString);
			break;

		case DEF_COMMONTYPE_GETMAGICABILITY:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GETMAGICABILITY");
			GetMagicAbilityHandler(iClientH);
			break;

		case DEF_COMMONTYPE_BUILDITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_BUILDITEM");
			BuildItemHandler(iClientH, pData);
			break;

		case DEF_COMMONTYPE_QUESTACCEPTED:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_QUESTACCEPTED");
			QuestAcceptedHandler(iClientH);
			break;

		case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CANCELEXCHANGEITEM");
			CancelExchangeItem(iClientH);
			break;

		case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CONFIRMEXCHANGEITEM");
			ConfirmExchangeItem(iClientH);
			break;

		case DEF_COMMONTYPE_SETEXCHANGEITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETEXCHANGEITEM");
			SetExchangeItem(iClientH, iV1, iV2);
			break;

		case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETHEROMANTLE");
			GetHeroMantleHandler(iClientH, iV1, pString);
			break;

		case DEF_COMMONTYPE_REQ_GETTRADEEK: // By Luqah
			GetTradeEKMantleHandler(iClientH, iV1, pString);
			break;

		case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFLAG");
			GetOccupyFlagHandler(iClientH);
			break;

		case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX");
			SetDownSkillIndexHandler(iClientH, iV1);
			break;

		case DEF_COMMONTYPE_TALKTONPC:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TALKTONPC");
			// works for client, but for npc it returns middleland
			// if ((m_pMapList[m_pNpcList[iV1]->m_cMapIndex]->m_cName) != (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) break;
			NpcTalkHandler(iClientH, iV1);
			break;

		case DEF_COMMONTYPE_REQ_CREATEPORTION:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_CREATEPORTION");
			ReqCreatePortionHandler(iClientH, pData);
			break;

		case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETFISHTHISTIME");
			ReqGetFishThisTimeHandler(iClientH);
			break;

		case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM");
			ReqRepairItemCofirmHandler(iClientH, iV1, pString);
			break;

		case DEF_COMMONTYPE_REQ_REPAIRITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEM");
			ReqRepairItemHandler(iClientH, iV1, iV2, pString);
			break;

		case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEMCONFIRM");
			ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
			break;

		case DEF_COMMONTYPE_REQ_SELLITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEM");
			ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
			break;

		case DEF_COMMONTYPE_REQ_USESKILL:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USESKILL");
			UseSkillHandler(iClientH, iV1, iV2, iV3);
			break;

		case DEF_COMMONTYPE_REQ_USEITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USEITEM");
			UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
			break;

		case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETREWARDMONEY");
			GetRewardMoneyHandler(iClientH);
			break;

		case DEF_COMMONTYPE_ITEMDROP:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_ITEMDROP");
			DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
			break;

		case DEF_COMMONTYPE_EQUIPITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EQUIPITEM");
			// ¿©±â¼­´Â Æ¯¼ºÄ¡ º¯È­¸¸À» ´Ù·é´Ù.
			bEquipItemHandler(iClientH, iV1);
			// ¹Ù²ï ¿ÜÇü¿¡ ´ëÇÑ Á¤º¸¸¦ ¿©±â¼­ Àü¼ÛÇÑ´Ù.
			// .....
			break;

		case DEF_COMMONTYPE_REQ_PURCHASEITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_PURCHASEITEM");
			// ¾ÆÀÌÅÛ ±¸ÀÔ ¿ä±¸. »ç½Ç ¾ÆÀÌÅÛÀº Àå¼Ò¿¡ »ó°ü¾øÀÌ ¾îµð¼­¶óµµ ±¸ÀÔÇÒ ¼ö ÀÖ´Ù.
			RequestPurchaseItemHandler(iClientH, pString, iV1);
			break;

		case DEF_COMMONTYPE_REQ_STUDYMAGIC:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_STUDYMAGIC");
			// ¸¶¹ýÀ» ¹è¿î´Ù
			RequestStudyMagicHandler(iClientH, pString);
			break;

		case DEF_COMMONTYPE_REQ_TRAINSKILL:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_TRAINSKILL");
			//RequestTrainSkillHandler(iClientH, pString);
			break;

		case DEF_COMMONTYPE_GIVEITEMTOCHAR:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GIVEITEMTOCHAR");
			// ¾ÆÀÌÅÛÀ» ´Ù¸¥ Ä³¸¯ÅÍ¿¡°Ô Àü´ÞÇÑ´Ù.
			GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
			break;

		case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EXCHANGEITEMTOCHAR");
			ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
			break;

		case DEF_COMMONTYPE_JOINGUILDAPPROVE:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDAPPROVE");
			JoinGuildApproveHandler(iClientH, pString);
			break;

		case DEF_COMMONTYPE_JOINGUILDREJECT:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDREJECT");
			JoinGuildRejectHandler(iClientH, pString);
			break;

		case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDAPPROVE");
			DismissGuildApproveHandler(iClientH, pString);
			break;

		case DEF_COMMONTYPE_DISMISSGUILDREJECT:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDREJECT");
			DismissGuildRejectHandler(iClientH, pString);
			break;

		case DEF_COMMONTYPE_RELEASEITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_RELEASEITEM");
			// Å¬¶óÀÌ¾ðÆ®°¡ ÀåÂøµÈ ¾ÆÀÌÅÛÀ» ÇØÁ¦Çß´Ù.
			ReleaseItemHandler(iClientH, iV1, TRUE);
			break;

		case DEF_COMMONTYPE_TOGGLECOMBATMODE:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLECOMBATMODE");
			ToggleCombatModeHandler(iClientH);
			break;

		case DEF_COMMONTYPE_MAGIC:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_MAGIC");
			PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
			break;

		case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLESAFEATTACKMODE");
			ToggleSafeAttackModeHandler(iClientH);
			break;

			// v1.4311-3 Ãß°¡ ÀÔÀå±Ç ¹Þ±â  case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET");
			GetFightzoneTicketHandler(iClientH);
			break;

			// Upgrade Item
		case DEF_COMMONTYPE_UPGRADEITEM:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_UPGRADEITEM");
			RequestItemUpgradeHandler(iClientH, iV1);
			break;

		case DEF_COMMONTYPE_REQGUILDNAME:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQGUILDNAME");
			RequestGuildNameHandler(iClientH, iV1, iV2);
			break;

		case DEF_COMMONTYPE_REQRANGO: // MORLA 2.2 - Llama al rango del pj
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQGUILDNAME");
			RequestRango(iClientH, iV1);
			break;

		case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
			//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY");
			RequestAcceptJoinPartyHandler(iClientH, iV1);
			break;

			// Crafting
		case DEF_COMMONTYPE_CRAFTITEM:
			ReqCreateCraftingHandler(iClientH, pData);
			break;

		default:
			wsprintf(G_cTxt, "Unknown message received! (0x%.8X)", wCommand);
			PutLogList(G_cTxt);
			break;
	}
}

// New 07/05/2004

void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, BOOL bByPlayer) {
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	// Amount°¡ -1ÀÌ°í ¼Ò¸ðÇ°ÀÌ¸é ¼ö·®ÀÇ ÀüºÎ¸¦ ¶³¾î¶ß¸°´Ù.
	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
			  (iAmount == -1))
		iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;


	// ¾ÆÀÌÅÛ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«½Ã
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
			  (((int) m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0)) {
		// ¼Òºñ¼º ¾ÆÀÌÅÛÀÌ¾ú°í ¼ö·®¸¸Å­ °¨¼Ò½ÃÅ°°í ³²Àº °Ô ÀÖ´Ù¸é
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			// ºÐÇÒÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Â °Å´Ù. ÀÌ·± ÀÏÀº ÀÏ¾î³¯ ¼ö°¡ ¾øÁö¸¸
			delete pItem;
			return;
		} else {
			if (iAmount <= 0) {
				// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ 0º¸´Ù ÀÛÀ¸¸é ¿¡·¯»óÈ². ¸®ÅÏ
				delete pItem;
				return;
			}
			pItem->m_dwCount = (DWORD) iAmount;
		}

		// ¼ö·® °¨¼Ò

		// ¿¡·¯. °¨¼Ò½ÃÅ°°íÀÚ ÇÏ´Â ¾çÀÌ ´õ ¸¹´Ù.
		if ((DWORD) iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
			delete pItem;
			return;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// º¯°æµÈ ¼ö·®À» ¼³Á¤ÇÏ°í ¾Ë¸°´Ù.
		// v1.41 !!!
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù.
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
				  m_pClientList[iClientH]->m_sY, pItem);

		// v1.411 Èñ±Í ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀÎÁö Ã¼Å©
		// v2.17 2002-7-31 ÇÃ·¹ÀÌ¾î°¡ Á×¾î¼­ ¶³¾îÁø°Ç ¸ðµç ·Î±×°¡ ³²´Â´Ù.
		if (bByPlayer == TRUE)
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) - 1, pItem);
		else
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) - 1, pItem, TRUE);

		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				  pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
	} else {
		// ÀÏ¹Ý ¾ÆÀÌÅÛÀÌ³ª ¼Òºñ¼º ¾ÆÀÌÅÛÀ» ¸ðµÎ ¹ö·È´Ù.

		// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù.

		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// v2.17 ¾ÆÀÌÅÛÀÌ ÀåÂøµÇ¾î ÀÖÀ¸¸é ÇØÁ¦ÇÑ´Ù.
		if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) &&
				  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
			// Èñ»ýÀÇ µ¹ÀÎ °æ¿ì ¼ö¸íÀÌ 0ÀÎ »óÅÂ·Î ¶³¾îÁö¸é »ç¶óÁø´Ù.
			delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		} else {
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
					  m_pClientList[iClientH]->m_sY,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù.
			// v2.17 2002-7-31 ÇÃ·¹ÀÌ¾î°¡ Á×¾î¼­ ¶³¾îÁø°Ç ¸ðµç ·Î±×°¡ ³²´Â´Ù.
			if (bByPlayer == TRUE)
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) - 1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) - 1, m_pClientList[iClientH]->m_pItemList[sItemIndex], TRUE);

			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
		}

		// ¾ÆÀÌÅÛÀ» deleteÇÏÁö ¾Ê°í NULL·Î ÇÒ´çÇÑ´Ù. delete ÇÏÁö ¾Ê´Â ÀÌÀ¯´Â ¹Ù´Ú¿¡ ¶³¾îÁ® ÀÖ±â ¶§¹®
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);

		// ÀÎµ¦½º°¡ ¹Ù²î¾úÀ¸¹Ç·Î ÀçÇÒ´ç
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
	iCalcTotalWeight(iClientH);
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: check if player is dropping item or picking up item
//  last updated		:: October 29, 2004; 7:12 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////

int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir) {
	DWORD * dwp;
	WORD * wp;
	char * cp;
	short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
	char cRemainItemColor, cData[100];
	int iRet, iEraseReq;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8)) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
			case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++;
				break;
			case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;
				break;
			case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;
				break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
	if (pItem != NULL) {
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

			_bItemLog(DEF_ITEMLOG_GET, iClientH, NULL, pItem);

			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_ITEMOBTAINED;

			cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp = (DWORD *) cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char) 0;
			cp++;

			sp = (short *) cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *) cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *) cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp = (short *) cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp = (short *) cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char) pItem->m_sItemSpecEffectValue2;
			cp++;

			dwp = (DWORD *) cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
					  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					  sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
			}
		} else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);

			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
			}
		}
	}

	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
	}

	return 1;
}

BOOL CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq) {
	register int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;

	// ÁýÀ» ¾ÆÀÌÅÛ Áß·®°è»ê
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// ¼ö·®°³³äÀÌ ÀÖ´Â ¾ÆÀÌÅÛ
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD) _iCalcMaxLoad(iClientH))
			return FALSE;
	} else {
		// ¼ö·® °³³äÀÌ ¾ø´Â ¾ÆÀÌÅÛ
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD) _iCalcMaxLoad(iClientH))
			return FALSE;
	}

	// ¼Òºñ¼º ¾ÆÀÌÅÛÀ» ÀÌ¹Ì ¼ÒÁöÇÏ°í ÀÖ´Ù¸é ¼ö·®¸¸ Áõ°¡½ÃÅ²´Ù.
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) &&
					  (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0)) {
				// °°Àº ÀÌ¸§À» Ã£¾Ò´Ù.
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
				//delete pItem;
				*pDelReq = 1;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
				iCalcTotalWeight(iClientH);

				return TRUE;
			}
	}

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {

			m_pClientList[iClientH]->m_pItemList[i] = pItem;
			// v1.3 ¾ÆÀÌÅÛÀÇ À§Ä¡´Â ¹«Á¶°Ç 100, 100
			m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
			m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

			*pDelReq = 0;

			// ¸¸¾à È­»ì·ù ¾ÆÀÌÅÛÀÌ¶ó¸é È­»ìÀ» ÇÒ´çÇÑ´Ù.
			if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
			iCalcTotalWeight(iClientH);

			return TRUE;
		}

	// ´õÀÌ»ó ¾ÆÀÌÅÛÀ» ÁýÀ» °ø°£ÀÌ ¾ø´Ù.
	return FALSE;
}

BOOL CGame::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify) {
	char cEquipPos, cHeroArmorType;
	short sSpeed;
	short sTemp;
	int iTemp;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL) &&
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
			case 1:
			case 2:
			case 3:
				// ³²¼ºÀÌ´Ù.
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
				break;
			case 4:
			case 5:
			case 6:
				// ¿©¼ºÀÌ´Ù.
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
				break;
		}
	}

	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr)*100) return FALSE;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) ||
			  (cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
			case 10: // Str Á¦ÇÑ
				if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
					// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
					// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
					return FALSE;
				}
				break;
			case 11: // Dex
				if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
					// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
					// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
					return FALSE;
				}
				break;
			case 12: // Vit
				if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
					// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
					// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
					return FALSE;
				}
				break;
			case 13: // Int
				if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
					// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
					// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
					return FALSE;
				}
				break;
			case 14: // Mag
				if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
					// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
					// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
					return FALSE;
				}
				break;
			case 15: // Chr
				if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
					// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
					// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
					return FALSE;
				}
				break;
		}
	}

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		// Stormbringer
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iInt) < 65) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, sItemIndex, TRUE);
				return FALSE;
			}
		}
	}

	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		// Resurrection wand(MS.10) or Resurrection wand(MS.20)
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 99 && (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 99 && m_pClientList[iClientH]->m_iSpecialAbilityTime < 1) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
			}
		}
	}

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {

		if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
			// ÀÌ¹Ì Æ¯¼ö´É·ÂÀÌ ¼³Á¤µÇ¾î ÀÖ´Ù. ÀÌÀü¿¡ ÀåÂøµÇ¾î ÀÖ´Â ¾ÆÀÌÅÛ Âø¿ë ÇØÁ¦:
			// ´Ü, Âø¿ë ºÎÀ§°¡ °°´Ù¸é ÇØÁ¦ ¸Þ½ÃÁö º¸³»Áö ¾Ê´Â´Ù.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
			}
		}
	}


	if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		// ¾ç¼ÕÀ» »ç¿ëÇÏ´Â ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ´Ù¸é
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			// ¿À¸¥¼Õ, ¿Þ¼Õ¿¡ ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é ¸ðµÎ ÀåÂø ÇØÁ¦
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], FALSE);
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], FALSE);
		}
	} else {
		// ¾ç¼Õ ¾ÆÀÌÅÛÀÌ ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù.
		if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
			// ¹«±â³ª ¹æÆÐ·ù¶ó¸é ¾ç¼Õ¹«±â¸¦ ÇØÁ¦
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], FALSE);
		}

		// ÀåÂøÀ§Ä¡¿¡ ¾ÆÀÌÅÛÀÌ ÀÌ¹Ì ÀÖÀ¸¸é »èÁ¦.
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}


	if (cEquipPos == DEF_EQUIPPOS_RELEASEALL) {
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ], FALSE);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ], FALSE);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ], FALSE);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ], FALSE);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ], FALSE);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ], FALSE);
		}
	} else {
		if (cEquipPos == DEF_EQUIPPOS_HEAD || cEquipPos == DEF_EQUIPPOS_BODY || cEquipPos == DEF_EQUIPPOS_ARMS ||
				  cEquipPos == DEF_EQUIPPOS_LEGGINGS || cEquipPos == DEF_EQUIPPOS_PANTS || cEquipPos == DEF_EQUIPPOS_BACK) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ] != -1) {
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ], FALSE);
			}
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}


	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;

	switch (cEquipPos) {

		case DEF_EQUIPPOS_HEAD:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0xFF0F; // Åõ±¸ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFFFF0; // ºÎÃ÷ »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_PANTS:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0xF0FF; // ¹ÙÁö Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFF0FF; // ¹ÙÁö »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_LEGGINGS:
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0x0FFF; // ºÎÃ÷ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr4 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFFF0F; // ºÎÃ÷ »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_BODY:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0x0FFF; // °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.

			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
				// ¿ÜÇü°ªÀÌ 100 ÀÌÇÏ. Á¤»óÀûÀÎ °ª
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ.
				m_pClientList[iClientH]->m_sAppr3 = sTemp;
			} else {
				// ¿ÜÇü°ªÀÌ 100 ÀÌ»óÀÌ¸é È®Àå ÇÃ·¡±×¸¦ »ç¿ëÇÑ´Ù.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr °ªÀ» ¼¼ÆÃ.
				m_pClientList[iClientH]->m_sAppr3 = sTemp;
				// °Ñ¿Ê È®Àå Æ¯¼ºÄ¡ ºñÆ®¸¦ ¼¼Æ®.
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp | 0x080;
				m_pClientList[iClientH]->m_sAppr4 = sTemp;
			}

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFF0FFFFF; // °Ñ¿Ê(°©¿Ê) »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_ARMS:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0xFFF0; // ¼Ó¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFFFFF; // ¼Ó¿Ê »ö ºñÆ®¸¦ Å¬¸®¾î. // New 09/05/2004
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_LHAND:
			// ¿Þ¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹æÆÐ·ùÀÌ´Ù.
			sTemp = m_pClientList[iClientH]->m_sAppr2;
			sTemp = sTemp & 0xFFF0; // ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr2 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xF0FFFFFF; // ¹æÆÐ »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_RHAND:
			// ¿À¸¥¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹«±â·ùÀÌ´Ù.
			sTemp = m_pClientList[iClientH]->m_sAppr2;
			sTemp = sTemp & 0xF00F; // ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr2 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
			m_pClientList[iClientH]->m_iApprColor = iTemp;

			// ¹«±â ¼Óµµ¸¦ ³ªÅ¸³»´Â StatusÀÇ ºñÆ®¸¦ ¼³Á¤ÇÑ´Ù.
			iTemp = m_pClientList[iClientH]->m_iStatus;
			iTemp = iTemp & 0xFFFFFFF0;
			sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
			// Str¿¡ µû¶ó ¹«±â ¼Óµµ¸¦ ÁÙÀÎ´Ù.
			sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
			if (sSpeed < 0) sSpeed = 0;
			iTemp = iTemp | (int) sSpeed;
			m_pClientList[iClientH]->m_iStatus = iTemp;
			m_pClientList[iClientH]->m_iComboAttackCount = 0;
			break;

		case DEF_EQUIPPOS_TWOHAND:
			// ¾ç¼ÕÅ¸ÀÔÀÌÁö¸¸ »ç½Ç ¿À¸¥¼Õ¿¡ ÀåÂøµÈ´Ù.
			sTemp = m_pClientList[iClientH]->m_sAppr2;
			sTemp = sTemp & 0xF00F; // ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr2 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
			m_pClientList[iClientH]->m_iApprColor = iTemp;

			// ¹«±â ¼Óµµ¸¦ ³ªÅ¸³»´Â StatusÀÇ ºñÆ®¸¦ ¼³Á¤ÇÑ´Ù.
			iTemp = m_pClientList[iClientH]->m_iStatus;
			iTemp = iTemp & 0xFFFFFFF0;
			sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
			// Str¿¡ µû¶ó ¹«±â ¼Óµµ¸¦ ÁÙÀÎ´Ù.
			sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
			if (sSpeed < 0) sSpeed = 0;
			iTemp = iTemp | (int) sSpeed;
			m_pClientList[iClientH]->m_iStatus = iTemp;
			m_pClientList[iClientH]->m_iComboAttackCount = 0;
			break;

		case DEF_EQUIPPOS_BACK:
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xF0FF; // ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr4 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFF0FFFF; // ¸ÁÅä »ö ºñÆ®¸¦ Å¬¸®¾î.
			iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_RELEASEALL:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0x0FFF; // ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFF0FFFF; // ¸ÁÅä »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// °ø°Ý Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
			case 0: break;
			case 1: // °ø°Ý½Ã 50% HP °¨¼Ò
				m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;
				break;

			case 2: // ³Ãµ¿ È¿°ú
				m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;
				break;

			case 3: // ¸¶ºñ È¿°ú
				m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;
				break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
			case 0:
				break;
			case 50:
			case 51:
			case 52:
				m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;
				break;
			default:
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0)
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;
				// m_sAppr4
				// 0x0001 GM
				// 0x0002 Green
				// 0x0003 ice element
				// 0x0004 sparkle
				// 0x0005 sparkle green gm
				// 0x0006 sparkle green
				break;
		}
	}

	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = cHeroArmorType;

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);
	return TRUE;

}

void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4) {
	int i, iRet, iShortCutIndex;
	char * cp, cData[100];
	DWORD * dwp, dwTime;
	WORD * wp;
	short * sp;
	BOOL bFlag;

	std::memset(cData, 0, sizeof(cData));

	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = wMsgType;

	cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *) cp;
	*sp = sX;
	cp += 2;

	sp = (short *) cp;
	*sp = sY;
	cp += 2;

	sp = (short *) cp;
	*sp = sV1;
	cp += 2;

	sp = (short *) cp;
	*sp = sV2;
	cp += 2;

	sp = (short *) cp;
	*sp = sV3;
	cp += 2;

	sp = (short *) cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = TRUE;
	iShortCutIndex = 0;
	while (bFlag == TRUE) {
		// DEF_MAXCLIENTS ±îÁö ·çÇÁ¸¦ µ¹Áö ¾Ê±â À§ÇÑ ¹æ¹ý. Å¬¶óÀÌ¾ðÆ® ¼ôÄÆ ¸®½ºÆ®¿¡¼­ 0ÀÌ ³ª¿À¸é ³¡ÀÌ´Ù.
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;

		if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {
			if ((m_pClientList[i]->m_cMapIndex == cMapIndex) &&
					  (m_pClientList[i]->m_sX >= sX - 10) &&
					  (m_pClientList[i]->m_sX <= sX + 10) &&
					  (m_pClientList[i]->m_sY >= sY - 8) &&
					  (m_pClientList[i]->m_sY <= sY + 8)) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is stopped
//  last updated		:: October 29, 2004; 6:46 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////

int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir) {
	char cData[100];
	DWORD * dwp;
	WORD * wp;
	int iRet;
	short sOwnerH;
	char cOwnerType;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8)) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	ClearSkillUsingStatus(iClientH);

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
			case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++;
				break;
			case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;
				break;
			case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;
				break;
		}
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize) {
	register int i;
	WORD * wp, wResult;
	DWORD * dwp;
	char * cp, cCharName[11], cData[100], cTxt[120];
	int iRet;

	// ·Î±× ¼­¹ö·ÎºÎÅÍ ±æµå »ý¼º ¿äÃ»¿¡ ´ëÇÑ ÀÀ´äµ¥ÀÌÅÍ°¡ µµÂøÇß´Ù.
	std::memset(cCharName, 0, sizeof(cCharName));
	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£´Â´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
				  (m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) {

			wp = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
				case DEF_LOGRESMSGTYPE_CONFIRM:
					// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù.
					wResult = DEF_MSGTYPE_CONFIRM;
					// ±æµå ÀÌ¸§Àº ÀÌ¹Ì ÀúÀåµÇ¾î ÀÖÀ¸¹Ç·Î ·©Å©¸¦ 0À¸·Î ¹Ù²ã À¯È¿È­ ÇÑ´Ù.
					m_pClientList[i]->m_iGuildRank = 0; // ±æµå ·©Å©´Â 0. ±æµå¸¶½ºÅÍÀÓ
					wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
					PutLogList(cTxt);
					break;

				case DEF_LOGRESMSGTYPE_REJECT:
					// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ½ÇÆÐÇÏ¿´´Ù.
					// ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµåÀÌ¸§À» ÃÊ±âÈ­ÇÑ´Ù "NONE".
					wResult = DEF_MSGTYPE_REJECT;
					std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
					memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
					m_pClientList[i]->m_iGuildRank = -1;
					m_pClientList[i]->m_iGuildGUID = -1;
					wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
					PutLogList(cTxt);
					break;
			}

			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = wResult;

			// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(i, TRUE, TRUE);
					return;
			}

			return;
		}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize) {
	char * cp, cGuildName[21], cTxt[120], cData[100];
	DWORD * dwp;
	WORD * wp;
	int iRet;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	cp += 10;
	cp += 10;
	cp += 10;

	std::memset(cGuildName, 0, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// ÀÌ Ä³¸¯ÅÍ´Â ÀÌ¹Ì ±æµå¿¡ °¡ÀÔÇÏ¿© ÀÖÀ¸¹Ç·Î ±æµå¸¦ ¸¸µé ¼ö ¾ø´Ù.
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	} else {
		if ((m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
				  (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
				  (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0)) { // v1.4
			// ÀÚ°Ý¿ä°ÇÀÌ ¸ÂÁö ¾Ê´Â´Ù. Æ¯¼ºÄ¡°¡ ³·°Å³ª ¸¶À»ÀÇ À§Ä¡°¡ ´Ù¸£°Å³ª ½Ã¹ÎÀÌ ¾Æ´Ñ °æ¿ì
			std::memset(cData, 0, sizeof(cData));

			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_REJECT;

			// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		} else {
			// ±æµå ÀÌ¸§À» ÀÓ½Ã·Î ÀúÀåÇÑ´Ù. -> ¾îÂ÷ÇÇ ±æµå ÀÌ¸§Àº Rank°¡ -1ÀÏ¶§ ¹«ÀÇ¹ÌÇÏ¹Ç·Î .
			std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			// ±æµåÀÇ ¼Ò¼Ó ¸¶À» ÀÌ¸§À» ÀúÀåÇÑ´Ù.
			std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			// ±æµåÀÇ GUID¸¦ »ý¼ºÇÏ¿© ÀÔ·ÂÇÑ´Ù.
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int) (SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());

			// ±æµå »ý¼º¿äÃ» ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}

void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize) {
	char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);
	std::memset(cGuildName, 0, sizeof(cGuildName));

	cp += 10;
	cp += 10;
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		// ±æµå¸¶½ºÅÍ°¡ ¾Æ´Ï°Å³ª ±æµåÀÇ ÀÌ¸§ÀÌ ´Ù¸£¹Ç·Î ±æµåÇØ»êÀÇ ±ÇÇÑÀÌ ¾ø´Ù.
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	} else {
		// ±æµå ÇØ»ê ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
		bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize) {
	register int i;
	WORD * wp, wResult;
	DWORD * dwp;
	char * cp, cCharName[11], cData[100], cTxt[120];
	int iRet;

	// �α� �����κ��� ��� �ػ� ��û�� ���� ���䵥���Ͱ� �����ߴ�.
	std::memset(cCharName, 0, sizeof(cCharName));
	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;

	// �̸��� ��ġ�ϴ� Ŭ���̾�Ʈ�� ã�´�.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {

			wp = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
				case DEF_LOGRESMSGTYPE_CONFIRM:
					// Ŭ���̾�Ʈ�� ��� �ػ� �䱸�� �����Ͽ���.
					wResult = DEF_MSGTYPE_CONFIRM;
					wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
					PutLogList(cTxt);

					// �������� ����鿡�� ��尡 �ػ�Ǿ����� �˸��� �޽����� ����Ѵ�.
					SendGuildMsg(i, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);

					// ����̸� Ŭ����
					std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
					memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
					m_pClientList[i]->m_iGuildRank = -1; // ��� ��ũ�� -1. ������ �ƴϴ�.
					m_pClientList[i]->m_iGuildGUID = -1;
					break;

				case DEF_LOGRESMSGTYPE_REJECT:
					// Ŭ���̾�Ʈ�� ��� �ػ� �䱸�� �����Ͽ���.
					wResult = DEF_MSGTYPE_REJECT;
					wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
					PutLogList(cTxt);
					break;
			}

			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_DISBANDGUILD;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = wResult;

			// ��� �ػ� �䱸 ���� �޽����� Ŭ���̾�Ʈ���� ���
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
					DeleteClient(i, TRUE, TRUE);
					return;
			}
			return;
		}

	// �̸��� ��ġ�ϴ� Ŭ���̾�Ʈ�� ã�� �� ���.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

// 05/29/2004 - Hypnotoad - Purchase Dicount updated to take charisma into consideration

void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum) {
	class CItem * pItem;
	char * cp, cItemName[21], cData[100];
	short * sp;
	DWORD * dwp, dwGoldCount, dwItemCount;
	WORD * wp, wTempPrice;
	int i, iRet, iEraseReq, iGoldWeight;
	int iCost2;
	int iCost, iDiscountRatio, iDiscountCost;
	double dTmp1, dTmp2, dTmp3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	// ¸¸¾à ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é ±¸ÀÔÇÒ ¼ö ¾ø´Ù.
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
					  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0)) {

			} else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
					  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)) {

			} else return;
		}
	}


	// ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÑ´Ù.
	std::memset(cData, 0, sizeof(cData));
	std::memset(cItemName, 0, sizeof(cItemName));

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

	// ÀÓ½ÃÄÚµå´Ù.
	if (memcmp(pItemName, "10Arrows", 8) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 10;
	} else if (memcmp(pItemName, "100Arrows", 9) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 100;
	} else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}

	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		} else {

			if (pItem->m_bIsForSale == FALSE) {
				// ÆÇ¸ÅµÇ´Â ¾ÆÀÌÅÛÀÌ ¾Æ´Ï´Ù. »ì ¼ö ¾ø´Ù.
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;
			if (m_pClientList[iClientH]->m_cSide == m_iLastCrusadeWinner) {
				iCost = (int) ((float) (pItem->m_wPrice) * 0.9f + 0.5f);
				iCost = iCost * pItem->m_dwCount;
				iCost2 = pItem->m_wPrice * pItem->m_dwCount;
			} else {
				iCost2 = iCost = ((pItem->m_wPrice * pItem->m_dwCount)*2);
			}

			// °¡°ÝÀ» °è»êÇÑ´Ù.
			iCost = pItem->m_wPrice * pItem->m_dwCount;

			/* v1.3 <- ÀÌ°Ç _bAddClientItemList¿¡¼­ Ã¼Å©ÇÏ´Â ±â´ÉÀÌ¹Ç·Î µÎ¹øÇÒ ÇÊ¿ä°¡ ¾ø´Ù.
			if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW))
				iItemWeight = (pItem->m_wWeight * pItem->m_dwCount);
			else iItemWeight = pItem->m_wWeight;

			if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
				// Áß·® ÃÊ°ú. ±¸ÀÔÇÒ ¼ö ¾ø´Ù.

				// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			 *dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			 *wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}

				delete pItem;
				return;
			}
			 */

			// ÇÃ·¹ÀÌ¾î°¡ ¼ÒÁöÇÑ Gold°¡ ¾ÆÀÌÅÛÀ» »ç±â¿¡ ÃæºÐÇÑÁö °Ë»çÇÑ´Ù.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			// Charisma¿¡ µû¸¥ ÇÒÀÎ·üÀ» °è»êÇÑ´Ù.
			// v2.14 Ä«¸®½º¸¶°¡ 10ÀÎ°æ¿ì ¾ÆÀÌÅÛÀ» ÇÒÀÎ ÇÏÁö ¾ÊÀ½
			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma - 10) / 4);

			// 2.03 Discount Method
			// Charisma¿¡ µû¸¥ ÇÒÀÎ·üÀ» °è»êÇÑ´Ù.
			// iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
			// if (iDiscountRatio == 0) iDiscountRatio = 1;

			dTmp1 = (double) (iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double) iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int) dTmp3;

			if (iDiscountCost >= (iCost / 2)) iDiscountCost = (iCost / 2) - 1;
			if ((iCost - iDiscountCost) <= (iCost2 / 2)) {
				iDiscountCost = iCost - (iCost2 / 2) + 1;
			}
			if (dwGoldCount < (DWORD) (iCost - iDiscountCost)) {
				// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ¾ÆÀÌÅÛ °¡°Ý¿¡ ºñÇØ Àû´Ù. »ì¼ö ¾øÀ½.
				delete pItem;

				dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_NOTIFY_NOTENOUGHGOLD;
				cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = -1; // -1ÀÌ¸é ÀÇ¹Ì¾ø´Ù.
				cp++;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
				return;
			}

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				// ¾ÆÀÌÅÛ »ò´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_NOTIFY_ITEMPURCHASED;

				cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);
				// 1°³ È¹µæÇß´Ù.
				*cp = 1;
				cp++;

				memcpy(cp, pItem->m_cName, 20);
				cp += 20;

				dwp = (DWORD *) cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char) 0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
				cp++;

				sp = (short *) cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *) cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;

				wp = (WORD *) cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp = (short *) cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp = (short *) cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				wp = (WORD *) cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;

				if (iEraseReq == 1) delete pItem;

				// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);

				// GoldÀÇ ¼ö·®À» °¨¼Ò½ÃÅ²´Ù. ¹Ýµå½Ã ¿©±â¼­ ¼¼ÆÃÇØ¾ß ¼ø¼­°¡ ¹Ù²îÁö ¾Ê´Â´Ù.
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
				iCalcTotalWeight(iClientH);

				//v1.4 ¸¶À»ÀÇ ÀÚ±Ý¿¡ ´õÇÑ´Ù.
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;

				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
			} else {
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
				iCalcTotalWeight(iClientH);

				dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
			}
		}
	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName) {
	register int iRet, iEraseReq;
	short * sp, sOwnerH;
	char * cp, cOwnerType, cData[100], cCharName[21];
	DWORD * dwp;
	WORD * wp;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	// ¾ÆÀÌÅÛ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«½ÃµÈ´Ù.
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	std::memset(cCharName, 0, sizeof(cCharName));

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD) iAmount)) {
		// ¼Òºñ¼º ¾ÆÀÌÅÛÀÌ¾ú°í ¼ö·®¸¸Å­ °¨¼Ò½ÃÅ°°í ³²Àº °Ô ÀÖ´Ù¸é

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			// ºÐÇÒÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Â °Å´Ù. ÀÌ·± ÀÏÀº ÀÏ¾î³¯ ¼ö°¡ ¾øÁö¸¸
			delete pItem;
			return;
		} else {
			pItem->m_dwCount = iAmount;
		}

		// ¼ö·® °¨¼Ò: 0º¸´Ù Å©´Ù.
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// º¯°æµÈ ¼ö·®À» ¼³Á¤ÇÏ°í ¾Ë¸°´Ù.
		// v1.41 !!! ¾ÆÀÌÅÛ ÀÌ¸§¿¡¼­ ÀÎµ¦½º·Î º¯°æµÇ¾ú´Ù.
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != NULL) {
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD) sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			} else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD) sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			// ÁÖ°íÀÚ ÇÏ´Â À§Ä¡¿¡ ¾Æ¹«µµ ¾ø´Ù.
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

			// v1.411
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);

			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					  pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		} else {
			// ¾ÆÀÌÅÛÀ» ÁØ´Ù.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// ÇÃ·¹ÀÌ¾î¿¡°Ô ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

				if (sOwnerH == iClientH) {
					// ¸¸¾à ÀÚ±â ÀÚ½Å¿¡°Ô ÁÖ´Â °Å¶ó¸é ¹«½ÃÇÑ´Ù. ÇØÅ·ÀÇ ¼ÒÁö°¡ ÀÖ´Ù.
					delete pItem;
					return;
				}

				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
					*wp = DEF_NOTIFY_ITEMOBTAINED;

					cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

					// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *) cp;
					*dwp = pItem->m_dwCount; // ¼ö·®À» ÀÔ·Â
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char) 0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
					cp++;

					sp = (short *) cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *) cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *) cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *) cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *) cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char) pItem->m_sItemSpecEffectValue2; // v1.41
					cp++;

					dwp = (DWORD *) cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					 *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ
					cp++;
					 */

					if (iEraseReq == 1) delete pItem;

					// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
							DeleteClient(sOwnerH, TRUE, TRUE);
							break;
					}

					// v1.4 ¼ö·®´ÜÀ§ÀÇ ¾ÆÀÌÅÛÀ» Àü´ÞÇÑ °ÍÀ» ¾Ë·ÁÁØ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
				} else {
					// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
					// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
							  m_pClientList[iClientH]->m_sY,
							  pItem);

					// v1.411
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);

					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							  pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

					// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
					*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
							DeleteClient(sOwnerH, TRUE, TRUE);
							break;
					}

					// v1.4 ¼ö·®´ÜÀ§ÀÇ ¾ÆÀÌÅÛÀ» Àü´Þ¿¡ ½ÇÆÐÇßÀ½À» ¾Ë¸°´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
				}

			} else {
				// NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC°¡ Ã¢°í ÁÖÀÎÀÌ¾ú´Ù¸é ¹°°ÇÀ» º¸°üÇÏ°Ú´Ù´Â ÀÇ¹ÌÀÌ´Ù.
					if (bSetItemToBankItem(iClientH, pItem) == FALSE) {
						// ¹°°ÇÀ» ¸Ã±â´Âµ¥ ½ÇÆÐÇÏ¿´´Ù.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

						// ½ÇÆÐÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³±º´Ù.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);

						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
								  pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					}
				} else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);

					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							  pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
				}
			}
		}
	} else {
		// ¾ÆÀÌÅÛ ÀüºÎ¸¦ ÁÖ¾ú´Ù.

		// ÀåÂøÁßÀÎ ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù¸é ¾ÆÀÌÅÛ ÀåÂøÈ¿°ú¸¦ ÇØÁ¦ÇØ¾ß ÇÏ¹Ç·Î.
		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// Ã³¸®µµÁß ¿¡·¯°¡ ¹ß»ýÇÒ¶§¸¦ ´ëºñÇØ¼­ -1·Î ÇÒ´çÇØ ³õ´Â´Ù.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = -1;

		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // ¾ÆÀÌÅÛÀ» dX, dY¿¡ ÀÖ´Â Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. ¸¸¾à ¹ÞÀ» Ä³¸¯ÅÍ°¡ ¾ÆÀÌÅÛÀ» ¹ÞÁö ¸øÇÒ »óÈ²ÀÌ¶ó¸é ¶¥¿¡ ¶³¾îÁø´Ù.

		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != NULL) {
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD) sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			} else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD) sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			// ¾ÆÀÌÅÛÀ» ÁÖ°íÀÚ ÇÏ´Â Àå¼Ò¿¡ Ä³¸¯ÅÍ°¡ ¾ø´Ù.
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
					  m_pClientList[iClientH]->m_sY,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
					  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

			// ÀÌÁ¦ ¾ÆÀÌÅÛÀÌ ¶³¾îÁ³À¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		} else {
			// ¾ÆÀÌÅÛÀ» ´Ù¸¥ Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// ĳ���Ϳ��� �������� �־��.
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];

				// v2.03 ũ�缼�̵� ����ΰ�쵵 ��� ������ �����ϴ�.

				// v2.17 2002-7-31 �������� ������ ������ȣ�� ���� �� �ְ� �Ѵ�.
				if (pItem->m_sIDnum == 88) {

					// �÷��̾� iClientH �� sOwnerH���� ��尡�� ��û���� �־��. ����
					// sOwnerH�� ��帶���Ͷ�� �������� �޴� ���� �ƴ϶� Ȯ���� �� �־�� �Ѵ�.
					// v2.17 2002-7-31 �������� ������ ������ȣ�� ���� �� �ְ� �Ѵ�.
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) &&
							  (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
							  (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
							  (m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
						// ��� �������̴�.	��� �����Ϳ��Դ� ����Ȯ�� ��û �޽����� ����Ѵ�.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// ���� �������� �� ���ο��� �������� �־����Ƿ� ����Ʈ���� �����Ұ��� �뺸�Ѵ�.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int) - 1, pItem);

						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// v2.17 2002-7-31 �������� ������ ������ȣ�� ���� �� �ְ� �Ѵ�.
				if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

					// �÷��̾� iClientH �� sOwnerH���� ���Ż�� ��û���� �־��. ����
					// sOwnerH�� ��帶�����̰� iClientH�� ��� �̸��� ���� iClientH�� �����̶��
					// �������� �޴� ���� �ƴ϶� Ȯ���� �� �־�� �Ѵ�.
					if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
							  (m_pClientList[iClientH]->m_iGuildRank != -1) &&
							  (m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
						// ��� �������̴�.	��� �����Ϳ��Դ� Ż��Ȯ�� ��û �޽����� ����Ѵ�.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// ���� �������� �� ���ο��� �������� �־����Ƿ� ����Ʈ���� �����Ұ��� �뺸�Ѵ�.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int) - 1, pItem);

						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// ÀÏ¹ÝÀûÀÎ °æ¿ì ¾ÆÀÌÅÛÀ» ±×Àú ¹ÞÀ» »Ó...
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {

					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» Àü´ÞÇÑ °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù.
					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
					*wp = DEF_NOTIFY_ITEMOBTAINED;

					cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

					// 1°³ È¹µæÇß´Ù.
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *) cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char) 0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
					cp++;

					sp = (short *) cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *) cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *) cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *) cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *) cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char) pItem->m_sItemSpecEffectValue2; // v1.41
					cp++;

					dwp = (DWORD *) cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					 *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ
					cp++;
					 */

					if (iEraseReq == 1) delete pItem;

					// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
							DeleteClient(sOwnerH, TRUE, TRUE);
							break;
					}
				} else {
					// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
					// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
							  m_pClientList[iClientH]->m_sY,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù.
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
					*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
							DeleteClient(sOwnerH, TRUE, TRUE);
							break;
					}

					// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý
					std::memset(cCharName, 0, sizeof(cCharName));
				}
			} else {
				// NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC°¡ Ã¢°í ÁÖÀÎÀÌ¾ú´Ù¸é ¹°°ÇÀ» º¸°üÇÏ°Ú´Ù´Â ÀÇ¹ÌÀÌ´Ù.
					if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) {
						// ¾ÆÀÌÅÛÀ» º¸°üÇÏ´Âµ¥ ½ÇÆÐÇÏ¿© ¹Ù´Ú¿¡ ¶³¾îÁ³´Ù.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

						// ½ÇÆÐÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³±º´Ù.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
								  m_pClientList[iClientH]->m_sY,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù.
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
					}
				} else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					// ±æµå »ç¹«Àå¿¡°Ô ±æµå Å»Åð ½ÅÃ»¼­¸¦ ÁÖ¾ú´Ù¸é ±æµå¸¦ Å»ÅðÇÑ´Ù.
					if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							// Å»Åð ½ÅÃ»ÀÚ¿¡°Ô Å»Åð ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);

							// ±æµå Å»Åð.
							std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù.
							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

							// ¾à°£ÀÇ °æÇèÄ¡°¡ ÇÏ¶ôÇÑ´Ù.
							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}

						// ÀÌ ¾ÆÀÌÅÛÀº »èÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					} else {
						// ±æµå Å»Åð ½ÅÃ»¼­°¡ ¾Æ´Ï¶ó¸é ¹Ù´Ú¿¡ ¶³±º´Ù. Å©·ç¼¼ÀÌµå ¸ðµåÀÏ¶§µµ ±æµå °ü·Ã ¿¬»ê ºÒ°¡
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
								  m_pClientList[iClientH]->m_sY,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù.
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

						// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý
						std::memset(cCharName, 0, sizeof(cCharName));

					}
				} else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù.

					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,
							  m_pClientList[iClientH]->m_sY,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù.
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù.
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý
					std::memset(cCharName, 0, sizeof(cCharName));
				}
			}

			// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}

REMOVE_ITEM_PROCEDURE:
		;

		// ³×Æ®¿öÅ© ¿À·ù·Î Ã³¸®µµÁß Å¬¶óÀÌ¾ðÆ®°¡ Á¦°ÅµÇ¾ú´Ù¸é ´õÀÌ»ó ÁøÇàÇÒ ¼ö ¾ø´Ù.
		if (m_pClientList[iClientH] == NULL) return;

		// ¾ÆÀÌÅÛÀ» ÁÖ°Å³ª ¹ö·ÈÀ¸¹Ç·Î Áö¿î´Ù. deleteÇØ¼­´Â ¾ÈµÈ´Ù!
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		// È­»ì ÀÎµ¦½º¸¦ Àç ÇÒ´ç
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2) {
	char cData[1000];
	DWORD * dwp;
	WORD * wp;
	char * cp;
	short * sp;
	int * ip, iRet, i;

	if (m_pClientList[iToH] == NULL) return;

	std::memset(cData, 0, sizeof(cData));

	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = wMsgType;

	cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

	// !!! sV1, sV2, sV3´Â DWORDÇüÀÓÀ» ¸í½ÉÇÏ¶ó.
	switch (wMsgType) {
		case DEF_NOTIFY_HELDENIANCOUNT:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV3;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV4;
			cp += 2;

			cp += 14;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);

			break;

		case DEF_NOTIFY_NOMOREAGRICULTURE:
		case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
		case DEF_NOTIFY_AGRICULTURENOAREA:
		case DEF_NOTIFY_HAPPYHOURSTAR:
		case DEF_NOTIFY_HAPPYHOUREND:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

			// Crafting
		case DEF_NOTIFY_CRAFTING_FAIL: //reversed by Snoopy: 0x0BF1:
			ip = (int *) cp;
			*ip = (int) sV1;
			cp += 4;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

			// New 18/05/2004
		case DEF_NOTIFY_SPAWNEVENT:
			*cp = (char) sV3;
			cp++;

			sp = (short *) cp;
			*cp = sV1;
			cp += 2;

			sp = (short *) cp;
			*cp = sV2;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
			break;

		case DEF_NOTIFY_QUESTCOUNTER:
			ip = (int *) cp;
			*ip = sV1;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
			break;

		case DEF_NOTIFY_REQRANGO: // Morla2.2 - Notify Rango
			ip = (int *) cp;
			*ip = sV1;
			cp += 4;

			ip = (int *) cp;
			*ip = sV2;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
			break;

		case DEF_NOTIFY_APOCGATECLOSE:
		case DEF_NOTIFY_APOCGATEOPEN:
			ip = (int *) cp;
			*ip = sV1;
			cp += 4;

			ip = (int *) cp;
			*ip = sV2;
			cp += 4;

			memcpy(cp, pString, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
			break;

		case DEF_NOTIFY_ABADDONKILLED:
			memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
			break;

		case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
		case DEF_NOTIFY_APOCGATESTARTMSG:
		case DEF_NOTIFY_APOCGATEENDMSG:
		case DEF_NOTIFY_NORECALL:
			//50Cent - Capture The Flag
		case DEF_NOTIFY_CAPTURETHEFLAGSTART:
		case DEF_NOTIFY_ARESDENCAPTUREDELVINEFLAG:
		case DEF_NOTIFY_ELVINECAPTUREDARESDENFLAG:
		case DEF_NOTIFY_ELVINEFLAGBACKTOCH:
		case DEF_NOTIFY_ARESDENFLAGBACKTOCH:
		case DEF_NOTIFY_ELVINEWINSROUND:
		case DEF_NOTIFY_ARESDENWINSROUND:
		case DEF_NOTIFY_ELVINEWINCTF:
		case DEF_NOTIFY_ARESDENWINCTF:
		case DEF_NOTIFY_TIECTF:

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_FORCERECALLTIME:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

			// New 16/05/2004
			//0xB4E2, 0xBEB
		case DEF_NOTIFY_MONSTERCOUNT:
		case DEF_NOTIFY_SLATE_STATUS:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

			//0x0BE5, 0x0BE7, 0x0BE8, 0x0BEA
		case DEF_NOTIFY_0BE8:
		case DEF_NOTIFY_HELDENIANTELEPORT:
		case DEF_NOTIFY_HELDENIANEND:
		case DEF_NOTIFY_RESURRECTPLAYER:
		case DEF_NOTIFY_SLATE_EXP:
		case DEF_NOTIFY_SLATE_MANA:
		case DEF_NOTIFY_SLATE_INVINCIBLE:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_SLATE_CREATEFAIL:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_SLATE_CREATESUCCESS:
			dwp = (DWORD *) cp;
			*dwp = sV1;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

			// New 07/05/2004
			// Party Notify Msg's
		case DEF_NOTIFY_PARTY:

			switch (sV1) {
				case 4:
				case 6:
					wp = (WORD *) cp;
					*wp = (WORD) sV1;
					cp += 2;
					wp = (WORD *) cp;
					*wp = (WORD) sV2;
					cp += 2;
					wp = (WORD *) cp;
					*wp = (WORD) sV3;
					cp += 2;
					memcpy(cp, pString, 10);
					cp += 10;
					iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + 10);
					SendNotifyMsg(NULL, iToH, DEF_NOTIFY_PARTYMEMBERSTATUS, NULL, NULL, NULL, NULL);
					break;

				case 5:
					wp = (WORD *) cp;
					*wp = (WORD) sV1;
					cp += 2;
					wp = (WORD *) cp;
					*wp = (WORD) sV2;
					cp += 2;
					wp = (WORD *) cp;
					*wp = (WORD) sV3;
					cp += 2;
					memcpy(cp, pString, sV3 * 11);
					cp += sV3 * 11;
					iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + sV3 * 11);
					SendNotifyMsg(NULL, iToH, DEF_NOTIFY_PARTYMEMBERSTATUS, NULL, NULL, NULL, NULL);
					break;

				default:
					wp = (WORD *) cp;
					*wp = (WORD) sV1;
					cp += 2;
					wp = (WORD *) cp;
					*wp = (WORD) sV2;
					cp += 2;
					wp = (WORD *) cp;
					*wp = (WORD) sV3;
					cp += 2;
					wp = (WORD *) cp;
					*wp = (WORD) sV4;
					cp += 2;
					iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
					SendNotifyMsg(NULL, iToH, DEF_NOTIFY_PARTYMEMBERSTATUS, NULL, NULL, NULL, NULL);
					break;
			}
			break;

		case DEF_NOTIFY_REQGUILDNAMEANSWER:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
			break;

			// New 06/05/2004
			// Upgrade Notify Msg's
		case DEF_NOTIFY_ITEMUPGRADEFAIL:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
		case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
			sp = (short *) cp;
			*sp = sV1;
			cp += 2;

			dwp = (DWORD *) cp;
			*dwp = sV2;
			cp += 4;

			dwp = (DWORD *) cp;
			*dwp = sV3;
			cp += 4;

			dwp = (DWORD *) cp;
			*dwp = sV4;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 20);
			break;

		case DEF_NOTIFY_UPGRADEHEROCAPE:
		case DEF_NOTIFY_GIZONITEMCANGE:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			*cp = (char) sV2;
			cp++;

			sp = (short *) cp;
			*sp = (short) sV3;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV4;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV5;
			cp += 2;

			*cp = (char) sV6;
			cp++;

			*cp = (char) sV7;
			cp++;

			dwp = (DWORD *) cp;
			*dwp = sV8;
			cp += 4;

			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 41);
			break;

			// 2.06 - by KLKS
		case DEF_NOTIFY_CHANGEPLAYMODE:
			memcpy(cp, pString, 10);
			cp += 10;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
			break;
			//

		case DEF_NOTIFY_TCLOC:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			memcpy(cp, pString, 10);
			cp += 10;

			wp = (WORD *) cp;
			*wp = (WORD) sV4;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV5;
			cp += 2;

			memcpy(cp, pString2, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
			break;

			//New 11/05/2004
		case DEF_NOTIFY_GRANDMAGICRESULT:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV3;
			cp += 2;

			memcpy(cp, pString, 10);
			cp += 10;

			wp = (WORD *) cp;
			*wp = (WORD) sV4;
			cp += 2;

			if (sV9 > 0) {
				memcpy(cp, pString2, (sV9 * 2) + 2);
				cp += (sV9 * 2) + 2;
			} else {
				sp = (short *) cp;
				*sp = 0;
				cp += 2;
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, (sV9 * 2) + 26);
			break;

		case DEF_NOTIFY_MAPSTATUSNEXT:
			memcpy(cp, pString, sV1);
			cp += sV1;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + sV1);
			break;

		case DEF_NOTIFY_MAPSTATUSLAST:
			memcpy(cp, pString, sV1);
			cp += sV1;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + sV1);
			break;

		case DEF_NOTIFY_LOCKEDMAP:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			memcpy(cp, pString, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
			break;

		case DEF_NOTIFY_BUILDITEMSUCCESS:
		case DEF_NOTIFY_BUILDITEMFAIL:

			if (sV1 >= 0) {
				sp = (short *) cp;
				*sp = (short) sV1;
				cp += 2;
			} else {
				sp = (short *) cp;
				*sp = (short) sV1 + 10000;
				cp += 2;
			}

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_HELP:
		case DEF_NOTIFY_QUESTREWARD:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			ip = (int *) cp;
			*ip = (int) sV3;
			cp += 4;

			memcpy(cp, pString, 20);
			cp += 20;

			ip = (int *) cp;
			*ip = (int) sV4;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
			break;

		case DEF_NOTIFY_CANNOTCONSTRUCT:
		case DEF_NOTIFY_METEORSTRIKECOMING:
		case DEF_NOTIFY_METEORSTRIKEHIT:
		case DEF_NOTIFY_HELPFAILED:
		case DEF_NOTIFY_SPECIALABILITYENABLED:
		case DEF_NOTIFY_FORCEDISCONN:
		case DEF_NOTIFY_OBSERVERMODE:
		case DEF_NOTIFY_QUESTCOMPLETED:
		case DEF_NOTIFY_QUESTABORTED:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_QUESTCONTENTS:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV3;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV4;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV5;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV6;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV7;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV8;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV9;
			cp += 2;

			if (pString2 != NULL) memcpy(cp, pString2, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
			break;

		case DEF_NOTIFY_ENERGYSPHERECREATED:
		case DEF_NOTIFY_ITEMCOLORCHANGE:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
		case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
		case DEF_NOTIFY_CANCELEXCHANGEITEM:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_SETEXCHANGEITEM:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV3;
			cp += 2;

			ip = (int *) cp;
			*ip = (int) sV4;
			cp += 4;

			*cp = (char) sV5;
			cp++;

			sp = (short *) cp;
			*sp = (short) sV6;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV7;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV8;
			cp += 2;

			memcpy(cp, pString, 20);
			cp += 20;

			memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
			cp += 10;

			// v1.42
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV9;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
			break;

		case DEF_NOTIFY_OPENEXCHANGEWINDOW:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV3;
			cp += 2;

			ip = (int *) cp;
			*ip = (int) sV4;
			cp += 4;

			*cp = (char) sV5;
			cp++;

			sp = (short *) cp;
			*sp = (short) sV6;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV7;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV8;
			cp += 2;

			memcpy(cp, pString, 20);
			cp += 20;

			memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
			cp += 10;

			// v1.42
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV9;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
			break;

		case DEF_NOTIFY_NOTFLAGSPOT:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_ITEMPOSLIST:
			for (i = 0; i < DEF_MAXITEMS; i++) {
				sp = (short *) cp;
				*sp = (short) m_pClientList[iToH]->m_ItemPosList[i].x;
				cp += 2;
				sp = (short *) cp;
				*sp = (short) m_pClientList[iToH]->m_ItemPosList[i].y;
				cp += 2;
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS * 4);
			break;

		case DEF_NOTIFY_ENEMYKILLS:
			ip = (int *) cp;
			*ip = (int) sV1;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_CRUSADE:
			ip = (int *) cp;
			*ip = (int) sV1;
			cp += 4;

			ip = (int *) cp;
			*ip = (int) sV2;
			cp += 4;

			ip = (int *) cp;
			*ip = (int) sV3;
			cp += 4;

			ip = (int *) cp;
			*ip = (int) sV4;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
			break;

		case DEF_NOTIFY_CONSTRUCTIONPOINT:
		case DEF_NOTIFY_SPECIALABILITYSTATUS:
		case DEF_NOTIFY_DAMAGEMOVE:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV3;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
			break;

		case DEF_NOTIFY_DOWNSKILLINDEXSET:
		case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_ADMINIFO:
			switch (sV1) {
				case 1:
					// NPCÀÇ Á¤º¸¸¦ ¾ò¾î¿Â´Ù.
					ip = (int *) cp;
					*ip = m_pNpcList[sV2]->m_iHP;
					cp += 4;

					ip = (int *) cp;
					*ip = m_pNpcList[sV2]->m_iDefenseRatio;
					cp += 4;

					ip = (int *) cp;
					*ip = m_pNpcList[sV2]->m_bIsSummoned;
					cp += 4;

					ip = (int *) cp;
					*ip = m_pNpcList[sV2]->m_cActionLimit;
					cp += 4;

					ip = (int *) cp;
					*ip = m_pNpcList[sV2]->m_iHitDice;
					cp += 4;

					dwp = (DWORD *) cp; // v1.4
					*dwp = m_pNpcList[sV2]->m_dwDeadTime;
					cp += 4;

					dwp = (DWORD *) cp;
					*dwp = m_pNpcList[sV2]->m_dwRegenTime;
					cp += 4;

					ip = (int *) cp;
					*ip = (int) m_pNpcList[sV2]->m_bIsKilled;
					cp += 4;

					iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
					break;
			}
			break;

		case DEF_NOTIFY_HELDENIANSTART:
		case DEF_NOTIFY_NPCTALK:
			sp = (short *) cp;
			*sp = (short) sV1;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV2;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV3;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV4;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV5;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV6;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV7;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV8;
			cp += 2;

			sp = (short *) cp;
			*sp = (short) sV9;
			cp += 2;

			if (pString != NULL) memcpy(cp, pString, 20);
			cp += 20;

			if (pString2 != NULL) memcpy(cp, pString2, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
			break;

		case DEF_NOTIFY_CRAFTING_SUCCESS: //reversed by Snoopy: 0x0BF0
		case DEF_NOTIFY_PORTIONSUCCESS:
		case DEF_NOTIFY_LOWPORTIONSKILL:
		case DEF_NOTIFY_PORTIONFAIL:
		case DEF_NOTIFY_NOMATCHINGPORTION:
			// ÀÏÄ¡ÇÏ´Â Æ÷¼Ç Á¶ÇÕÀÌ ¾ø´Ù.
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_SUPERATTACKLEFT:
			sp = (short *) cp;
			*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_SAFEATTACKMODE:
			*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
			break;

		case DEF_NOTIFY_QUERY_JOINPARTY:
		case DEF_NOTIFY_IPACCOUNTINFO:
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_REWARDGOLD:
			dwp = (DWORD *) cp;
			*dwp = m_pClientList[iToH]->m_iRewardGold;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_SERVERSHUTDOWN:
			*cp = (char) sV1;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
			break;

		case DEF_NOTIFY_GLOBALATTACKMODE:
		case DEF_NOTIFY_WHETHERCHANGE:
			*cp = (char) sV1;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
			break;

		case DEF_NOTIFY_FISHCANCELED:
		case DEF_NOTIFY_FISHSUCCESS:
		case DEF_NOTIFY_FISHFAIL:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_DEBUGMSG:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_FISHCHANCE:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_ENERGYSPHEREGOALIN:
		case DEF_NOTIFY_EVENTFISHMODE:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV3;
			cp += 2;

			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
			break;

		case DEF_NOTIFY_NOTICEMSG:
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);

			*cp = NULL;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
			break;

		case DEF_NOTIFY_CANNOTRATING:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_RATINGPLAYER:
			*cp = (char) sV1;
			cp++;

			memcpy(cp, pString, 10);
			cp += 10;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iRating;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
			break;

		case DEF_NOTIFY_ADMINUSERLEVELLOW:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_PLAYERSHUTUP:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			memcpy(cp, pString, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
			break;

		case DEF_NOTIFY_TIMECHANGE:
			*cp = (char) sV1;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
			break;

		case DEF_NOTIFY_TOBERECALLED:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_HUNGER:
			*cp = (char) sV1;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
			break;

		case DEF_NOTIFY_PLAYERPROFILE:
			if (strlen(pString) > 100) {
				memcpy(cp, pString, 100);
				cp += 100;
			} else {
				memcpy(cp, pString, strlen(pString));
				cp += strlen(pString);
			}
			*cp = NULL;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
			break;

			// New 10/05/2004 Changed
		case DEF_NOTIFY_WHISPERMODEON:
		case DEF_NOTIFY_WHISPERMODEOFF:
		case DEF_NOTIFY_PLAYERNOTONGAME:
			memcpy(cp, pString, 10);
			cp += 10;

			memcpy(cp, "          ", 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
			break;

			// New 15/05/2004 Changed
		case DEF_NOTIFY_PLAYERONGAME:
			memcpy(cp, pString, 10);
			cp += 10;

			if (pString[0] != 0) {
				memcpy(cp, pString2, 14);
				cp += 14;
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
			break;

			// New 06/05/2004
		case DEF_NOTIFY_ITEMSOLD:
		case DEF_NOTIFY_ITEMREPAIRED:
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV1;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV2;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
			break;

			// New 06/05/2004
		case DEF_NOTIFY_REPAIRITEMPRICE:
		case DEF_NOTIFY_SELLITEMPRICE:
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV1;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV2;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV3;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) sV4;
			cp += 4;

			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
			break;

		case DEF_NOTIFY_CANNOTREPAIRITEM:
		case DEF_NOTIFY_CANNOTSELLITEM:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

			break;

		case DEF_NOTIFY_SHOWMAP:
			wp = (WORD *) cp; // º¸¿©ÁÖ´Â Á¾·ù
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp; // ¸Ê ¹øÈ£ (0 aresden, 1 elvine, 3 middleland...)
			*wp = (WORD) sV2;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_SKILLUSINGEND:
			wp = (WORD *) cp; // ±â¼ú »ç¿ë °á°ú
			*wp = (WORD) sV1;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_TOTALUSERS:
			wp = (WORD *) cp;
			*wp = (WORD) m_iTotalGameServerClients; //_iGetTotalClients();
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
			break;

		case DEF_NOTIFY_MAGICEFFECTOFF:
		case DEF_NOTIFY_MAGICEFFECTON:
			wp = (WORD *) cp; // ¸¶¹ý È¿°ú Á¾·ù
			*wp = (WORD) sV1;
			cp += 2;

			dwp = (DWORD *) cp; // ¸¶¹ý È¿°ú È¿·Â
			*dwp = (DWORD) sV2;
			cp += 4;

			dwp = (DWORD *) cp; // ¸¶¹ý È¿°ú È¿·Â
			*dwp = (DWORD) sV3;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
			break;

		case DEF_NOTIFY_CANNOTITEMTOBANK:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_SERVERCHANGE:
			memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
			cp += 10;
			if (m_iGameServerMode == 1)
				if (memcmp(m_cLogServerAddr, m_cGameServerAddr, 15) == 0)
					memcpy(cp, m_cGameServerAddrExternal, 15);
				else
					memcpy(cp, m_cLogServerAddr, 15);
			else
				memcpy(cp, m_cLogServerAddr, 15);
			cp += 15;
			ip = (int *) cp;
			*ip = m_iLogServerPort;
			cp += 4;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 + 19);
			break;

		case DEF_NOTIFY_SKILL:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_SETITEMCOUNT:
			wp = (WORD *) cp; // ¾ÆÀÌÅÛ ÀÎµ¦½º ¹øÈ£
			*wp = (WORD) sV1;
			cp += 2;

			dwp = (DWORD *) cp; // ¾ÆÀÌÅÛÀÇ ÇöÀç ¼ö·®
			*dwp = (DWORD) sV2;
			cp += 4;

			*cp = (char) sV3;
			cp++;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
			break;

		case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			ip = (int *) cp;
			*ip = (int) sV2;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
			break;

		case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			ip = (int *) cp;
			*ip = (int) sV2;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
			break;

		case DEF_NOTIFY_CANNOTGIVEITEM:
		case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			ip = (int *) cp;
			*ip = (int) sV2;
			cp += 4;

			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
			break;

		case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;

			ip = (int *) cp;
			*ip = (int) sV2;
			cp += 4;

			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
			break;

		case DEF_NOTIFY_ENEMYKILLREWARD:
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iExp;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iEnemyKillCount;
			cp += 4;
			memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
			cp += 10;
			memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
			cp += 20;
			sp = (short *) cp;
			*sp = (short) m_pClientList[sV1]->m_iGuildRank;
			cp += 2;
			sp = (short *) cp;
			*sp = (short) m_pClientList[iToH]->m_iWarContribution;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
			break;

		case DEF_NOTIFY_PKCAPTURED:
			// PK¸¦ Àâ¾Ò´Ù.
			// PKÀÇ PKcount
			wp = (WORD *) cp;
			*wp = (WORD) sV1;
			cp += 2;
			wp = (WORD *) cp;
			*wp = (WORD) sV2;
			cp += 2;
			memcpy(cp, pString, 10);
			cp += 10;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iRewardGold;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = m_pClientList[iToH]->m_iExp;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
			break;

		case DEF_NOTIFY_PKPENALTY:
			// PK Æä³ÎÆ¼¸¦ ¸Ô¾ú´Ù.
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iExp;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iStr;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iVit;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iDex;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iInt;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iMag;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iCharisma;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iPKCount;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
			break;

		case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
		case DEF_NOTIFY_LIMITEDLEVEL:
			// Ã¼ÇèÆÇ »ç¿ëÀÚ´Â ´õÀÌ»ó ·¹º§À» ¿Ã¸± ¼ö ¾øÀ½À» ¾Ë¸°´Ù.
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iExp;
			cp += 4;
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_ITEMRELEASED:
		case DEF_NOTIFY_ITEMLIFESPANEND:
			// ÀüÅõÁß ¹«±â, È¤Àº ¹æ¾î±¸ ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´ÙÇØ ¸Á°¡Á³À½À» ¾Ë¸°´Ù.
			sp = (short *) cp;
			*sp = (short) sV1; // ÀåÂø À§Ä¡
			cp += 2;
			sp = (short *) cp;
			*sp = (short) sV2; // ¾ÆÀÌÅÛ ¹øÈ£
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_KILLED:
			// »ç¸Á Åëº¸ : Á×ÀÎ Ä³¸¯ÅÍ ÀÌ¸§µµ ÇÔ²² º¸³»ÁØ´Ù.
			memcpy(cp, pString, 20);
			cp += 20;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
			break;

		case DEF_NOTIFY_EXP:
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iExp;
			cp += 4;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iRating;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
			break;

		case DEF_NOTIFY_HP: // Fixed Party Info by xXx// 50cent
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iHP;
			cp += 4;
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iMP;
			cp += 4;

			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
				iH = m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i];
				if (m_pClientList[iH] != NULL) {
					SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTYMEMBERSTATUS, NULL, NULL, NULL, NULL);
				}
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
			break;

		case DEF_NOTIFY_PARTYMEMBERSTATUS:// 50 cent
			for (i = 0; i < m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iTotalMembers; i++) {
				ip = (int *) cp;
				*ip = (DWORD) m_pClientList[m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i]]->m_iHP;
				cp += 4;

				ip = (int *) cp;
				*ip = (DWORD) iGetMaxHP(m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i]);
				cp += 4;

				ip = (int *) cp;
				*ip = (DWORD) m_pClientList[m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i]]->m_iMP;
				cp += 4;

				ip = (int *) cp;
				*ip = (DWORD) iGetMaxMP(m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i]);
				cp += 4;
				//screemin fix/update :D -  Poison mode
				ip = (int *) cp;
				*ip = (DWORD) m_pClientList[m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i]]->m_bIsPoisoned;
				cp += 2;

			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + (m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iTotalMembers * 18));
			break;

		case DEF_NOTIFY_MP: // Fixed Party Info by xXx
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iMP;
			cp += 4;

			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
				iH = m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i];
				if (m_pClientList[iH] != NULL) {
					SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTYMEMBERSTATUS, NULL, NULL, NULL, NULL);
				}
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;



		case DEF_NOTIFY_SP: // Fixed Party Info by xXx
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iSP;
			cp += 4;

			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++) {
				iH = m_stPartyInfo[m_pClientList[iToH]->m_iPartyID].iIndex[i];
				if (m_pClientList[iH] != NULL) {
					SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTYMEMBERSTATUS, NULL, NULL, NULL, NULL);
				}
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

		case DEF_NOTIFY_CHARISMA:
			dwp = (DWORD *) cp;
			*dwp = (DWORD) m_pClientList[iToH]->m_iCharisma;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

			//MOG Fixes
		case DEF_NOTIFY_STATECHANGE_FAILED: // 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ½ÇÆÐ..korean buttplugs
		case DEF_NOTIFY_SETTING_FAILED:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

		case DEF_NOTIFY_STATECHANGE_SUCCESS: // 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¼º°ø.. wtf korean junk
		{
			int i;

			for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cMagicMastery[i];
				cp++;
			}

			for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cSkillMastery[i];
				cp++;
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		}
			break;

		case DEF_NOTIFY_SETTING_SUCCESS:
		case DEF_NOTIFY_LEVELUP:
			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iLevel;
			cp += 4;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iStr;
			cp += 4;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iVit;
			cp += 4;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iDex;
			cp += 4;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iInt;
			cp += 4;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iMag;
			cp += 4;

			ip = (int *) cp;
			*ip = m_pClientList[iToH]->m_iCharisma;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
			break;

			/*
		case DEF_NOTIFY_LEVELUP:
			ip  = (int *)cp;
			 *ip = m_pClientList[iToH]->m_iLevel;
			cp += 4;

			ip   = (int *)cp;
			 *ip  = m_pClientList[iToH]->m_iStr;
			cp  += 4;


			ip   = (int *)cp;
			 *ip  = m_pClientList[iToH]->m_iDex;
			cp  += 4;

			ip   = (int *)cp;
			 *ip  = m_pClientList[iToH]->m_iInt;
			cp  += 4;

			ip   = (int *)cp;
			 *ip  = m_pClientList[iToH]->m_iMag;
			cp  += 4;

			ip   = (int *)cp;
			 *ip  = m_pClientList[iToH]->m_iCharisma;
			cp  += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
			break;
			 */
		case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
		case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
		case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:

			memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
			break;

		case DEF_COMMONTYPE_JOINGUILDAPPROVE:
			if (m_pClientList[iFromH] != NULL)
				memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
			else memcpy(cp, "?", 1);
			cp += 20;

			sp = (short *) cp;
			*sp = DEF_GUILDSTARTRANK;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
			break;

		case DEF_COMMONTYPE_JOINGUILDREJECT:
		case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		case DEF_COMMONTYPE_DISMISSGUILDREJECT:
			if (m_pClientList[iFromH] != NULL)
				memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
			else memcpy(cp, "?", 1);
			cp += 20;

			sp = (short *) cp;
			*sp = DEF_GUILDSTARTRANK;
			cp += 2;

			memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
			break;

		case DEF_NOTIFY_GUILDDISBANDED:

			memcpy(cp, pString, 20);
			cp += 20;

			memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
			break;

			// v1.4311-3 Ãß°¡ Å¬¶óÀÌ¾ðÆ®¿¡°Ô »çÅõÀå ¿¹¾àÀÌ Ãë¼ÒµÇ¾ú´Ù°í ¾Ë¸² ..
		case DEF_NOTIFY_FIGHTZONERESERVE:
			ip = (int *) cp;
			*ip = (int) sV1;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
			break;

			// v1.4311-3 Ãß°¡ ±æµå ¸¶½ºÅÍ°¡ ¾Æ´Ñ°æ¿ì .
		case DEF_NOTIFY_NOGUILDMASTERLEVEL:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;

			// v1.4311-3 Ãß°¡ ÀÚ½ÅÀÇ ±æµå¿øÀÌ  ¾Æ´Ñ°æ¿ì
		case DEF_NOTIFY_CANNOTBANGUILDMAN:
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
			break;
	}

	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			// Ã³¸® µµÁß ¿À·ù°¡ ¹ß»ýÇÏ´Â °ÍÀ» ¸·±â À§ÇØ Áö¿ìÁö ¾Ê´Â´Ù. Time OutÀ¸·Î »èÁ¦µÉ °ÍÀÓ.
			//DeleteClient(iToH, TRUE, TRUE);
			return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName) {
	register int i;
	BOOL bIsExist = FALSE;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
			// v1.4 ¼Ò¼Ó ¸¶À»ÀÌ ´Þ¶óµµ ¹«½ÃµÈ´Ù.
			if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;

			// ±æµåÀÇ ÀÌ¸§À» º¹»çÇÏ°í ¼öÄ¡¸¦ ÃÊ±âÈ­ÇØ ÁØ´Ù.
			std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);

			// ±æµå GUIDº¹»çÇÑ´Ù.
			m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

			// ±æµåÀÇ »ý¼ºÀ§Ä¡¸¦ ÃÊ±âÈ­ÇÑ´Ù.
			std::memset(m_pClientList[i]->m_cLocation, 0, sizeof(m_pClientList[i]->m_cLocation));
			strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

			m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRankÀÇ ½ÃÀÛÀº DEF_GUILDSTARTRANK

			// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

			// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

			// ´Ù¸¥ ±æµå¿øµé¿¡°Ô »õ ±æµå¿øÀÌ ÀÖÀ½À» ¾Ë¸°´Ù.
			SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

			// ±æµåÁ¤º¸È­ÀÏ¿¡ »õ ±æµå¿øÀÇ ÀÌ¸§À» ±â·ÏÇÑ´Ù.
			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
			return;
		}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName) {
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
			return;
		}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName) {
	register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
			//_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);

			std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;

			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			return;
		}

}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName) {
	register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ Å»Åð ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô Å»Åð°¡ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
			return;
		}

	// Å»Åð¸¦ ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ
}

DWORD CGame::dwGetItemCount(int iClientH, char * pName) {
	register int i;
	char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {

			return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount) {
	register int i;
	char cTmpName[21];
	WORD wWeight;

	if (m_pClientList[iClientH] == NULL) return -1;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {

			wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1); // m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

			// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
			if (dwCount == 0) {
				ItemDepleteHandler(iClientH, i, FALSE, TRUE);
			} else {
				// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù.
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char) TRUE, NULL);
			}

			return wWeight;
		}

	return -1;
}

int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount) {
	WORD wWeight;

	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;

	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1); //m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
	} else {
		// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù.
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char) TRUE, NULL);
	}

	return wWeight;
}

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage) {
	char * cp, cAttackerName[21], cData[120], cEKMsg[1000];
	short sAttackerWeapon;
	int * ip, i, iExH;
	BOOL bIsSAattacked = FALSE;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// �������� ��� �ð��� �Է��Ѵ�.
	// 2002-7-4 �������� ������ �ø� �� �ֵ���
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) {
		m_pClientList[iClientH]->m_dwFightzoneDeadTime = timeGetTime();
		wsprintf(G_cTxt, "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogList(G_cTxt);
	}

	m_pClientList[iClientH]->m_bIsKilled = TRUE;
	// HP�� 0�̴�.
	m_pClientList[iClientH]->m_iHP = 0;

	// ���� ��ȯ ����� ��ȯ�� ����Ѵ�.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// ���� �� NPC�� ��ݴ������ ����ִ� ��ü���� �����Ѵ�.
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	std::memset(cAttackerName, 0, sizeof(cAttackerName));
	switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER_INDIRECT:
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[iAttackerH] != NULL)
				memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[iAttackerH] != NULL)
#ifdef DEF_LOCALNPCNAME     // v2.14 NPC �̸� �߹�ȭ�� ���� ����
				wsprintf(cAttackerName, "NPCNPCNPC@%d", m_pNpcList[iAttackerH]->m_sType);
#else
				memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
#endif
			break;
		default:
			break;
	}

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
	// �ٸ� Ŭ���̾�Ʈ���� �״� ���� ���.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
	} else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) &&
			  (m_bIsHeldenianMode == TRUE) &&
			  (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) {
		if (m_pClientList[iClientH]->m_cSide == 1) {
			m_iHeldenianAresdenDead++;
		} else if (m_pClientList[iClientH]->m_cSide == 2) {
			m_iHeldenianElvineDead++;
		}
		UpdateHeldenianStatus();
	}


	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		// Ư�� �ɷ��� �ִ� ����� ����� ���ߴ�.
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
				bIsSAattacked = TRUE;
				break;
		}

		if (iAttackerH == iClientH) return; // �����̴�.
		// �÷��̾ �÷��̾ �׿��ٸ� PK���� ������ �¸������� �Ǻ��Ͽ� ����ġ�� �ø���.
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
			// ����ڰ� �������̴�.
			if (m_pClientList[iClientH]->m_iPKCount == 0) {


				// ������ �����ڿ���. ����ڴ� PK �������� �޴´�.
				ApplyPKpenalty(iAttackerH, iClientH);
			} else {

				// ���˸� ������ �����ڿ���. ����ڴ� PK�� �����Ϳ� ���� ������ �޴´�.
				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		} else {
			// ����ڰ� �����ڰ� �ƴ϶� �� ���� �Ҽ��̴�.
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				// ����ڴ� �ù��̴�.
				// ����ڰ� ������, ���� ���� �ù�, ���� ���� ���� -> PK�� ��. �ٸ� ���� �ù�, ���� -> ������ ���
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// ����ڰ� �������̴�.
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ������ �ù��� �����ڰ� �׿���. �����ڴ� PK�� �ȴ�.
						ApplyPKpenalty(iAttackerH, iClientH);
					} else {
						// �����ڴ� PK�� ��Ƶ� ������ ���� ���Ѵ�.

					}
				} else {
					// ����ڰ� �ù�, Ȥ�� ���� -> ������ ������ PK, �ٸ� �����̶�� ������ ���
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// ���� ���� �ù��� �������� �ù� Ȥ�� ������ ����� ���̴�.
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// ����ڰ� ������ ����. PK�̴�.
							ApplyPKpenalty(iAttackerH, iClientH);
						} else {
							// �����ڸ� ��Ҵ�.
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					} else {
						// ����ڰ� �ٸ� ���� �Ҽ�. ������ �������
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			} else {
				// ����ڴ� �����̴�.
				// ����� �ڰ� ������, �ù�, ������°� �ƴ� ����-> PK / ���������� ���� -> ������ ��������
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// ����ڰ� �������̴�.
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ������ ������ �����ڰ� �׿���. �����ڴ� PK�� �ȴ�.
						ApplyPKpenalty(iAttackerH, iClientH);
					} else {
						// �����ڴ� PK�� ��Ƶ� ������ ���� ���Ѵ�.

					}
				} else {
					// ����ڴ� �ù� Ȥ�� ���� -> ������ ������ PK, �ٸ� �����̶�� ������ ���
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// ���� ���� ������ �������� �ù� Ȥ�� ������ ����� ���̴�.
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// ����ڰ� ������ ����. PK�̴�.
							ApplyPKpenalty(iAttackerH, iClientH);
						} else {
							// �����ڸ� ��Ҵ�.
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					} else {
						// ����ڰ� �ٸ� ���� �Ҽ�. ������ �������
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		// ������ �÷��̾��� ��޿� �´� ���Ƽ�� ���Ѵ�.
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
				//�����ڿ��� ��ݹ޾� �׾��.
				//PK�������Ƿ� ����ġ�� ���� �ʴ´�.
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			} else {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) {
					//���� ���� �ù� Ȥ�� ����� �׾��.
					//PK�������Ƿ� �������� ���� �ʴ´�.
					//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				} else {
					// �ٸ� ���� �ù� Ȥ�� ����� �׾��. ������ �׾����Ƿ� ����ġ�� �������� �������.
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		} else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		} else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		} else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
	} else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC, iClientH, NULL, cAttackerName);

		// �÷��̾ ������ �׾��. ������ �÷��̾��� ��޿� �´� ���Ƽ�� ���Ѵ�.
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		} else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		} else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		} else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		// ���� ����� NPC�� ����� ����Ʈ��� ���ְ�� �Ǽ� ����Ʈ �ΰ�
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) {

			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				// ����� ������ Ȥ�� ����Ʈ�� �� �÷��̾ �׿���. �ٷ� �뺸�Ѵ�.
				// ���� ������ ���ְ��� �ִٸ� ��ٷ� �뺸. ������ �ٸ� ������ �˷���.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
							  (m_pClientList[i]->m_iCrusadeDuty == 3)) {
						m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						//testcode
						wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
						PutLogList(G_cTxt);
						// ���ְ�� �ٷ� �뺸.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
						return;
					}
			}
		}
	} else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER, iClientH, NULL, NULL);
		// �÷��̾ �׾����� ����ڰ� �������̴�. �ƹ��� ������ ���.
		// m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		// if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		// SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	//----------------------------EK Announcer-------------------------
	//---- Function: CGame::ClientKilledHandler                    ----
	//---- Description: Announces a message to alert all connected ----
	//---- clients an EK has taken place                           ----
	//---- Version: HBX 2.03 Build                                 ----
	//---- Date: November 07 2005                                  ----
	//---- By: Daxation                                            ----
	//---- Notes: Add char cEKMsg[1000]                            ----
	//-----------------------------------------------------------------
	std::memset(cEKMsg, 0, sizeof(cEKMsg));
	//Multiple EK Messages
	//Note - Remove section '01' and replace with alternative code for a single message
	//Alternative code: wsprintf(cEKMsg, "%s killed %s", cAttackerName, m_pClientList[iClientH]->m_cCharName);
	// 01
	switch (iDice(1, 10))
		//You can add extra messages by creating a new case.
		//Remember to increase iDice
	{
		case 1: // To reverse the order the names appear in the message reverse the last 2 parameters
			wsprintf(cEKMsg, "%s whooped %s's ass!", cAttackerName, m_pClientList[iClientH]->m_cCharName);
			break;
		case 2:
			wsprintf(cEKMsg, "%s smashed %s's face into the ground!", cAttackerName, m_pClientList[iClientH]->m_cCharName);
			break;
		case 3:
			wsprintf(cEKMsg, "%s was sliced to pieces by %s", m_pClientList[iClientH]->m_cCharName, cAttackerName);
			break;
		case 4:
			wsprintf(cEKMsg, "%s says LAG LAG!! but gets PWNED by %s", m_pClientList[iClientH]->m_cCharName, cAttackerName);
			break;
		case 5:
			wsprintf(cEKMsg, "%s sent %s off too pie heaven!", cAttackerName, m_pClientList[iClientH]->m_cCharName);
			break;
		case 6:
			wsprintf(cEKMsg, "%s got beat by %s's ugly stick!", cAttackerName, m_pClientList[iClientH]->m_cCharName);
			break;
		case 7:
			wsprintf(cEKMsg, "%s OwneD! %s", cAttackerName, m_pClientList[iClientH]->m_cCharName);
			break;
		case 8:
			wsprintf(cEKMsg, "%s Sended %s To Revival Zone! Too Bad ;(", cAttackerName, m_pClientList[iClientH]->m_cCharName);
			break;
		case 9:
			wsprintf(cEKMsg, "%s says: I CAN OWN YOU! But gets OWNED by %s", m_pClientList[iClientH]->m_cCharName, cAttackerName);
			break;
		case 10:
			wsprintf(cEKMsg, "%s KilleD %s", cAttackerName, m_pClientList[iClientH]->m_cCharName);
			break;
	}
	// 01
	for (i = 1; i < DEF_MAXCLIENTS; i++) // Check all clients
	{
		if ((m_pClientList[i] != NULL)) // Check if client is avtice
		{
			SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cEKMsg); // Send message to client
			// Log EK
			wsprintf(G_cTxt, "%s killed %s", cAttackerName, m_pClientList[iClientH]->m_cCharName); // Log message
			PutLogFileList(G_cTxt); // Enter into logs
		}
	}
	//-----------------------------------------------------------------
	//----                   End EK Announcer Code                 ----
	//-----------------------------------------------------------------
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice) {
	char cEquipPos, cHeroArmorType;
	short sTemp;
	int iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;

	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;

	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = 0;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
			}
		}
	}

	// ¾ÆÀÌÅÛÀÇ ÇØÁ¦À§Ä¡¿¡ ¸Â°Ô Apprº¯¼ö¸¦ Á¶Á¤ÇÑ´Ù.
	switch (cEquipPos) {
		case DEF_EQUIPPOS_RHAND:
			// ¿À¸¥¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹«±â·ùÀÌ´Ù.
			sTemp = m_pClientList[iClientH]->m_sAppr2;
			sTemp = sTemp & 0xF00F; // ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr2 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;

			// V1.3 ¹«±â¼Óµµ Àç°è»ê <- ¸Ç¼ÕÀÌ´Ï±ñ 0
			iTemp = m_pClientList[iClientH]->m_iStatus;
			iTemp = iTemp & 0xFFFFFFF0;
			m_pClientList[iClientH]->m_iStatus = iTemp;
			break;

		case DEF_EQUIPPOS_LHAND:
			// ¿Þ¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹æÆÐ·ùÀÌ´Ù.
			sTemp = m_pClientList[iClientH]->m_sAppr2;
			sTemp = sTemp & 0xFFF0; // ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr2 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xF0FFFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_TWOHAND:
			// ¾ç¼Õ¿¡ ÀåÂøÇÑ´ÙÁö¸¸ »ç½Ç ¿À¸¥¼Õ¿¡¸¸ µé°í ÀÖ´Ù. ¿Þ¼ÕÀº ºñ¾îÀÖ´Â »óÅÂ.
			sTemp = m_pClientList[iClientH]->m_sAppr2;
			sTemp = sTemp & 0xF00F; // ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr2 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_BODY:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0x0FFF; // °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			// °Ñ¿Ê È®Àå Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF7F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFF0FFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_BACK:
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xF0FF; // ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr4 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFF0FFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_ARMS:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0xFFF0; // °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFF0FFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_PANTS:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0xF0FF; // °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFF0FF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_LEGGINGS:
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0x0FFF; // °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr4 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFFF0F; // »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_HEAD:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0xFF0F; // Åõ±¸ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFFFFFF0; // »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;

		case DEF_EQUIPPOS_RELEASEALL:
			sTemp = m_pClientList[iClientH]->m_sAppr3;
			sTemp = sTemp & 0x0FFF; // ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ
			iTemp = iTemp & 0xFFF0FFFF; // ¸ÁÅä »ö ºñÆ®¸¦ Å¬¸®¾î.
			m_pClientList[iClientH]->m_iApprColor = iTemp;
			break;
	}

	//v1.432 Æ¯¼ö ´É·ÂÀÌ ºÎ¿©µÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇÃ·¡±× ¼³Á¤
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// °ø°Ý Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// ¹æ¾î±¸ Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;

	// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» ¾Ë¸°´Ù.
	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// ÀÌ ¾ÆÀÌÅÛÀ» ÇØÁ¦ÇÏ´Â °Í¿¡ µû¸£´Â Æ¯¼ºÄ¡ÀÇ º¯È­¸¦ °è»êÇÑ´Ù.
	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}

BOOL CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize) {
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int iNpcConfigListIndex = 0;
	class CStrTok * pStrTok;

	pContents = new char[dwMsgSize + 1];
	ZeroMemory(pContents, dwMsgSize + 1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
						case 1:
							// NPC
							if (strlen(token) > 20) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							std::memset(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, 0, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
							memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
							cReadModeB = 2;
							break;
						case 2:
							// m_sType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
							cReadModeB = 3;
							break;
						case 3:
							// m_iHitDice
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
							cReadModeB = 4;
							break;
						case 4:
							// m_iDefenseRatio
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
							cReadModeB = 5;
							break;
						case 5:
							// m_iHitRatio
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
							cReadModeB = 6;
							break;
						case 6:
							// m_iMinBravery
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
							cReadModeB = 7;
							break;
						case 7:
							// m_iExpDiceMin
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMin = atoi(token);
							cReadModeB = 8;
							break;

						case 8:
							// m_iExpDiceMax
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMax = atoi(token);
							cReadModeB = 9;
							break;

						case 9:
							// m_iGoldDiceMin
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMin = atoi(token);
							cReadModeB = 10;
							break;

						case 10:
							// m_iGoldDiceMax
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMax = atoi(token);
							cReadModeB = 11;
							break;

						case 11:
							// m_cAttackDiceThrow
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
							cReadModeB = 12;
							break;

						case 12:
							// m_cAttackDiceRange
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
							cReadModeB = 13;
							break;

						case 13:
							// m_cSize
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
							cReadModeB = 14;
							break;

						case 14:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
							cReadModeB = 15;
							break;

						case 15:
							// ActionLimit
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
							cReadModeB = 16;
							break;

						case 16:
							// Action Time
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
							cReadModeB = 17;
							break;

						case 17:
							// ResistMagic
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
							cReadModeB = 18;
							break;

						case 18:
							// cMagicLevel
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
							cReadModeB = 19;
							break;

						case 19:
							// cGenDayWeekLimit  // Æ¯Á¤ ¿äÀÏ¿¡¸¸ »ý¼ºµÇ´Â ¸ó½ºÅÍ¿©ºÎ
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
							cReadModeB = 20;
							break;

						case 20:
							// cChatMsgPresence
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);

							if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {
								// ¿¬°áµÈ Ã¤ÆÃ ¸Þ½ÃÁö°¡ Á¸ÀçÇÑ´Ù. ³»¿ëÀ» ÀÐ¾î ÀúÀåÇÑ´Ù.


							}
							cReadModeB = 21;
							break;

						case 21:
							// m_cTargetSearchRange
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);

							cReadModeB = 22;
							break;

						case 22:
							// Npc Àç »ý¼º±îÁöÀÇ ½Ã°£
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);

							cReadModeB = 23;
							break;

						case 23:
							// Attribute
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);

							cReadModeB = 24;
							break;

						case 24:
							// Absorb Magic Damage
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);

							cReadModeB = 25;
							break;

						case 25:
							// Maximum Mana Point
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);

							cReadModeB = 26;
							break;

						case 26:
							// MagicHitRatio
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);

							cReadModeB = 27;
							break;

						case 27:
							// AttackRange
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							iNpcConfigListIndex++;
							break;
					}
					break;

				case 2:
					m_iPlayerMaxLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					break;
			}
		} else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}

			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

BOOL CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA) {
	register int i, iTemp;
	char cTmpName[21];
	int sTemp;
	double dV1, dV2, dV3;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
				// °°Àº ÀÌ¸§À» °¡Áø NPC ¼³Á¤À» Ã£¾Ò´Ù. ¼³Á¤°ªÀ¸·Î ÃÊ±âÈ­ÇÑ´Ù.
				std::memset(pNpc->m_cNpcName, 0, sizeof(pNpc->m_cNpcName));
				memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);

				pNpc->m_sType = m_pNpcConfigList[i]->m_sType;

				// HitDice¿¡ µû¶ó °ø½ÄÀÌ ´Ù¸£´Ù. ¸÷°£ÀÇ Â÷º°À» µÎ±â À§ÇÔ.
				if (m_pNpcConfigList[i]->m_iHitDice <= 5)
					pNpc->m_iHP = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
				else pNpc->m_iHP = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
				// v1.4 È®ÀÎÄÚµå
				if (pNpc->m_iHP == 0) pNpc->m_iHP = 1;

				pNpc->m_iExpDiceMin = m_pNpcConfigList[i]->m_iExpDiceMin;
				pNpc->m_iExpDiceMax = m_pNpcConfigList[i]->m_iExpDiceMax;
				pNpc->m_iGoldDiceMin = m_pNpcConfigList[i]->m_iGoldDiceMin * 5;
				pNpc->m_iGoldDiceMax = m_pNpcConfigList[i]->m_iGoldDiceMax * 5;
				pNpc->m_iExp = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin) * 500;
				pNpc->m_iHitDice = m_pNpcConfigList[i]->m_iHitDice;
				pNpc->m_iDefenseRatio = m_pNpcConfigList[i]->m_iDefenseRatio;
				pNpc->m_iHitRatio = m_pNpcConfigList[i]->m_iHitRatio;
				pNpc->m_iMinBravery = m_pNpcConfigList[i]->m_iMinBravery;
				pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
				pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
				pNpc->m_cSize = m_pNpcConfigList[i]->m_cSize;
				pNpc->m_cSide = m_pNpcConfigList[i]->m_cSide;
				pNpc->m_cActionLimit = m_pNpcConfigList[i]->m_cActionLimit;
				pNpc->m_dwActionTime = m_pNpcConfigList[i]->m_dwActionTime;
				pNpc->m_dwRegenTime = m_pNpcConfigList[i]->m_dwRegenTime;
				pNpc->m_cResistMagic = m_pNpcConfigList[i]->m_cResistMagic;
				pNpc->m_cMagicLevel = m_pNpcConfigList[i]->m_cMagicLevel;
				pNpc->m_iMaxMana = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
				pNpc->m_iMana = m_pNpcConfigList[i]->m_iMaxMana;
				pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
				pNpc->m_cDayOfWeekLimit = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
				pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;

				switch (sClass) {
					case 43:
					case 44:
					case 45:
					case 46:
					case 47: // ÀüÀï¿ë À¯´ÖÀÇ °æ¿ì ¹«Á¶°Ç °ø°Ý¸¸ ÇÏ´Â Àü·«À» ±¸»ç.
						pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
						break;

					default:
						pNpc->m_iAttackStrategy = iDice(1, 10);
						break;
				}

				pNpc->m_iAILevel = iDice(1, 3);
				pNpc->m_iAbsDamage = m_pNpcConfigList[i]->m_iAbsDamage;
				pNpc->m_iMagicHitRatio = m_pNpcConfigList[i]->m_iMagicHitRatio;
				pNpc->m_iAttackRange = m_pNpcConfigList[i]->m_iAttackRange;
				pNpc->m_cSpecialAbility = cSA;
				pNpc->m_iBuildCount = m_pNpcConfigList[i]->m_iMinBravery;

				// v1.411 NPCÀÇ Æ¯¼ö È¿°ú °è»ê. °æÇèÄ¡ °¡Áß
				switch (pNpc->m_cSpecialAbility) {
					case 1:
						dV2 = (double) pNpc->m_iExp;
						dV3 = 25.0f / 100.0f;
						dV1 = dV2 * dV3;
						if (m_bHappyHour == TRUE) {
							pNpc->m_iExp += (int) dV1 * 2;
						}// >>>Happy Hour MrKrhiz <<<
						else {
							pNpc->m_iExp += (int) dV1;
						}
						break;
					case 2:
						dV2 = (double) pNpc->m_iExp;
						dV3 = 30.0f / 100.0f;
						dV1 = dV2 * dV3;
						if (m_bHappyHour == TRUE) {
							pNpc->m_iExp += (int) dV1 * 2;
						} else {
							pNpc->m_iExp += (int) dV1;
						}
						break;
					case 3: // Absorbing Physical Damage
						if (pNpc->m_iAbsDamage > 0) {
							pNpc->m_cSpecialAbility = NULL;
							cSA = NULL;
						} else {
							iTemp = 20 + iDice(1, 60);
							pNpc->m_iAbsDamage -= iTemp;
							if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
						}
						dV2 = (double) pNpc->m_iExp;
						dV3 = (double) abs(pNpc->m_iAbsDamage) / 100.0f;
						dV1 = dV2 * dV3;
						if (m_bHappyHour == TRUE) {
							pNpc->m_iExp += (int) dV1 * 2;
						} else {
							pNpc->m_iExp += (int) dV1;
						}
						break;

					case 4: // Absorbing Magical Damage
						if (pNpc->m_iAbsDamage < 0) {
							// ±âº»ÀûÀ¸·Î ¹°¸® ´ë¹ÌÁö Àý°¨ ´É·ÂÀÌ ÀÖ´Â °æ¿ì ¸¶¹ý ´ë¹ÌÁö Àý°¨Àº Àû¿ëµÇÁö ¾Ê´Â´Ù.
							pNpc->m_cSpecialAbility = NULL;
							cSA = NULL;
						} else {
							iTemp = 20 + iDice(1, 60);
							pNpc->m_iAbsDamage += iTemp;
							if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
						}
						dV2 = (double) pNpc->m_iExp;
						dV3 = (double) (pNpc->m_iAbsDamage) / 100.0f;
						dV1 = dV2 * dV3;
						if (m_bHappyHour == TRUE) {
							pNpc->m_iExp += (int) dV1 * 2;
						} else {
							pNpc->m_iExp += (int) dV1;
						}
						break;

					case 5:
						dV2 = (double) pNpc->m_iExp;
						dV3 = 15.0f / 100.0f;
						dV1 = dV2 * dV3;
						if (m_bHappyHour == TRUE) {
							pNpc->m_iExp += (int) dV1 * 2;
						} else {
							pNpc->m_iExp += (int) dV1;
						}
						break;

					case 6:
					case 7:
						dV2 = (double) pNpc->m_iExp;
						dV3 = 20.0f / 100.0f;
						dV1 = dV2 * dV3;
						if (m_bHappyHour == TRUE) {
							pNpc->m_iExp += (int) dV1 * 2;
						} else {
							pNpc->m_iExp += (int) dV1;
						}
						break;

					case 8:
						dV2 = (double) pNpc->m_iExp;
						dV3 = 25.0f / 100.0f;
						dV1 = dV2 * dV3;
						if (m_bHappyHour == TRUE) {
							pNpc->m_iExp += (int) dV1 * 2;
						} else {
							pNpc->m_iExp += (int) dV1;
						}
						break;
				}

				// v1.411 À§Ä¡ ¿Å±è
				pNpc->m_iNoDieRemainExp = (pNpc->m_iExp) - (pNpc->m_iExp / 3);

				// v1.411 NPCÀÇ Æ¯¼ö ´É·Â »ðÀÔ
				pNpc->m_iStatus = pNpc->m_iStatus & 0xFFFFF0FF;
				sTemp = cSA;
				sTemp = sTemp << 8;
				pNpc->m_iStatus = pNpc->m_iStatus | sTemp;

				// v1.41 NPCÀÇ Class»ðÀÔ.
				pNpc->m_iStatus = pNpc->m_iStatus & 0xFFFFFFF0;
				pNpc->m_iStatus = pNpc->m_iStatus | (sClass);

				return TRUE;
			}
		}

	// NPC¸®½ºÆ®¸¦ ¸ðµÎ °Ë»öÇßÀ½¿¡µµ ¹ß°ßµÇÁö ¾Ê¾Ò´Ù.
	return FALSE;
}

/*********************************************************************************************************************
 **  int CGame::iDice(int iThrow, int iRange)																		**
 **  description			:: produces a random number between the throw and range										**
 **  last updated		:: November 20, 2004; 10:24 PM; Hypnotoad													**
 **	return value		:: int																						**
 **********************************************************************************************************************/
int CGame::iDice(int iThrow, int iRange) {
	register int i, iRet;

	if (iRange <= 0) return 0;
	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}

/*
void CGame::OnStartGameSignal()
{
 int i;
 char * cp;
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;

	// ¸Ê ÀÌº¥Æ® È­ÀÏÀ» ÀÐ¾î °¢°¢ÀÇ ¸Ê¿¡ ÇÒ´çµÈ NPCµéÀ» ¼¼ÆÃÇÑ´Ù.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL)
		_bReadMapInfoFiles(i);

	// Crusade

	// Á¡·É ±ê¹ß Á¤º¸ ÀÐ´Â´Ù.
	hFile = CreateFile("GameData\\OccupyFlag.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen("GameData\\OccupyFlag.txt", "rt");
	if (pFile == NULL) {
		// Á¡·É ±ê¹ß Á¤º¸¸¦ ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open file: GameData\\OccupyFlag.txt");
	}
	else {
		PutLogList("(!) Occupy Flag save file contents decoding...");

		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		_bDecodeOccupyFlagSaveFileContents(cp, dwFileSize);
		delete cp;
	}

	// ÃÊ±â ¼³Ä¡ °Ç¹° Á¤º¸ ÀÐ´Â´Ù.
	bReadCrusadeStructureConfigFile("Crusade.cfg");
	// Æø°Ý Æ÷ÀÎÆ® Á¤º¸¸¦ ¹ÙÅÁÀ¸·Î ¸Ê ÀÎµ¦½º¸¦ ¸µÅ©½ÃÅ²´Ù.
	_LinkStrikePointMapIndex();

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");

	PutLogList("");
	PutLogList("(!) Game Server Activated.");
}*/

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH) {
	register int ix, iy, iExp;
	short sOwnerH;
	char cOwnerType;

	// ### ERROR POINT! ÀÓ½Ã·Î ¸·¾Æ ³í´Ù.
	return;

	if (m_pClientList[sAttackerH] == NULL) return;

	switch (cVictimType) {

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[iVictimH] == NULL) return;

			for (ix = m_pNpcList[iVictimH]->m_sX - 2; ix <= m_pNpcList[iVictimH]->m_sX + 2; ix++)
				for (iy = m_pNpcList[iVictimH]->m_sY - 2; iy <= m_pNpcList[iVictimH]->m_sY + 2; iy++) {

					m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);

					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
							  (memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
							  (m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel)) {
						// ±æµå¿ø°úÀÇ Çùµ¿ÀüÅõ¿¡¼­ °æÇèÄ¡¸¦ ¾ò±â À§ÇØ¼­´Â ¸ó½ºÅÍ¸¦ Á×ÀÎ ±æµå¿øÀÇ ·¹º§º¸´Ù ³·Àº ±æµå¿øÀÌ¾î¾ß ÇÑ´Ù.
						// 1D3ÀÇ °ªÀÌ 2ÀÏ¶§ ¸ó½ºÅÍ °æÇèÄ¡ÀÇ 3ºÐÀÇ 1À» ¾ò´Â´Ù.
						if (iDice(1, 3) == 2) {
							iExp = (m_pNpcList[iVictimH]->m_iExp / 3);
							if (m_pClientList[sAttackerH]->m_iLevel >= m_iPlayerMaxLevel) iExp = 0;

							if (iExp > 0) {

								m_pClientList[sOwnerH]->m_iExp += iExp;
								if (bCheckLimitedUser(sOwnerH) == FALSE) {
									// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ °É¸®Áö ¾Ê¾Ò´Ù. °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
								}
								// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
								bCheckLevelUp(sOwnerH);
							}
						}
					}
				}
			break;
	}
}

void CGame::TimeManaPointsUp(int iClientH) {
	register int iMaxMP, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	iMaxMP = (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)) + (2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) / 2); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		iTotal = iDice(1, ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double) iTotal;
			dV3 = (double) m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int) dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;

		if (m_pClientList[iClientH]->m_iMP > iMaxMP)
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}

// 05/29/2004 - Hypnotoad - fixed infinite sp bug

void CGame::TimeStaminarPointsUp(int iClientH) {
	register int iMaxSP, iTotal = 0;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ±Ã¢ Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«ÃÃŸÂ¿Â¡Â´Ã‚ Â½ÂºÃ…Ã—Â¹ÃŒÂ³ÃŠ Â¿Ã€Â¸Â£ÃÃ¶ Â¾ÃŠÃ€Â½.

	iMaxSP = (2 * (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr)) + (2 * m_pClientList[iClientH]->m_iLevel);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit / 3)); // Staminar Point´Â 10ÃÊ¸¶´Ù 1D(Vit/3)¾¿ ¿Ã¶ó°£´Ù.
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double) iTotal;
			dV3 = (double) m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int) dV1;
		}

		// v2.03 ·¹º§ 60 ÀÌÇÏ´Â Á¤±âÀûÀ¸·Î ½ºÅ×¹Ì³ª°¡ ¸¹ÀÌ Âù´Ù.
		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if (m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		} else if (m_pClientList[iClientH]->m_iLevel <= 60) {
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP)
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::DelayEventProcess() {

}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString) {
	char cData[500];
	DWORD * dwp;
	WORD * wp;
	char * cp;
	register int i, iRet;

	// °°Àº ±æµå¿øµé¿¡°Ô¸¸ º¸³»´Â ¸Þ½ÃÁöµé
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) &&
				  (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0)) {

			// ### BUG POINT À§Ä¡°¡ Àß¸øµÇ¾î Æ÷ÀÎÅÍ ¿¬»êÀÌ Àß¸øµÇ¾ú´Ù.
			std::memset(cData, 0, sizeof(cData));

			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = wNotifyMsgType;

			cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

			// °°Àº ±æµå ÀÌ¸§À» °®°í ÀÖ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£¾Ò´Ù.
			switch (wNotifyMsgType) {
				case DEF_NOTIFY_GUILDDISBANDED:
					if (i == iClientH) break; // <-- ±æµå ¸¶½ºÅÍ ÀÚ½Å¿¡°Ô´Â ¸Þ½ÃÁö¸¦ º¸³»Áö ¾Ê´Â´Ù.
					// ±æµå ÇØ»ê Åëº¸¿¡ ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå ·©Å©¸¦ Å¬¸®¾îÇÑ´Ù.
					memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
					cp += 20;

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
					// ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå³»¿ëÀ» Å¬¸®¾îÇÑ´Ù. @@@@@@@
					std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
					strcpy(m_pClientList[i]->m_cGuildName, "NONE");
					m_pClientList[i]->m_iGuildRank = -1;
					m_pClientList[i]->m_iGuildGUID = -1;
					break;

				case DEF_NOTIFY_EVENTMSGSTRING:
					// ±æµå¿øµé¿¡°Ô Àü´ÞµÇ´Â ÀÌº¥Æ® ¸Þ½ÃÁö ½ºÆ®¸µ
					strcpy(cp, pString);
					cp += strlen(pString);

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
					break;

				case DEF_NOTIFY_NEWGUILDSMAN:
					memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
					cp += 10;

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
					break;

				case DEF_NOTIFY_DISMISSGUILDSMAN:
					memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
					cp += 10;

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
					break;
			}

			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(i, TRUE, TRUE);
					return;
			}
		}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize) {
	// ´Ù¸¥ °ÔÀÓ¼­¹ö·ÎºÎÅÍ ±æµå ÀÌº¥Æ®°¡ µµÂøÇß´Ù.
	char * cp, cCharName[11], cGuildName[21];

	std::memset(cCharName, 0, sizeof(cCharName));
	std::memset(cGuildName, 0, sizeof(cGuildName));

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	// ¾ÆÁ÷ ±¸ÇöµÇÁö ¾Ê¾Ò´Ù.
}

void CGame::ToggleCombatModeHandler(int iClientH) {
	short sAppr2;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	// Á×ÀºÃ´ÇÏ±â³ª Á×Àº »óÅÂ¿¡¼­´Â º¯È¯ÇÒ ¼ö ¾ø´Ù.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	sAppr2 = (short) ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; // v2.172


	if (sAppr2 == 0) {
		// ºñÀüÅõ ¸ðµå¿´´Ù. ÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	} else {
		// ÀüÅõ ¸ðµå¿´´Ù. ºñÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	// Ä³¸¯ÅÍÀÇ ¿ÜÇüÀÌ ¹Ù²î¾úÀ¸¹Ç·Î ÀÌº¥Æ®¸¦ Àü´ÞÇÑ´Ù.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is casting magic
//  last updated		:: October 29, 2004; 6:51 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////

int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir) {
	char cData[100];
	DWORD * dwp;
	WORD * wp;
	int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
			case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++;
				break;
			case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++;
				break;
			case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;
				break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
	}

	return 1;
}

/*********************************************************************************************************************
 **  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)			**
 **  description			:: handles all magic related items/spells													**
 **  last updated		:: November 22, 2004; 5:45 PM; Hypnotoad													**
 **	return value		:: void																						**
 **  commentary			::	-	added 3.51 casting detection														**
 **							-	updated it so civilians can only cast certain spells on players and vice versa		**
 **							-	fixed bug causing spell to be cast when mana is below required amount				**
 **********************************************************************************************************************/
int _tmp_iMCProb[] = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int _tmp_iMLevelPenalty[] = {0, 5, 5, 8, 8, 10, 14, 28, 32, 36, 40};

void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1) {
	short * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic, sTemp;
	char * cp, cData[120], cDir, cOwnerType, cName[11], cItemName[21], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor, cScanMessage[256];
	double dV1, dV2, dV3, dV4;
	int i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int tX, tY, iManaCost, iMagicAttr;
	class CItem * pItem;
	DWORD * dwp, dwTime;
	WORD * wp, wWeaponType;
	short sEqStatus;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_bMagicConfirm = TRUE;

	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
			  (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;

	if (((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 1000) && (bItemEffect == 0)) {
		wsprintf(G_cTxt, "3.51 Detection: (%s) Player: (%s) - Magic casting speed is too fast! Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;

	if ((sType < 0) || (sType >= 100)) return;
	if (m_pMagicConfigList[sType] == NULL) return;

	if ((bItemEffect == FALSE) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;

	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
	//if ((var_874 == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) && (m_pMagicConfigList[sType]->m_sType != 8)) return;

	if (((m_pClientList[iClientH]->m_iStatus & 0x100000) != 0) && (bItemEffect != TRUE)) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, NULL, -1, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if ((wWeaponType >= 34) && (wWeaponType <= 39)) {
		} else return;
	}

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] != -1) ||
			  (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) return;

	if ((m_pClientList[iClientH]->m_iSpellCount > 1) && (bItemEffect == FALSE)) {
		wsprintf(G_cTxt, "TSearch Spell Hack: (%s) Player: (%s) - casting magic without precasting.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	if (m_pClientList[iClientH]->m_bInhibition == TRUE) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;
	}

	/*if (((m_pClientList[iClientH]->m_iUninteruptibleCheck - (iGetMaxHP(iClientH)/10)) > (m_pClientList[iClientH]->m_iHP)) && (m_pClientList[iClientH]->m_bMagicItem == FALSE)) {
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL);
		return;
	}*/

	if (m_pMagicConfigList[sType]->m_sType == 32) { // Invisiblity
		sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != NULL)) {
			if ((m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 866)) {
				bItemEffect = TRUE;
			}
		}
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		dV1 = 1.0f;
	else dV1 = (double) m_pClientList[iClientH]->m_cSkillMastery[4];

	if (bItemEffect == TRUE) dV1 = (double) 100.0f;
	dV2 = (double) (dV1 / 100.0f);
	dV3 = (double) _tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int) dV1;

	if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 50)
		iResult += ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) - 50) / 2;

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double) (m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
			dV2 = (double) abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double) abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3) * dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle] - (int) dV4);
		} else {
			iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}
	}

	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0: break;
		case 1: iResult = iResult - (iResult / 24);
			break;
		case 2: iResult = iResult - (iResult / 12);
			break;
		case 3: iResult = iResult - (iResult / 5);
			break;
	}

	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double) iResult;
		dV2 = (double) (m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int) dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);

	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) &&
			  (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)) {
		iManaCost += (iManaCost / 2) - (iManaCost / 10);
	}

	if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
		dV1 = (double) m_pClientList[iClientH]->m_iManaSaveRatio;
		dV2 = (double) (dV1 / 100.0f);
		dV3 = (double) iManaCost;
		dV1 = dV2 * dV3;
		dV2 = dV3 - dV1;
		iManaCost = (int) dV2;

		if (iManaCost <= 0) iManaCost = 1;
	}

	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 34) {
		iManaCost += 20;
	}

	if (iResult < 100) {
		iDiceRes = iDice(1, 100);
		if (iResult < iDiceRes) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;
		}
	}

	if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1, 1000) <= 100)) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iMP < iManaCost) {
		return;
	}

	iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
	if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) - 50);

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double) (m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
			dV2 = (double) abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double) abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3) * dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle] - (int) dV4);
		} else {
			iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}
	}

	iResult += m_pClientList[iClientH]->m_iAddAR;
	if (iResult <= 0) iResult = 1;

	if (sType >= 80) iResult += 10000;

	if (m_pMagicConfigList[sType]->m_sType == 28) {
		iResult += 10000;
	}

	if (m_pMagicConfigList[sType]->m_cCategory == 1) {
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}

	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
	if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if ((m_bIsCrusadeMode == FALSE) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
		if ((m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == TRUE)) {
			if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) return;
		} else if ((m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == FALSE)) {
			switch (m_pMagicConfigList[sType]->m_sType) {
				case 1: // DEF_MAGICTYPE_DAMAGE_SPOT
				case 4: // DEF_MAGICTYPE_SPDOWN_SPOT 4
				case 8: // DEF_MAGICTYPE_TELEPORT 8
				case 10: // DEF_MAGICTYPE_CREATE 10
				case 11: // DEF_MAGICTYPE_PROTECT 11
				case 12: // DEF_MAGICTYPE_HOLDOBJECT 12
				case 16: // DEF_MAGICTYPE_CONFUSE
				case 17: // DEF_MAGICTYPE_POISON
				case 24: // DEF_MAGICTYPE_RESURRECTION
					return;
			}
		}
	}

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		switch (m_pMagicConfigList[sType]->m_sType) {

			case DEF_MAGICTYPE_DAMAGE_SPOT:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}
				break;

			case DEF_MAGICTYPE_HPUP_SPOT:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				break;

			case DEF_MAGICTYPE_PURITYLIFE_SPOT:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				PURITYLIFE(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}

				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
				break;

			case DEF_MAGICTYPE_SPDOWN_SPOT:
				break;

			case DEF_MAGICTYPE_SPDOWN_AREA:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				break;

			case DEF_MAGICTYPE_POLYMORPH:
				// ÂºÂ¯Â½Ã… Â¸Â¶Â¹Ã½.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char) m_pMagicConfigList[sType]->m_sValue4;
							// Â¿Ã¸Â·Â¡ Ã…Â¸Ã€Ã”Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
							m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
							// Â¹Ã™Â²Ã¯ Â¿ÃœÃ‡Ã¼Ã€Â» Ã…Ã«ÂºÂ¸Ã‡Ã˜ ÃÃ˜Â´Ã™.
							m_pClientList[sOwnerH]->m_sType = 18;
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char) m_pMagicConfigList[sType]->m_sValue4;
							// Â¿Ã¸Â·Â¡ Ã…Â¸Ã€Ã”Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
							m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
							// Â¹Ã™Â²Ã¯ Â¿ÃœÃ‡Ã¼Ã€Â» Ã…Ã«ÂºÂ¸Ã‡Ã˜ ÃÃ˜Â´Ã™.
							m_pNpcList[sOwnerH]->m_sType = 18;
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							break;
					}

					// ÂºÂ¯Â½Ã… ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				}
				break;

				// 05/20/2004 - Hypnotoad - Cancellation
			case DEF_MAGICTYPE_CANCELLATION:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)) {

					// Removes Invisibility Flag 0x0010
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);

					// Removes Illusion Flag 0x01000000
					SetIllusionFlag(sOwnerH, cOwnerType, FALSE);

					// Removes Defense Shield Flag 0x02000000
					// Removes Great Defense Shield Flag 0x02000000
					SetDefenseShieldFlag(sOwnerH, cOwnerType, FALSE);

					// Removes Absolute Magic Protection Flag 0x04000000
					// Removes Protection From Magic Flag 0x04000000
					SetMagicProtectionFlag(sOwnerH, cOwnerType, FALSE);

					// Removes Protection From Arrow Flag 0x08000000
					SetProtectionFromArrowFlag(sOwnerH, cOwnerType, FALSE);

					// Removes Illusion Movement Flag 0x00200000
					SetIllusionMovementFlag(sOwnerH, cOwnerType, FALSE);

					// Removes Berserk Flag 0x0020
					SetBerserkFlag(sOwnerH, cOwnerType, FALSE);

					if (m_pClientList[iClientH]->m_bInhibition == TRUE)
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					if (m_pClientList[iClientH]->m_iStatus & 0x0010)
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					if (m_pClientList[iClientH]->m_iStatus & 0x0020)
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					if ((m_pClientList[iClientH]->m_iStatus & 0x08000000) || (m_pClientList[iClientH]->m_iStatus & 0x04000000) || (m_pClientList[iClientH]->m_iStatus & 0x02000000))
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					if ((m_pClientList[iClientH]->m_iStatus & 0x01000000) || (m_pClientList[iClientH]->m_iStatus & 0x00200000))
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					// Update Client
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
				// ������ ó������ �ʴ´�.
				// �ֺ� ��� ȿ��
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// �ڽŵ� ����� �� ������ ����.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ���� ô�ϰ� �ִ� �÷��̾��.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							}
						}
					}
				break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR:
				// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃŽ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
				sX = m_pClientList[iClientH]->m_sX;
				sY = m_pClientList[iClientH]->m_sY;

				for (i = 2; i < 10; i++) {
					iErr = 0;
					m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
				}

				// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}

				// dX, dY
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						  (m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
				}
				break;

				// v2.16 2002-5-23 Â°Ã­Â±Â¤Ã‡Ã¶
			case DEF_MAGICTYPE_ICE_LINEAR:
				// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃŽ Â¾Ã³Â¸Â®Â¸Ã§ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
				sX = m_pClientList[iClientH]->m_sX;
				sY = m_pClientList[iClientH]->m_sY;

				for (i = 2; i < 10; i++) {
					iErr = 0;
					m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_iHP < 0) goto MAGIC_NOEFFECT;
								// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									}
								}
								break;
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}
					}

					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									}
								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}
					}

					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									}
								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}
					}

					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									}
								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}
					}

					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									}
								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}
					}

					if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
				}

				// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
								//
							}
						}
					}

				// dX, dY
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
									SetIceFlag(sOwnerH, cOwnerType, TRUE);
									// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								}
							}
							break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						  (m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
						// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									}
								}
								break;
						}
						//
					}
				}
				break;


			case DEF_MAGICTYPE_INHIBITION:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if ((m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) || (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)) goto MAGIC_NOEFFECT; // juan - ic fix para que no pegue si tiene AMP o PFM .
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INHIBITION ] != 0) goto MAGIC_NOEFFECT;
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
						//if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto MAGIC_NOEFFECT;
						m_pClientList[sOwnerH]->m_bInhibition = TRUE;
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;
				}
				break;
			case DEF_MAGICTYPE_TREMOR: // v1.4 ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°ÃºÂ¿Â¡ Ã€ÃŒÂ¾Ã® Ã€ÃœÂ·Ã¹ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						  (m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}

				// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
				// ÃÃ·Â°ÃÃ€Âº ÃƒÂ³Â¸Â®Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
				// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
				break;

			case DEF_MAGICTYPE_SPUP_AREA:
				// SpÂ°Â¡ Â»Ã³Â½Ã‚Ã‡Ã‘Â´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€ÃŒ Ã‡ÃŠÂ¿Ã¤Â¾Ã¸Â´Ã™.
				Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						// Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—Ã€ÃŒ Ã‡ÃŠÂ¿Ã¤ Â¾Ã¸Â´Ã™.
						Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				break;

				// v2.16 2002-5-23 °í±¤Çö
			case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
				// ÀÏÁ÷¼± »ó¿¡ ÀÖ´Â ¸ñÇ¥¸¦ ¸ðµÎ ¾ó¸®¸ç °ø°ÝÇÑ´Ù.
				sX = m_pClientList[iClientH]->m_sX;
				sY = m_pClientList[iClientH]->m_sY;

				for (i = 2; i < 10; i++) {
					iErr = 0;
					m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}
					}

					// tx-1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}
					}

					// tx+1, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}
					}

					// tx, ty-1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}
					}

					// tx, ty+1
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;
						}
						//
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}
					}

					if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
				}

				// ÁÖº¯ °ø°Ý È¿°ú
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

										}
										break;
								}
								//
							}
						}
					}

				// dX, dY
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
					// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							}
							break;
					}
					//
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						  (m_pClientList[sOwnerH]->m_iHP > 0)) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
						// ¾ó¾î¼­ µ¿ÀÛÀÌ ´Ê¾îÁö´Â È¿°ú
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆÐÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

								}
								break;
						}
						//
					}
				}
				break;

			case DEF_MAGICTYPE_TELEPORT:
				//50Cent - Capture The Flag
				if (bCheckIfIsFlagCarrier(iClientH)) {
					ShowClientMsg(iClientH, "You can not use that magic being a flag carrier.");
					goto MAGIC_NOEFFECT;
				}
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				switch (m_pMagicConfigList[sType]->m_sValue4) {
					case 1:
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH)) {
							if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) > 10000) {
								RequestTeleportHandler(iClientH, "1 ");
							} else {
								char cCannotRecall[256];
								wsprintf(cCannotRecall, "Wait 10 seconds after get DMG to Recall.");
								ShowClientMsg(iClientH, cCannotRecall);
								goto MAGIC_NOEFFECT;
							}
						}
						break;
				}
				break;

			case DEF_MAGICTYPE_SUMMON:
				// Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½

				// Â»Ã§Ã…ÃµÃ€Ã¥ Â³Â»Â¿Â¡Â¼Â­Â´Ã‚ Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰.
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) return;

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				// ÃÃ¶ÃÂ¤ÂµÃˆ OwnerÂ°Â¡ MasterÂ°Â¡ ÂµÃˆÂ´Ã™.
				if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
					// MasterÂ·ÃŽ ÃÃ¶ÃÂ¤ÂµÃˆ Â´Ã«Â»Ã³Ã€Â» ÂµÃ»Â¶Ã³Â´Ã™Â´ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â°Â´ÃƒÂ¼ Â¼Ã¶Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
					iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

					// Â¼Ã’ÃˆÂ¯Â¸Â¶Â¹Ã½Ã€Â» CastingÃ‡Ã‘ Ã€ÃšÃ€Ã‡ Magery/20 Â¸Â¸Ã…Â­Ã€Ã‡ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ Â¼Ã’ÃˆÂ¯Ã‡Ã’ Â¼Ã¶ Ã€Ã–Â´Ã™.
					if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4] / 20)) break;

					iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
					} else {
						// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
						std::memset(cName, 0, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = '_';
						cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

						// MageryÂ¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã’ÃˆÂ¯ÂµÃ‡Â´Ã‚ Â¸Ã³Â½ÂºÃ…ÃÃ€Ã‡ ÂµÃ®Â±ÃžÃ€ÃŒ Â´ÃžÂ¶Ã³ÃÃ¸Â´Ã™.
						std::memset(cNpcName, 0, sizeof(cNpcName));

						switch (iV1) {
							case NULL: // Ã€ÃÂ¹ÃÃ€Ã»Ã€ÃŽ Â°Ã¦Â¿Ã¬
								iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);

								// v1.42 ÃƒÃ–Ã€Ãº Â¸Ã· Â·Â¹ÂºÂ§Ã€Â» Ã€Ã”Â·Ã‚
								if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20)
									iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

								switch (iResult) {
									case 1: strcpy(cNpcName, "Slime");
										break;
									case 2: strcpy(cNpcName, "Giant-Ant");
										break;
									case 3: strcpy(cNpcName, "Amphis");
										break;
									case 4: strcpy(cNpcName, "Orc");
										break;
									case 5: strcpy(cNpcName, "Skeleton");
										break;
									case 6: strcpy(cNpcName, "Clay-Golem");
										break;
									case 7: strcpy(cNpcName, "Stone-Golem");
										break;
									case 8: strcpy(cNpcName, "Orc-Mage");
										break;
									case 9: strcpy(cNpcName, "Hellbound");
										break;
									case 10:strcpy(cNpcName, "Cyclops");
										break;
								}
								break;

							case 1: strcpy(cNpcName, "Orc");
								break;
							case 2: strcpy(cNpcName, "Skeleton");
								break;
							case 3: strcpy(cNpcName, "Clay-Golem");
								break;
							case 4: strcpy(cNpcName, "Stone-Golem");
								break;
							case 5: strcpy(cNpcName, "Hellbound");
								break;
							case 6: strcpy(cNpcName, "Cyclops");
								break;
							case 7: strcpy(cNpcName, "Troll");
								break;
							case 8: strcpy(cNpcName, "Orge");
								break;

							case 9: strcpy(cNpcName, "Sor-Aresden");
								break;
							case 10: strcpy(cNpcName, "ATK-Elvine");
								break;
							case 11: strcpy(cNpcName, "Elf-Aresden");
								break;
							case 12: strcpy(cNpcName, "DSK-Elvine");
								break;
							case 13: strcpy(cNpcName, "HBT-Aresden");
								break;
							case 14: strcpy(cNpcName, "Bar-Elvine");
								break;

						}

						if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE) == FALSE) {
							// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·ÃŽ Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
						} else {
							std::memset(cName_Master, 0, sizeof(cName_Master));
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
									break;
								case DEF_OWNERTYPE_NPC:
									memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
									break;
							}
							bSetNpcFollowMode(cName, cName_Master, cOwnerType);
						}
					}
				}
				break;

			case DEF_MAGICTYPE_CREATE:
				// Â¹Â«Â¾Ã°Â°Â¡Â¸Â¦ Â»Ã½Â¼ÂºÂ½ÃƒÃ…Â°Â´Ã‚ Â¸Â¶Â¹Ã½

				// Ã€Â§Ã„Â¡Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã·Â¿Â¡Â´Ã‚ Â»Ã½Â±Ã¢ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE)
					goto MAGIC_NOEFFECT;

				pItem = new class CItem;

				switch (m_pMagicConfigList[sType]->m_sValue4) {
					case 1:
						// Food
						if (iDice(1, 2) == 1)
							wsprintf(cItemName, "Meat");
						else wsprintf(cItemName, "Baguette");
						break;
				}

				_bInitItemAttr(pItem, cItemName);

				// v2.15 Â¸Â¶Â¹Ã½Ã€Â¸Â·ÃŽ Â»Ã½Â±Ã¤ Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â°Ã­Ã€Â¯Â¹Ã¸ÃˆÂ£ Ã€ÃºÃ€Ã¥
				pItem->m_sTouchEffectType = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1, 100000);
				pItem->m_sTouchEffectValue2 = iDice(1, 100000);
				pItem->m_sTouchEffectValue3 = (short) timeGetTime();

				// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

				// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃŽÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™.
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) - 1, pItem);

				// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™.
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						  dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
				break;

			case DEF_MAGICTYPE_PROTECT:
				// ÂºÂ¸ÃˆÂ£ Â¸Â¶Â¹Ã½
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				// ÂºÂ¸ÃˆÂ£ Â»Ã³Ã…Ã‚Â¶Ã³Â´Ã‚ Â°ÃÃ€Â» Â¼Â³ÃÂ¤Ã‡ÃÂ±Ã¢ Ã€Ã¼Â¿Â¡ Ã€ÃŒÂ¹ÃŒ Ã‡Ã˜Â´Ã§ ÂºÂ¸ÃˆÂ£Â°Â¡ Â°Ã‰Â·ÃÃ€Ã–Â´Ã‚ÃÃ¶ ÃˆÂ®Ã€ÃŽÃ‡ÃÂ°Ã­ Â°Ã‰Â·ÃÃ€Ã–Â´Ã™Â¸Ã© Â¸Â¶Â¹Ã½Ã€Âº Â¹Â«Â½ÃƒÂµÃˆÂ´Ã™.
				switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
						// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” Â¸Â¶Â¹Ã¦Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

						m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char) m_pMagicConfigList[sType]->m_sValue4;
						switch (m_pMagicConfigList[sType]->m_sValue4) {
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
						// ÃÂ¤Ã€Ã» NPCÂµÃ©Ã€Âº ÂºÂ¸ÃˆÂ£ Â¸Â¶Â¹Ã½ Ã€Ã»Â¿Ã« Â¾ÃˆÂµÃŠ.
						if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char) m_pMagicConfigList[sType]->m_sValue4;

						switch (m_pMagicConfigList[sType]->m_sValue4) {
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
						}
						break;
				}

				// ÂºÂ¸ÃˆÂ£ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
						  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

				/*					// Magictype:	Protection from Magic, Protection from Arrow, Defense Shield
						//				Absolue Magic Protection, Great Defense Shield
						case DEF_MAGICTYPE_PROTECT:
							// iClientH (the caster) gets the spell targets (sOwnerH) type (npc/pc) and coords (x,y)
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
							// switch cases for the owner type (DEF_OWNERTYPE_PLAYER, DEF_OWNERTYPE_NPC)
							switch (cOwnerType) {
							// if the owners is a player
							case DEF_OWNERTYPE_PLAYER:
								// DISABLED: if the caster side isnt the same as the targets side, no effect occurs
								// DISABLED: if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;
								// if the player target doesnt exist no magic effect
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// if the player target already has a protect magic on, no magic effect occurs
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != FALSE) goto MAGIC_NOEFFECT;
								// if the caster is neutral go to no magic effect
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
								// switch cases for the effect4 of the spell
								switch (m_pMagicConfigList[sType]->m_sValue4){
									// Protection From Arrow
									case 1:
										// triggers the spell target's protection from arrow flag on
										SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
										break; // end case 1
									// Protection From Magic
									// Absolue Magic Protection
									case 2:
									case 5:
										// triggers the spell target's protection from magic flag on
										SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
										break; // end case 2, case 5
									// Defense Shield
									// Great Defense Shield
									case 3:
									case 4:
										// triggers the spells target's defense shield flag on
										SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
										break; // end case 3, case 4
								} // end switch (m_pMagicConfigList[sType]->m_sValue4){
								// the target's magic effect is set to the effect4 value of the spell cast on him
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break; // break; DEF_OWNERTYPE_PLAYER

							case DEF_OWNERTYPE_NPC:
								// if the npc target doesnt exist no magic effect
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// if the npc target already has a protect magic on, no magic effect occurs
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
								// if the npc's action limit is not 0, no magic effect occurs
								if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
								// switch cases for the effect4 of the spell
								switch (m_pMagicConfigList[sType]->m_sValue4){
									// Protection From Arrow
									case 1:
										// triggers the spell target's protection from arrow flag on
										SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
										break; // end case 1
									// Protection From Magic
									// Absolue Magic Protection
									case 2:
									case 5:
										// triggers the spell target's protection from magic flag on
										SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
										break; // end case 2, case 5
									// Defense Shield
									// Great Defense Shield
									case 3:
									case 4:
										// triggers the spells target's defense shield flag on
										SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
										break; // end case 3, case 4
								} // end switch (m_pMagicConfigList[sType]->m_sValue4){
								// the npc's magic effect is set to the effect4 value of the spell cast on it
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;
							} // end switch (cOwnerType) {
							// the DEF_MAGICTYPE_PROTECT effect leaves after the magic effects "Last" time (in seconds)
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000),
													 sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							// if the owner is a player send a message
							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break; // end case DEF_MAGICTYPE_PROTECT:*/

			case DEF_MAGICTYPE_SCAN:
				std::memset(cScanMessage, 0, sizeof(cScanMessage));
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							wsprintf(cScanMessage, " Player: %s || Health: %d || Mana: %d || Stamina: %d || Criticals: %d", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP, m_pClientList[sOwnerH]->m_iSP, m_pClientList[sOwnerH]->m_iSuperAttackLeft);
							//ShowClientMsg(iClientH, cScanMessage);
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cScanMessage);
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							wsprintf(cScanMessage, " Monster: %s || Health: %d || Mana: %d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
							//   ShowClientMsg(iClientH, cScanMessage);
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cScanMessage);
							break;
					}
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
							  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, 10);
				}
				break;
			case DEF_MAGICTYPE_HOLDOBJECT:
				// Â¿Ã€ÂºÃªÃÂ§Ã†Â®Ã€Ã‡ Â¿Ã²ÃÃ·Ã€Ã“Ã€Â» ÂºÃ€Â¼Ã¢Ã‡Ã‘Â´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
							// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” Ã†ÃÂ·Â²Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
							// 2002-09-10 #2 Â¾ÃˆÃ€Ã¼ÃÃ¶Â´Ã«(No-Attack-Area) Ã†ÃÂ·Â² Â¸Â¶Â¹Ã½ Â¾ÃˆÂµÃ‡Â°Ã” Ã‡Ã”
							if (cOwnerType == DEF_OWNERTYPE_PLAYER) {

								if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
								if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
							}

							// 2002-09-10 #3 Ã€Ã¼Â¸Ã©Ã€Ã¼Â½ÃƒÂ¿Ã Â¹ÃŒÂµÃ©Â·Â£ÂµÃ¥Â¿Â¡Â¼Â­Â¸Â¦ ÃÂ¦Â¿ÃœÃ‡ÃÂ°Ã­ Â°Â°Ã€Âº Ã†Ã­Â¿Â¡Â°Ã”Â´Ã‚ Ã†ÃÂ·Â² Â¾ÃˆÂµÃŠ
							if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
									  m_bIsCrusadeMode == FALSE &&
									  m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide)
								goto MAGIC_NOEFFECT;

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char) m_pMagicConfigList[sType]->m_sValue4;
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 Â¸Â¶Â¹Ã½ Â·Â¹ÂºÂ§ 6Ã€ÃŒÂ»Ã³Ã€ÃŽ Â¸Â®Ã„Â¡Â±Ãž Ã€ÃŒÂ»Ã³Ã€Ã‡ Â¸Â¶Â¹Ã½ Â¸Ã³Â½ÂºÃ…ÃÂ¿Â¡Â°Ã”Â´Ã‚ Â¸Â¶ÂºÃ± Â¸Â¶Â¹Ã½ Ã…Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char) m_pMagicConfigList[sType]->m_sValue4;
							break;
					}

					// ÂºÂ¸ÃˆÂ£ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					// ÃˆÂ¿Â°ÃºÂ°Â¡ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				}
				break;

			case DEF_MAGICTYPE_INVISIBILITY:
				//50Cent - Capture The flag
				if (bCheckIfIsFlagCarrier(iClientH)) {
					ShowClientMsg(iClientH, "You can not use that magic being a flag carrier.");
					goto MAGIC_NOEFFECT;
				}
				switch (m_pMagicConfigList[sType]->m_sValue4) {
					case 1:
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char) m_pMagicConfigList[sType]->m_sValue4;
								SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
								RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;

								if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
									// Ã€ÃŒÂµÂ¿Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚ NPCÂ´Ã‚ Ã…ÃµÂ¸Ã­ Â¸Â¶Â¹Ã½Ã€Â» Â°Ã‰ Â¼Ã¶ Â¾Ã¸Â´Ã™.
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char) m_pMagicConfigList[sType]->m_sValue4;
									SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
									// Ã€ÃŒ NPCÂ¸Â¦ ÃƒÃŸÃ€Ã»Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã¸ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
									RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
								}
								break;
						}

						// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;

					case 2:
						// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” ÃÃŸÂµÂ¶Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

						// dX, dY Â¹ÃÂ°Ã¦ 8 ÃÃ–ÂºÂ¯Ã€Ã‡ Invisibility Â»Ã³Ã…Ã‚Ã€ÃŽ ObjectÂ°Â¡ Ã€Ã–Ã€Â¸Â¸Ã© Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
						for (ix = dX - 8; ix <= dX + 8; ix++)
							for (iy = dY - 8; iy <= dY + 8; iy++) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
												SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
												bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
												SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
												bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
											}
											break;
									}
								}
							}
						break;
				}
				break;

			case DEF_MAGICTYPE_CREATE_DYNAMIC:
				// Dynamic ObjectÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡ÃÂ°Ã­ ÃˆÂ¿Â·Ã‚Ã€ÃŒ ÃÃ¶Â¼Ã“ÂµÃ‡Â´Ã‚ Ã…Â¸Ã€Ã”.

				// v2.1 Â¸Â¶Ã€Â» Â³Â»Â¿Â¡Â¼Â­Â´Ã‚ Ã‡ÃŠÂµÃ¥ Â¸Â¶Â¹Ã½ Â±ÃÃÃ¶(Ã€Ã¼Â¸Ã©Ã€Ã¼Â½Ãƒ ÃÂ¦Â¿Ãœ)
				if (m_bIsCrusadeMode == FALSE) {
					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
					// v2.14
					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
				}

				switch (m_pMagicConfigList[sType]->m_sValue10) {
					case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // ÂµÂ¶Â±Â¸Â¸Â§

					case DEF_DYNAMICOBJECT_FIRE: // Fire Ã€ÃŒÂ´Ã™.
					case DEF_DYNAMICOBJECT_SPIKE: // Spike

#ifdef DEF_TAIWANLOG
						short sTemp_X, sTemp_Y;
						// v2.15 Â¸Â¶Â¹Ã½Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Â§Ã„Â¡Â¸Â¦ Ã‡Â¥Â½ÃƒÃ‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã‘ ÂºÂ¯Â¼Ã¶
						sTemp_X = m_pClientList[iClientH]->m_sX;
						sTemp_Y = m_pClientList[iClientH]->m_sY;

						m_pClientList[iClientH]->m_sX = dX;
						m_pClientList[iClientH]->m_sY = dY;

						_bItemLog(DEF_ITEMLOG_SPELLFIELD, iClientH, m_pMagicConfigList[sType]->m_cName, NULL);

						m_pClientList[iClientH]->m_sX = sTemp_X;
						m_pClientList[iClientH]->m_sY = sTemp_Y;
#endif

						switch (m_pMagicConfigList[sType]->m_sValue11) {
							case 1:
								// wall - type
								cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
								switch (cDir) {
									case 1: rx = 1;
										ry = 0;
										break;
									case 2: rx = 1;
										ry = 1;
										break;
									case 3: rx = 0;
										ry = 1;
										break;
									case 4: rx = -1;
										ry = 1;
										break;
									case 5: rx = 1;
										ry = 0;
										break;
									case 6: rx = -1;
										ry = -1;
										break;
									case 7: rx = 0;
										ry = -1;
										break;
									case 8: rx = 1;
										ry = -1;
										break;
								}

								iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
										  dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000);

								bAnalyzeCriminalAction(iClientH, dX, dY);

								for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
									iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
											  dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
									bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i * ry);

									iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
											  dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
									bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i * ry);
								}
								break;

							case 2:
								// Field - Type
								BOOL bFlag = FALSE;
								int cx, cy;
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
									for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
										iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
												  ix, iy, m_pMagicConfigList[sType]->m_dwLastTime * 1000, m_pMagicConfigList[sType]->m_sValue5);

										// Â¸Â¸Â¾Ã  Â¸Â¶Ã€Â»Â¿Â¡Â¼Â­ Ã‡ÃŠÂµÃ¥Â¸Â¦ Â±Ã± Â°Ã·Â¿Â¡ Â¹Â«Â°Ã­Ã‡Ã‘ Ã€ÃšÂ°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã¸Â°ÃÃ€ÃšÂ´Ã‚ Â°Â¡ÂµÃ¥Ã€Ã‡ Â°Ã¸Â°ÃÃ€Â» Â¹ÃžÂ°Ã” ÂµÃˆÂ´Ã™.
										if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
											bFlag = TRUE;
											cx = ix;
											cy = iy;
										}
									}
								// Ã‡ÃŠÂµÃ¥Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â°Ã¦ÂºÃ±Â¸Â¦ 1Â¸Ã­Â¸Â¸ Â¼Ã’ÃˆÂ¯Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”.
								if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
								break;
						}
						//
						break;

					case DEF_DYNAMICOBJECT_ICESTORM:
						// Ice-Storm Dynamic Object
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
								  dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000,
								  m_pClientList[iClientH]->m_cSkillMastery[4]);
						break;

					default:
						break;
				}
				break;

			case DEF_MAGICTYPE_POSSESSION:
				// Â¿Ã¸Â°Ã…Â¸Â®Â¿Â¡ Â¶Â³Â¾Ã®ÃÂ® Ã€Ã–Â´Ã‚ Â¹Â°Â°Ã‡Ã€Â» ÃÃ½Â¾Ã®Â¿Ã€Â´Ã‚ Â¸Â¶Â¹Ã½Ã€ÃŒÂ´Ã™.
				// v2.12 ÃÃŸÂ¸Â³Ã€Âº Ã†Ã·ÃÂ¦Â¼Ã‡ Â¸Â¶Â¹Ã½ Â»Ã§Â¿Ã« ÂºÃ’Â°Â¡
				if (m_pClientList[iClientH]->m_cSide == NULL) goto MAGIC_NOEFFECT;

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (sOwnerH != NULL) break; // v1.41 Ã†Ã·ÃÂ¦Â¼Ã‡ Â¸Â¶Â¹Ã½Ã€Âº Â»Ã§Â¶Ã·Ã€ÃŒ Â¼Â­ Ã€Ã–Â´Ã‚ Ã€Â§Â¿Â¡Â´Ã‚ ÃˆÂ¿Â·Ã‚Ã€ÃŒ Â¾Ã¸Â´Ã™.

				pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
				if (pItem != NULL) {
					// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃÂ¿Â´Â´Ã™.
					if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
						// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.

						// v1.411 Â·ÃŽÂ±Ã— Â³Â²Â±Ã¤Â´Ã™.
						_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) - 1, pItem);

						dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
						*dwp = MSGID_NOTIFY;
						wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
						*wp = DEF_NOTIFY_ITEMOBTAINED;

						cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

						// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. <- Â¿Â©Â±Ã¢Â¼Â­ 1Â°Â³Â¶Ãµ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â¸Â»Ã‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™
						*cp = 1;
						cp++;

						memcpy(cp, pItem->m_cName, 20);
						cp += 20;

						dwp = (DWORD *) cp;
						*dwp = pItem->m_dwCount;
						cp += 4;

						*cp = pItem->m_cItemType;
						cp++;

						*cp = pItem->m_cEquipPos;
						cp++;

						*cp = (char) 0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·ÃŽ Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
						cp++;

						sp = (short *) cp;
						*sp = pItem->m_sLevelLimit;
						cp += 2;

						*cp = pItem->m_cGenderLimit;
						cp++;

						wp = (WORD *) cp;
						*wp = pItem->m_wCurLifeSpan;
						cp += 2;

						wp = (WORD *) cp;
						*wp = pItem->m_wWeight;
						cp += 2;

						sp = (short *) cp;
						*sp = pItem->m_sSprite;
						cp += 2;

						sp = (short *) cp;
						*sp = pItem->m_sSpriteFrame;
						cp += 2;

						*cp = pItem->m_cItemColor;
						cp++;

						*cp = (char) pItem->m_sItemSpecEffectValue2; // v1.41
						cp++;

						dwp = (DWORD *) cp;
						*dwp = pItem->m_dwAttribute;
						cp += 4;
						/*
						 *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃŽÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃŽ
						cp++;
						 */

						if (iEraseReq == 1) delete pItem;

						// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃÂ°Ã­Â³Â­ ÃˆÃ„ Â³Â²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â¸Â°Â´Ã™.
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
								  dX, dY, sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4

						// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã›
						iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);

						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								// Â¸ÃžÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
								DeleteClient(iClientH, TRUE, TRUE);
								return;
						}
					} else {
						// Â°Ã¸Â°Â£Ã€ÃŒ ÂºÃŽÃÂ·Ã‡ÃÂ°Ã…Â³Âª Ã‡Ã‘Â°Ã¨ÃÃŸÂ·Â®Ã€Â» ÃƒÃŠÂ°ÃºÃ‡ÃŸÂ´Ã™. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.

						// Â°Â¡ÃÂ®Â¿Ã”Â´Ã¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¿Ã¸Â»Ã³ÃˆÂ¸ÂºÂ¹Â½ÃƒÃ…Â²Â´Ã™.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

						dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
						*dwp = MSGID_NOTIFY;
						wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
						*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;

						iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								// Â¸ÃžÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
								DeleteClient(iClientH, TRUE, TRUE);
								return;
						}
					}
				}
				//
				break;

			case DEF_MAGICTYPE_CONFUSE:
				// if the caster side is the same as the targets side, no effect occurs
				switch (m_pMagicConfigList[sType]->m_sValue4) {
					case 1: // confuse LanguageÃ¬ÂÂ´Ã«â€¹Â¤.
					case 2: // Confusion, Mass Confusion
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								// Ã¬Å¾ÂÃ¬â€¹Â Ã«Ââ€ž Ã­â€Â¼Ã­ÂÂ­Ã«ÂÂ  Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã¬Å“Â¼Ã«â€¹Ë† Ã¬Â£Â¼Ã¬ÂËœ.
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
									// Ã­â€¢Â´Ã«â€¹Â¹ Ã¬Å“â€žÃ¬Â¹ËœÃ¬â€”Â Ã¬ÂºÂÃ«Â¦Â­Ã­â€žÂ°ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤.
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										// Ã¬Æ’ÂÃ«Å’â‚¬Ã«Â°Â©Ã¬ÂÂ´ Ã«Â§Ë†Ã«Â²â€¢ Ã¬Â â‚¬Ã­â€¢Â­Ã¬â€”Â Ã¬â€¹Â¤Ã­Å’Â¨Ã­â€“Ë†Ã«â€¹Â¤.
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //Ã¬ÂÂ´Ã«Â¯Â¸ Ã«â€¹Â¤Ã«Â¥Â¸ ConfuseÃ­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤Ã«Â©Â´ Ã«Â¬Â´Ã¬â€¹Å“Ã«ÂÅ“Ã«â€¹Â¤.
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char) m_pMagicConfigList[sType]->m_sValue4;

										// Ã­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã­â€¢Â´Ã¬Â Å“Ã«ÂÂ  Ã«â€¢Å’ Ã«Â°Å“Ã¬Æ’ÂÃ­â€¢Â  Ã«â€Å“Ã«Â Ë†Ã¬ÂÂ´ Ã¬ÂÂ´Ã«Â²Â¤Ã­Å Â¸Ã«Â¥Â¼ Ã«â€œÂ±Ã«Â¡ÂÃ­â€¢Å“Ã«â€¹Â¤.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

										// Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â ÃªÂ±Â¸Ã«Â Â¸Ã¬ÂÅ’Ã¬Ââ€ž Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
									}
								}
							}
						break;

					case 3: // Ilusion, Mass-Ilusion
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								// Ã¬Å¾ÂÃ¬â€¹Â Ã«Ââ€ž Ã­â€Â¼Ã­ÂÂ­Ã«ÂÂ  Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã¬Å“Â¼Ã«â€¹Ë† Ã¬Â£Â¼Ã¬ÂËœ.
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
									// Ã­â€¢Â´Ã«â€¹Â¹ Ã¬Å“â€žÃ¬Â¹ËœÃ¬â€”Â Ã¬ÂºÂÃ«Â¦Â­Ã­â€žÂ°ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤.
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										// Ã¬Æ’ÂÃ«Å’â‚¬Ã«Â°Â©Ã¬ÂÂ´ Ã«Â§Ë†Ã«Â²â€¢ Ã¬Â â‚¬Ã­â€¢Â­Ã¬â€”Â Ã¬â€¹Â¤Ã­Å’Â¨Ã­â€“Ë†Ã«â€¹Â¤.
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //Ã¬ÂÂ´Ã«Â¯Â¸ Ã«â€¹Â¤Ã«Â¥Â¸ ConfuseÃ­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã¬Å¾Ë†Ã«â€¹Â¤Ã«Â©Â´ Ã«Â¬Â´Ã¬â€¹Å“Ã«ÂÅ“Ã«â€¹Â¤.
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char) m_pMagicConfigList[sType]->m_sValue4;

										switch (m_pMagicConfigList[sType]->m_sValue4) {
											case 3:
												SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
												break;
										}

										// Ã­Å¡Â¨ÃªÂ³Â¼ÃªÂ°â‚¬ Ã­â€¢Â´Ã¬Â Å“Ã«ÂÂ  Ã«â€¢Å’ Ã«Â°Å“Ã¬Æ’ÂÃ­â€¢Â  Ã«â€Å“Ã«Â Ë†Ã¬ÂÂ´ Ã¬ÂÂ´Ã«Â²Â¤Ã­Å Â¸Ã«Â¥Â¼ Ã«â€œÂ±Ã«Â¡ÂÃ­â€¢Å“Ã«â€¹Â¤.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

										// Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â ÃªÂ±Â¸Ã«Â Â¸Ã¬ÂÅ’Ã¬Ââ€ž Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤.
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
									}
								}
							}
						break;

					case 4: // Ilusion Movement
						if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break;
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char) m_pMagicConfigList[sType]->m_sValue4;

										switch (m_pMagicConfigList[sType]->m_sValue4) {
											case 4:
												//para que los del mismo pueblo no se den con illusion movement by KahBur
												if ((strcmp(m_pClientList[sOwnerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation)) == 0) goto MAGIC_NOEFFECT;
												if ((m_pClientList[iClientH]->m_bIsPlayerCivil == FALSE) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == TRUE)) goto MAGIC_NOEFFECT;
												SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
												break;
										}

										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
									}
								}
							}
						break;
				}
				break;

			case DEF_MAGICTYPE_POISON:
				// ÃÃŸÂµÂ¶ Â¸Â¶Â¹Ã½. Â¸Ã•Ã€Ãº Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€Â» Â±Â¼Â¸Â®Â°Ã­ Â´Ã™Ã€Â½Ã€Â¸Â·ÃŽ ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Ã‡Ã‘Â¹Ã¸ Â´Ãµ Â±Â¼Â¸Â°Â´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
					// ÃÃŸÂµÂ¶Ã€Â» Â°Ã…Â´Ã‚ Â¸Â¶Â¹Ã½
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							// v1.4334 ÃÃŸÂ¸Â³Ã€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” ÃÃŸÂµÂ¶Ã€Â» Â¸Ã¸Ã‡ÃÂ°Ã” Â¼Ã¶ÃÂ¤
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

							// Â¹Ã¼ÃÃ‹Ã‡Ã Ã€Â§Â¶Ã³Â¸Ã©
							bAnalyzeCriminalAction(iClientH, dX, dY);

							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™. ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
								if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
									// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÂ´Ã™.
									m_pClientList[sOwnerH]->m_bIsPoisoned = TRUE;
									m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
									m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
									// 05/06/2004 - Hypnotoad - poison aura appears when cast Poison
									SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
									// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
#ifdef DEF_TAIWANLOG
									_bItemLog(DEF_ITEMLOG_POISONED, sOwnerH, (char *) NULL, NULL);
#endif
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_iHP > 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™. ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
								if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
									// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÂ´Ã™.

								}
							}
							break;
					}
				} else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
					// ÃÃŸÂµÂ¶Ã€Â» Ã‡ÂªÂ´Ã‚ Â¸Â¶Â¹Ã½
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

							if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
								// ÃÃŸÂµÂ¶ÂµÃˆ Â»Ã³Ã…Ã‚Â¿Â´Â´Ã™Â¸Ã© ÃÃŸÂµÂ¶Ã€Â» Ã‡Â¬Â´Ã™.
								m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
								// 05/06/2004 - Hypnotoad - poison aura removed when cure cast
								SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
								// ÃÃŸÂµÂ¶Ã€ÃŒ Ã‡Â®Â·ÃˆÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							break;
					}
				}
				break;

			case DEF_MAGICTYPE_BERSERK:
				switch (m_pMagicConfigList[sType]->m_sValue4) {
					case 1:
						// Â¹Ã¶Â¼Â­Ã„Â¿ Â¸Ã°ÂµÃ¥Â·ÃŽ Ã€Ã¼ÃˆÂ¯ÂµÃˆÂ´Ã™.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char) m_pMagicConfigList[sType]->m_sValue4;
								SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
								// ÃÂ¤Ã€Ã» NPCÂµÃ©Ã€Âº Â±Â¤ÂºÃ Â¾ÃˆÂµÃŠ
								if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
								// 2002-09-11 #3 Ã€Ã» Â¸Ã³Â½ÂºÃ…ÃÂ´Ã‚ Â±Â¤ÂºÃÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Â½
								if (m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;

								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char) m_pMagicConfigList[sType]->m_sValue4;
								SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
								break;
						}

						// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;
				}
				break;

				// v2.16 2002-5-23 Â°Ã­Â±Â¤Ã‡Ã¶ Â¼Ã¶ÃÂ¤
			case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {

							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
						}
					}
				break;
				/*						// Resurrection Magic.
								case DEF_MAGICTYPE_RESURRECTION:
									// 10 Mins once
									if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
									m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC/2;
									// Get the ID of the dead Player/NPC on coords dX, dY.
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
									switch (cOwnerType) {
												// For Player.
										case DEF_OWNERTYPE_PLAYER:
											// The Player has to exist.
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// Resurrection is not for alive Players.
											if (m_pClientList[sOwnerH]->m_bIsKilled == FALSE) goto MAGIC_NOEFFECT;
											// Set Deadflag to Alive.
											m_pClientList[sOwnerH]->m_bIsKilled = FALSE;
											// Player's HP becomes half of the Max HP.
											m_pClientList[sOwnerH]->m_iHP = ((m_pClientList[sOwnerH]->m_iLevel * 2) + (m_pClientList[sOwnerH]->m_iVit * 3) + (m_pClientList[sOwnerH]->m_iStr / 2)) / 2;
											// Send new HP to Player.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
											// Make Player stand up. (Currently, by a fake damage).
											m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->ClearDeadOwner(dX, dY);
											m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->SetOwner(sOwnerH, DEF_OWNERTYPE_PLAYER, dX, dY);
											SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, NULL, NULL, NULL);
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
											break;
											// Resurrection is not for NPC's.
										case DEF_OWNERTYPE_NPC:
											goto MAGIC_NOEFFECT;
											break;
									}
									break;*/

			case DEF_MAGICTYPE_ICE:
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							// Â´Ã«Â¹ÃŒÃÃ¶Â¿Ã Ã‡Ã”Â²Â²
							//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Â´Ã«Â»Ã³Ã€ÃŒ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€ÃŽ Â°Ã¦Â¿Ã¬ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}

						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

								//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº. ÃÃ—ÃÃ¶ Â¾ÃŠÂ¾Ã’Ã€Â¸Â¸Ã© Ã€Ã»Â¿Ã«
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												  sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
							}
						}
					}
				break;

			default:
				break;
		}
	} else {
		// Casting ÃˆÃ„ ÂµÃ´Â·Â¹Ã€ÃŒÂ°Â¡ Â°Ã‰Â¸Â®Â´Ã‚ Â¸Â¶Â¹Ã½
		// Resurrection wand(MS.10) or Resurrection wand(MS.20)

		if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION) {
			//Check if player has resurrection wand
			if (m_pClientList[iClientH] != NULL && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
					  m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == FALSE) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (m_pClientList[sOwnerH] != NULL) {
					// GM's can ressurect ne1, and players must be on same side to ressurect
					/*if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]]->m_sIDnum != 865) ||
						(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]]->m_sIDnum != 866)) {
						wsprintf(G_cTxt, "(!!!) Hack: Player(%s) cast resurrect without wand!", m_pClientList[iClientH]->m_cCharName);
						PutLogList(G_cTxt);
						DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
						return;
					}*/


					if ((m_pClientList[iClientH]->m_iAdminUserLevel < 1) &&
							  (m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						return;
					}
					if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != NULL &&
							  m_pClientList[sOwnerH]->m_iHP <= 0) {
						m_pClientList[sOwnerH]->m_bIsBeingResurrected = TRUE;
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
						if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
							m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = TRUE;
							m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
							m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
							m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

							sTemp = m_pClientList[iClientH]->m_sAppr4;
							sTemp = 0xFF0F & sTemp;
							sTemp = sTemp | 0x40;
							m_pClientList[iClientH]->m_sAppr4 = sTemp;
						}
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
						SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}
			}
		}
	}

MAGIC_NOEFFECT:
	;

	if (m_pClientList[iClientH] == NULL) return;

	//Mana Slate
	if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
		iManaCost = 0;
	}

	// ManaÂ¸Â¦ Â°Â¨Â¼Ã’Â½ÃƒÃ…Â°Â°Ã­ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
	m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1Ã€ÃŒ Mana Cost
	if (m_pClientList[iClientH]->m_iMP < 0)
		m_pClientList[iClientH]->m_iMP = 0;

	CalculateSSN_SkillIndex(iClientH, 4, 1);

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);

	// Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°ÃºÂ¸Â¦ Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™. Â¸Â¶Â¹Ã½Â¹Ã¸ÃˆÂ£ + 100Ã€ÃŒ Â¿Â¡Ã†Ã¥Ã†Â® Â¹Ã¸ÃˆÂ£
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
			  m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType + 100), m_pClientList[iClientH]->m_sType);

}

void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType) {
	short sOwnerH;
	char cOwnerType;
	register int i, iErr, ix, iy, sX, sY, tX, tY, iResult, iWhetherBonus, iMagicAttr;
	DWORD dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
			  (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;

	if ((sType < 0) || (sType >= 100)) return;
	if (m_pMagicConfigList[sType] == NULL) return;

	// �����ġ�� ��� �Ұ��� ���̶�� ��� �Ұ���
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;

	// ���� �� ���� ���߷� �Է�
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;

	// ������ ���� ���� ��ݷ� ����
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);

	// v1.41 ���� �Ӽ�
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// ��� ȿ�� ���� ����
		switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_INVISIBILITY:
				switch (m_pMagicConfigList[sType]->m_sValue4) {
					case 1:
						// ������ �ʴ� ���·� �����.
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char) m_pMagicConfigList[sType]->m_sValue4;
								SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
								// �� ĳ���͸� �����ϰ� �ִ� ���͸� ������Ų��.
								RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char) m_pMagicConfigList[sType]->m_sValue4;
								SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
								// �� NPC�� �����ϰ� �ִ� ���͸� ������Ų��.
								RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC);
								break;
						}

						// ȿ�� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;

					case 2:
						// dX, dY �ݰ� 8 �ֺ��� Invisibility ������ Object�� ������ ���� ��Ų��.
						for (ix = dX - 8; ix <= dX + 8; ix++)
							for (iy = dY - 8; iy <= dY + 8; iy++) {
								m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
												if (m_pClientList[sOwnerH]->m_sType != 66) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
												if (m_pClientList[sOwnerH]->m_sType != 66) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
											}
											break;
									}
								}
							}
						break;
				}
				break;

			case DEF_MAGICTYPE_HOLDOBJECT:
				// ������Ʈ�� �������� �����Ѵ�.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto NMH_NOEFFECT;
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char) m_pMagicConfigList[sType]->m_sValue4;
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; // v1.4 ���� ���� 6�̻��� ��ġ�� �̻��� ���� ���Ϳ��Դ� ���� ���� ������ �ʴ´�.
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char) m_pMagicConfigList[sType]->m_sValue4;
							break;
					}

					// ���� ȿ�� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
							  sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					// ȿ�� ������� �˷��ش�.
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				}
				break;


			case DEF_MAGICTYPE_DAMAGE_LINEAR:
				// ������ �� �ִ� ��ǥ�� ��� ����Ѵ�.
				sX = m_pNpcList[iNpcH]->m_sX;
				sY = m_pNpcList[iNpcH]->m_sY;

				for (i = 2; i < 10; i++) {
					iErr = 0;
					m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

					// tx, ty
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ���� ô�ϰ� �ִ� �÷��̾��.
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx-1, ty
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ���� ô�ϰ� �ִ� �÷��̾��.
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx+1, ty
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ���� ô�ϰ� �ִ� �÷��̾��.
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx, ty-1
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ���� ô�ϰ� �ִ� �÷��̾��.
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					// tx, ty+1
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							  (m_pClientList[sOwnerH]->m_iHP > 0)) {
						// ���� ô�ϰ� �ִ� �÷��̾��.
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
					}

					if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
				}

				// �ֺ� ��� ȿ��
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// �ڽŵ� ����� �� ������ ����.
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ���� ô�ϰ� �ִ� �÷��̾��.
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}

				// dX, dY
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						  (m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ���� ô�ϰ� �ִ� �÷��̾��.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				break;

			case DEF_MAGICTYPE_DAMAGE_SPOT:
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						  (m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ���� ô�ϰ� �ִ� �÷��̾��.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}
				break;

			case DEF_MAGICTYPE_HPUP_SPOT:
				// �� ������ ���߷��� ����� ���.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				break;

			case DEF_MAGICTYPE_PURITYLIFE_SPOT:
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				PURITYLIFE(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA:
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						  (m_pClientList[sOwnerH]->m_iHP > 0)) {
					// ���� ô�ϰ� �ִ� �÷��̾��.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
				}

				// �ֺ� ��� ȿ��
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// �ڽŵ� ����� �� ������ ����.
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ���� ô�ϰ� �ִ� �÷��̾��.
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
				break;

			case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
				// ������ ������� �ʴ´�.
				// �ֺ� ��� ȿ��
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// �ڽŵ� ����� �� ������ ����.
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								  (m_pClientList[sOwnerH]->m_iHP > 0)) {
							// ���� ô�ϰ� �ִ� �÷��̾��.
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
				break;

			case DEF_MAGICTYPE_SPDOWN_AREA:
				// Sp�� �پ���.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				// �ֺ� ��� ȿ��
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// �ڽŵ� ����� �� ������ ����.
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				break;

			case DEF_MAGICTYPE_SPUP_AREA:
				// Sp�� ����Ѵ�.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				// ���� ������ �ʿ���.
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				// �ֺ� ��� ȿ��
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// �ڽŵ� ����� �� ������ ����.
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						// ���������� �ʿ� ���.
						Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
				break;

		}
	} else {
		// Casting �� �����̰� �ɸ��� ����

	}

NMH_NOEFFECT:
	;

	// Mana�� ���ҽ�Ų��.
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1�� Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0)
		m_pNpcList[iNpcH]->m_iMana = 0;

	// ���� ȿ�� �ٸ� Ŭ���̾�Ʈ���� ����Ѵ�. �����ȣ + 100�� ����Ʈ ��ȣ
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
			  m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType + 100), m_pNpcList[iNpcH]->m_sType);

}

void CGame::RequestTeleportHandler(int iClientH, const char * pData, const char * cMapName, int dX, int dY) {
	char * pBuffer, cTempMapName[21];
	DWORD * dwp;
	WORD * wp;
	char * cp, cDestMapName[11], cDir, cMapIndex, cQuestRemain;
	short * sp, sX, sY, sSummonPoints;
	int * ip, i, iRet, iSize, iDestX, iDestY, iExH, iMapSide;
	BOOL bRet, bIsLockedMapNotify;
	SYSTEMTIME SysTime;

	m_pClientList[iClientH]->m_dwLastActionTime = m_pClientList[iClientH]->m_dwAFKCheckTime = timeGetTime();
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
			  (m_pClientList[iClientH]->m_bIsKilled == FALSE) && (m_pClientList[iClientH]->m_iHP > 0)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NORECALL, NULL, NULL, NULL, NULL);
		return;
	}
	// v2.16 2002-6-2 ���� ���������� ������ ���� �ʴ´�.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
			  && (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
			  && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			  && ((pData[0] == '1') || (pData[0] == '3'))
			  && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			  && (m_bIsCrusadeMode == FALSE)) return;

	// v2.16 2002-6-2 ���� ���������� ������ ���� �ʴ´�.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0)
			  && (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
			  && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
			  && ((pData[0] == '1') || (pData[0] == '3'))
			  && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			  && (m_bIsCrusadeMode == FALSE)) return;

	bIsLockedMapNotify = FALSE;

	// ë§Œì•½ êµí™˜ ëª¨ë“œë¼ë©´ êµí™˜ì„ ì·¨ì†Œí•œë‹¤.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// ì¤‘ë¦½ì´ ë¦¬ì½œ ë§ˆë²•ì„ ì‚¬ìš©í•˜ë©´ íˆ¬ëª…í•˜ê²Œ ë˜ëŠ” ë²„ê·¸ ìˆ˜ì •
	// ì¤‘ë¦½ì´ë©´ ë¦¬ì½œ ë§ˆë²•ì„ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê²Œ ëœë‹¤.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
		return;

	// í˜„ìž¬ ì´ í”Œë ˆì´ì–´ë¥¼ ëª©í‘œë¡œ ì‚¼ê³  ìžˆëŠ” ëª¹ë“¤ì˜ ê³µê²©í–‰ë™ì„ ë©ˆì¶”ê²Œ í•œë‹¤.
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	// í˜„ìž¬ ë§µ ìœ„ì¹˜ì—ì„œ ì§€ìš´ë‹¤.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER,
			  m_pClientList[iClientH]->m_sX,
			  m_pClientList[iClientH]->m_sY);

	// ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ í”Œë ˆì´ì–´ê°€ í˜„ ìœ„ì¹˜ì—ì„œ ì‚¬ë¼ì§ì„ ì•Œë¦°ë‹¤.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

	// í˜„ìž¬ í…”ë ˆí¬íŠ¸ê°€ ë§ˆë²•ì— ì˜í•œ ê²ƒì¸ì§€, ì•„ë‹ˆë©´ ì¼ë°˜ì ì¸ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì— ì˜í•œ ê²ƒì¸ì§€ë¥¼ ì²´í¬í•œë‹¤.
	// ë§Œì•½ ì¼ë°˜ì ì¸ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì— ì˜í•œ ê²ƒì´ë¼ë©´ í…”ë ˆí¬íŠ¸í•  ìœ„ì¹˜ì˜ ë§µì´ë¦„, ì¢Œí‘œë¥¼ êµ¬í•´ì™€ì„œ
	// ê·¸ ë§µì´ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ëŠ”ì§€ë¥¼ ê²€ìƒ‰í•œë‹¤. ë§Œì•½ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ
	// ë‹¤ë¥¸ ì„œë²„ë¡œì˜ ì ‘ì†ì„ ì‹œë„í•˜ë¼ëŠ” ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ë‹¤.

	// ë¨¼ì € í”Œë ˆì´ì–´ê°€ ì„œìžˆëŠ” ìœ„ì¹˜ê°€ í…”ë ˆí¬íŠ¸ íƒ€ì¼ì¸ì§€ ì•Œì•„ë‚¸ë‹¤.
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	std::memset(cDestMapName, 0, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
		// ë§Œì•½ ê°ˆ ë§µì´ ê±´ë¬¼ ë‚´ë¶€ë¼ë©´
		iMapSide = iGetMapLocationSide(cDestMapName);
		if (iMapSide > 3) iMapSide -= 2; // New 18/05/2004
		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
			// ë“¤ì–´ê°€ê³ ìž í•˜ëŠ” ë§µì´ ê°™ì€ íŽ¸ì˜ ê±´ë¬¼ ë‚´ë¶€ë¼ë©´ ë“¤ì–´ê°ˆ ìˆ˜ ìžˆë‹¤.
		} else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			std::memset(cDestMapName, 0, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet == TRUE) && (cMapName == NULL)) {
		// í”Œë ˆì´ì–´ê°€ í…”ë ˆí¬íŠ¸ íƒ€ì¼ ìœ„ì— ì„œ ìžˆë‹¤. í…”ë ˆí¬íŠ¸ í•  ë§µì´ í˜„ìž¬ ì„œë²„ì— ì¡´ìž¬í•˜ëŠ”ì§€ ê²€ìƒ‰í•œë‹¤. ë¬¼ë¡  ëª©ì ì§€ê°€ ì§€ì •ë˜ì§€ ì•Šì€ í…”ë ˆí¬íŠ¸ì—¬ì•¼í•œë‹¤.
		for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
					// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.
					m_pClientList[iClientH]->m_sX = iDestX; // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
					m_pClientList[iClientH]->m_sY = iDestY;
					m_pClientList[iClientH]->m_cDir = cDir;
					m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
					std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10); // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
					goto RTH_NEXTSTEP;
				}
			}

		// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
		m_pClientList[iClientH]->m_sX = iDestX; // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
		m_pClientList[iClientH]->m_sY = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10); // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

		// New 18/05/2004
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
				  m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
		SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

		// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì €ìž¥í–ˆë‹¤ëŠ” ì‘ë‹µì´ ì˜¤ë©´ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì ‘ì†ì„ ë‹¤ì‹œ í• ê²ƒì„ ì•Œë ¤ì¤€ë‹¤.
		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
		// !!!!
		m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
		return;
	} else {
		// ë§ˆë²•ì— ì˜í•œ í…”ë ˆí¬íŠ¸ì´ë‹¤.
		switch (pData[0]) {
			case '0':
				// Forced Recall.
				// ë ˆë²¨ ì œí•œì´ ìžˆëŠ” ë§µì— ë“¤ì–´ê°”ì„ë•Œ ì¼ì–´ë‚œë‹¤.
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
					strcpy(cTempMapName, "default");
				} else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0) {
					strcpy(cTempMapName, "arefarm");
				} else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) {
					strcpy(cTempMapName, "elvfarm");
				} else strcpy(cTempMapName, m_pClientList[iClientH]->m_cLocation);

				// Crusade
				if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
					// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
					bIsLockedMapNotify = TRUE;
					std::memset(cTempMapName, 0, sizeof(cTempMapName));
					strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
				}

				for (i = 0; i < DEF_MAXMAPS; i++)
					if (m_pMapList[i] != NULL) {
						if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
							// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.
							GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

							m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
							std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
							memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10); // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
							goto RTH_NEXTSTEP;
						}
					}

				// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
				m_pClientList[iClientH]->m_sX = -1; // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
				m_pClientList[iClientH]->m_sY = -1; // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

				std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10); // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

				// New 18/05/2004
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
						  m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

				// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.

				m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;

			case '1':
				// Recall.í”Œë ˆì´ì–´ê°€ ì†Œì†ëœ ë§ˆì„ì˜ ì§„ìž… í¬ì¸íŠ¸ë¡œ ê°„ë‹¤.
				// ë§Œì•½ ë¶€í™œì¡´ì´ë¼ë©´ ë¦¬ì½œë˜ì§€ ì•ŠëŠ”ë‹¤.
				// if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;

				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
					strcpy(cTempMapName, "default");
				} else {
					// v2.14 ·¹º§ 80 ÀÌÇÏ´Â ¸®ÄÝ½Ã ³ó°æÁö·Î °£´Ù.
					if (m_pClientList[iClientH]->m_iLevel > 80)
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
							strcpy(cTempMapName, "aresden");
						else strcpy(cTempMapName, "elvine");
					else {
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
							strcpy(cTempMapName, "aresden");
						else strcpy(cTempMapName, "elvine");
					}
				}
				// Crusade
				if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
					// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
					bIsLockedMapNotify = TRUE;
					std::memset(cTempMapName, 0, sizeof(cTempMapName));
					strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
				}

				for (i = 0; i < DEF_MAXMAPS; i++)
					if (m_pMapList[i] != NULL) {
						if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
							// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸í•  ë§µì´ ì¡´ìž¬í•œë‹¤.

							GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

							m_pClientList[iClientH]->m_cMapIndex = i; // ë§µ ì¸ë±ìŠ¤ë¥¼ ë°”ê¾¼ë‹¤.
							std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
							memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10); // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
							goto RTH_NEXTSTEP;
						}
					}

				// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
				m_pClientList[iClientH]->m_sX = -1; // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
				m_pClientList[iClientH]->m_sY = -1; // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

				std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10); // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.

				// New 18/05/2004
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
						  m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

				// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;

			case '2':
				// ëª©ì ì§€ê°€ ì§€ì •ëœ í…”ë ˆí¬íŠ¸.

				// Crusade
				if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
					// íŠ¹ì • ë§µì— ê°–ížŒ ìƒíƒœì´ë‹¤. í…”ë ˆí¬íŠ¸ íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ê°–ížŒ ë§µìœ¼ë¡œ ë³€í˜•í•œë‹¤.
					dX = -1;
					dY = -1;
					bIsLockedMapNotify = TRUE;
					std::memset(cTempMapName, 0, sizeof(cTempMapName));
					strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
				} else {
					std::memset(cTempMapName, 0, sizeof(cTempMapName));
					strcpy(cTempMapName, cMapName);
				}

				cMapIndex = iGetMapIndex(cTempMapName);
				if (cMapIndex == -1) {
					// í˜„ìž¬ ì„œë²„ì— ëª©ì ì§€ê°€ ì—†ë‹¤.
					// í˜„ìž¬ ì„œë²„ì— í…”ë ˆí¬íŠ¸ í•  ë§µì´ ì—†ë‹¤. í´ë¼ì´ì–¸íŠ¸ëŠ” í˜„ìž¬ ì ‘ì†ì„ ì¢…ë£Œí•˜ê³  ë‹¤ë¥¸ ì„œë²„ë¡œ ì ‘ì†ì„ ì‹œë„í•´ì•¼ í•œë‹¤.
					m_pClientList[iClientH]->m_sX = dX; //-1;	  // í…”ë ˆí¬íŠ¸ ì¢Œí‘œë¥¼ ìž…ë ¥í•œë‹¤.
					m_pClientList[iClientH]->m_sY = dY; //-1;	  // -1ì€ InitialPointë¥¼ ë§í•œë‹¤.

					std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10); // ë§µ ì´ë¦„ì„ ë°”ê¾¼ë‹¤.
					// í”Œë ˆì´ì–´ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ê³  ì‘ë‹µì„ ë°›ì€ í›„ ìž¬ì ‘ì†ì„ ì•Œë ¤ì•¼ í•œë‹¤.

					// New 18/05/2004
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
							  m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
					SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! ì¹´ìš´íŒ… í•˜ì§€ ì•ŠëŠ”ë‹¤.
					// !!!
					m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
					m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
					return;
				}

				m_pClientList[iClientH]->m_sX = dX;
				m_pClientList[iClientH]->m_sY = dY;
				m_pClientList[iClientH]->m_cMapIndex = cMapIndex;

				std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);
				break;
		}
	}

RTH_NEXTSTEP:
	;

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	// Crusade
	if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);

	pBuffer = new char [DEF_MSGBUFFERSIZE + 1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE + 1);

	// ë§µë°ì´í„°ë¥¼ ì „ì†¡í•œë‹¤.
	dwp = (DWORD *) (pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp = DEF_MSGTYPE_CONFIRM;

	cp = (char *) (pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë¥¼ í™•ì •í•œë‹¤.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ì „ì†¡í•  ë§µ ë°ì´í„°ì˜ ê¸°ì¤€ìœ„ì¹˜. í”Œë ˆì´ì–´ëŠ” ê¸°ì¤€ìœ„ì¹˜ (x, y)ë¡œë¶€í„° (x+14, y+12)ì— ìœ„ì¹˜í•œë‹¤.
	sp = (short *) cp;
	*sp = iClientH; // Player ObjectID
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp = (short *) cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	// v1.4 ApprColor
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4; //Original 2

	// (!) í”Œë ˆì´ì–´ê°€ ìœ„ì¹˜í•˜ëŠ” ë§µì´ë¦„ì„ ê¸°ë¡í•œë‹¤.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// ëª…ì¹­ìƒì˜ ë§µ ì´ë¦„ì„ ìž…ë ¥í•œë‹¤.
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// ì£¼ì•¼ê°„ ëª¨ë“œë¥¼ ì‚½ìž…
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// ê¸°ìƒ ìƒíƒœ ëª¨ë“œë¥¼ ì‚½ìž…
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)
		*cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ í”Œë ˆì´ì–´ë¥¼ ë§µìƒì— ìµœì´ˆë¡œ ìœ„ì¹˜ì‹œí‚¨ë‹¤.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
				  DEF_OWNERTYPE_PLAYER,
				  m_pClientList[iClientH]->m_sX,
				  m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char) m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *) cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	//Unknown variable
	*cp = 0;
	cp++;

	// ë§µì˜ ì •ë³´ë¥¼ ì¶”ê°€í•œë‹¤.
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp);
	// ë©”ì‹œì§€ ì „ì†¡
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize + 4 + 4 + 1 + 4 + 4 + 3); //Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ë•Œ ì—ëŸ¬ê°€ ë°œìƒí–ˆë‹¤ë©´ ì œê±°í•œë‹¤.
			DeleteClient(iClientH, TRUE, TRUE);
			if (pBuffer != NULL) delete pBuffer;
			return;
	}

	if (pBuffer != NULL) delete pBuffer;

	// ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ í”Œë ˆì´ì–´ê°€ ìƒˆë¡œìš´ ìœ„ì¹˜ì— ë‚˜íƒ€ë‚¬ìŒì„ ì•Œë¦°ë‹¤.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) &&
			  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) &&
			  (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// New 17/05/2004
		CheckForceRecallTime(iClientH);
	} else if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) &&
			  (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) &&
			  (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// New 17/05/2004
		CheckForceRecallTime(iClientH);
	} else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		SetForceRecallTime(iClientH);

		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 20 * 60 - ((SysTime.wHour % 2)*20 * 60 + SysTime.wMinute * 20) - 2 * 20;

	} else {
		m_pClientList[iClientH]->m_bIsWarLocation = FALSE;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		SetForceRecallTime(iClientH);
	}

	// No entering enemy shops
	int iMapside, iMapside2;

	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideOwnTown = FALSE;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideOwnTown = TRUE;
			}
		}
	} else {
		if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone == TRUE &&
				  m_iFightzoneNoForceRecall == FALSE &&
				  m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2)*20 * 60 + SysTime.wMinute * 20) - 2 * 20;
		} else {
			if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "arejail", 7) == 0 ||
					  memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "elvjail", 7) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
					else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
				}
			}
		}
	}

	// ì¶”ê°€ë¡œ ë³´ë‚´ì¤˜ì•¼ í•  ì •ë³´ë¥¼ ë³´ë‚¸ë‹¤. v1.1
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	// v1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	// V1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	// v1.4
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

	// Crusade íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ CrusadeGUIDì§¸ì§• 0 íšŠì§š?ì¨˜ íš‰ì² ?ì±Œì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ì±• íš„ì¨€?ì© íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì¨ˆíš‚ ì§¸íš’?íš‘ì¨ˆíš¢. íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• 0?íš‘ì¨‹ì²œ ì§¸íš’?ì¨˜ íš„ì¨€?ì© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì©”ì§• ì¨‰ì±•ì©ì±¤ì©”íššì¨ˆíš¢ì¨ˆíš‚ ?íš‰ì¨”íš‘. ì©”ì§§íš‰íš˜ íš„íšŽì§¹ì°½íšŠì§¯.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		} else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…ì¨ì±¨ì¨‰ì±…?íš‘ì§¸ì±  íš‰íš„ì¨Œì¨”?íš‘ì©ì±¤?íš‰ GUIDì§¸ì§• íš‰ì² ?ì±Œ íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì©íšˆ?íš‘ì¨‰ì±¨ì©”íš’ ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢ì¨ˆíš‚ ì§¸íš’?ì¨˜ ?ì²¬ì¨”ì²©ì©”ì§• ì¨”ì²¬ì©ì±¤íšì¨€ì¨ˆì²© íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±…?íš‰ ì§¸ì°¼ì§¸ì²¬?íš‘ì¨ˆíš¢.
			// ?íš‘ì¨Œì§¹ ì§¸ì±ˆì©”ì±™ ?ì²´ì§¸ì²©ì©”ì§• ì¨‰ì²­ì¨ì§œ íšˆì²¨ì¨©ì²˜?ì¨© íš‰íš˜ ì©Œì²  ì©ì²©ì¨ˆíš¢. íš„íšœì©Œíš˜íš‰íš— íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… ì¨ì±¨ì¨‰ì±…ì§¸ì§• íšì©ì¨Œì°¼ì¨‰íšŠ ì¨ˆíš¢?ì© ì¨ˆíš¢?ì© ?ì²´ì¨ì±•?ì²´?íš‘ ì©íš„?íš¤ì¨‰íš‰ì§¹ì°½ ?ì²´ì©”ì§• íšì§–ì©Œíš™?ì¨© íš‰íš ì©íš© íšˆì²¨ì¨©ì²˜?ì¨© ì©ì±µ?ì¨© ì©Œì²  ?íšœì¨ˆíš¢.
			// ?íš‘?ì²´ì©”ì§• íš‰íš˜ì¨ˆì±Œì¨‰íš‰ì©ì²¬ì¨ˆì²© ì©”ì§§íš‰íš˜, ì§¸íš‰ì©Œì¨€ íšˆì²¨?íš“íšˆì§°, ?ì²´?ì±¦ ì§¸ì²©íš‰ì±…ì¨‰ì¨‰ íš„íšŽì§¹ì°½íšŠì§¯.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// íš‡ì§¤ì¨Œì±Œì©Œì©Œ?íš‘ì¨‰ì±… GUIDì§¸ì§• ì¨ˆíš¢ì¨ì§™ì¨ˆíš¢. íšˆì²¨ì¨©ì²˜ ì¨˜íš˜ì§¸ì§•.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD) m_bIsCrusadeMode, NULL, 0, NULL, -1);
		}
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD) m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	} else if (m_bIsHeldenianMode == TRUE) {
		sSummonPoints = m_pClientList[iClientH]->m_iCharisma * 300;
		if (sSummonPoints > DEF_MAXSUMMONPOINTS) sSummonPoints = DEF_MAXSUMMONPOINTS;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) {
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
		} else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
		}
		m_pClientList[iClientH]->m_cVar = 2;
		if (m_bIsHeldenianMode == TRUE) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
		}
		if (m_bHeldenianInitiated == TRUE) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
		UpdateHeldenianStatus();
	} else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	} else {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_pClientList[iClientH]->m_cVar == 1) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD) m_bIsCrusadeMode, NULL, NULL, NULL, -1);
			}
		} else {
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}
	/*// Crusade í˜„ìž¬ í¬ë£¨ì„¸ì´ë“œ ëª¨ë“œì´ê³  í”Œë ˆì´ì–´ì˜ CrusadeGUIDê°€ 0 í˜¹ì€ í˜„ìž¬ì™€ ë‹¤ë¥´ë‹¤ë©´ ì²˜ìŒ í• ë‹¹ë˜ëŠ” ê²ƒì´ë‹¤. í¬ë£¨ì„¸ì´ë“œ ì—­í•  ì´ˆê¸°í™”.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// í¬ë£¨ì„¸ì´ë“œëª¨ë“œì´ê³  í”Œë ˆì´ì–´ì˜ GUIDê°€ 0ì´ëž€ ê²ƒì€ ì²˜ìŒ í¬ë£¨ì„¸ì´ë“œ ëª¨ë“œì— ë“¤ì–´ì™”ë‹¤ëŠ” ì˜ë¯¸. ì—­í•  ì´ˆê¸°í™”.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// í¬ë£¨ì„¸ì´ë“œëª¨ë“œì´ê³  í”Œë ˆì´ì–´ì˜ GUIDê°€ í˜„ìž¬ í¬ë£¨ì„¸ì´ë“œ ì•„ì´ë””ì™€ ë‹¤ë¥´ë‹¤ëŠ” ê²ƒì€ ì €ë²ˆì— ë²Œì–´ì¡Œë˜ í¬ë£¨ì„¸ì´ë“œì˜ ê²°ê³¼ì´ë‹¤.
			// ì´ëŸ° ê²½ìš° ì „ê³µì— ë”°ë¥¸ í¬ìƒì„ í•  ìˆ˜ ì—†ë‹¤. ìµœì†Œí•œ í¬ë£¨ì„¸ì´ë“œ ëª¨ë“œê°€ ì¢…ë£Œëœ ë‹¤ìŒ ë‹¤ìŒ ì „ë©´ì „ì´ ì‹œìž‘ë˜ê¸° ì „ì— ì ‘ì†ì„ í•´ì•¼ í¬ìƒì„ ì–»ì„ ìˆ˜ ìžˆë‹¤.
			// ì´ì „ì— í• ë‹¹ë˜ì—ˆë˜ ì—­í• , ê±´ì„¤ í¬ì¸íŠ¸, ì „ìŸ ê³µí—Œë„ ì´ˆê¸°í™”.
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// í¬ë£¨ì„¸ì´ë“œ GUIDê°€ ë‹¤ë¥´ë‹¤. í¬ìƒ ë¶ˆê°€.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		// í¬ë£¨ì„¸ì´ë“œ ëª¨ë“œê°€ ì•„ë‹Œ ê²½ìš° ì—­í• ê³¼ ê³µí—Œ í¬ì¸íŠ¸ë§Œ ì´ˆê¸°í™”. ì „ìŸ ê³µí—Œë„ëŠ” ìž ì‹œí›„ì— ê³„ì‚°ë˜ì–´ì„œ í¬ìƒëœë‹¤.
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}
		else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			// í¬ë£¨ì„¸ì´ë“œ GUIDê°€ ë‹¤ë¥´ë‹¤. í¬ìƒ ë¶ˆê°€.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}*/

	// v1.42
	// 2002-7-4 Â»Ã§Ã…ÃµÃ€Ã¥Ã€Ã‡ Â°Â¹Â¼Ã¶Â¸Â¦ Â´ÃƒÂ¸Â± Â¼Ã¶ Ã€Ã–ÂµÂµÂ·Ã
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);

	// v2.15
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

	if (m_bIsHeldenianMode == TRUE) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
		if (m_bHeldenianInitiated == TRUE) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
		} else {
			UpdateHeldenianStatus();
		}
	}

	if (m_pClientList[iClientH]->m_iQuest != NULL) {
		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
		_bCheckIsQuestCompleted(iClientH);
	}

}

void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType) {
	register int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
		if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
			if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
					  (m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
					  (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {

				m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
			}
		}
}

BOOL CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize) {
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int iMagicConfigListIndex = 0;
	class CStrTok * pStrTok;

	pContents = new char[dwMsgSize + 1];
	ZeroMemory(pContents, dwMsgSize + 1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
						case 1:
							// ¸¶¹ý ¹øÈ£
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							if (m_pMagicConfigList[atoi(token)] != NULL) {
								// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[atoi(token)] = new class CMagic;
							iMagicConfigListIndex = atoi(token);

							cReadModeB = 2;
							break;

						case 2:
							// ¸¶¹ý ÀÌ¸§
							std::memset(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, 0, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
							memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
							cReadModeB = 3;
							break;

						case 3:
							// ¸¶¹ý Á¾·ù m_sType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// ¸¶¹ý µô·¹ÀÌ ½Ã°£ m_dwDelayTime
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// ¸¶¹ý Áö¼Ó½Ã°£ m_dwLastTime
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							// m_sValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
							cReadModeB = 7;
							break;

						case 7:
							// m_sValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
							cReadModeB = 8;
							break;

						case 8:
							// m_sValue3
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
							cReadModeB = 9;
							break;

						case 9:
							// m_sValue4
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
							cReadModeB = 10;
							break;

						case 10:
							// m_sValue5
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
							cReadModeB = 11;
							break;

						case 11:
							// m_sValue6
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
							cReadModeB = 12;
							break;

						case 12:
							// m_sValue7
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
							cReadModeB = 13;
							break;

						case 13:
							// m_sValue8
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
							cReadModeB = 14;
							break;

						case 14:
							// m_sValue9
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
							cReadModeB = 15;
							break;

						case 15:
							// m_sValue10
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
							cReadModeB = 16;
							break;

						case 16:
							// m_sValue11
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
							cReadModeB = 17;
							break;

						case 17:
							// m_sValue12
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
							cReadModeB = 18;
							break;

						case 18:
							// m_sIntLimit
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
							cReadModeB = 19;
							break;

						case 19:
							// m_iGoldCost
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);

							cReadModeB = 20;
							break;

						case 20:
							// m_cCategory
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
							cReadModeB = 21;
							break;

						case 21:
							// m_iAttribute
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				default:
					break;
			}
		} else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return TRUE;

}

BOOL CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize) {
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int iSkillConfigListIndex = 0;
	class CStrTok * pStrTok;

	pContents = new char[dwMsgSize + 1];
	ZeroMemory(pContents, dwMsgSize + 1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
						case 1:
							// ½ºÅ³ ¹øÈ£
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							if (m_pSkillConfigList[atoi(token)] != NULL) {
								// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[atoi(token)] = new class CSkill;
							iSkillConfigListIndex = atoi(token);

							cReadModeB = 2;
							break;

						case 2:
							// ½ºÅ³ ÀÌ¸§
							std::memset(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, 0, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
							memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
							cReadModeB = 3;
							break;

						case 3:
							// ½ºÅ³ Á¾·ù m_sType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// m_sValue1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// m_sValue2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							// m_sValue3
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
							cReadModeB = 7;
							break;

						case 7:
							// m_sValue4
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
							cReadModeB = 8;
							break;

						case 8:
							// m_sValue5
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
							cReadModeB = 9;
							break;

						case 9:
							// m_sValue6
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				default:
					break;
			}
		} else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

// 12-22 ���Ĵ� ����  ������⿡ ������ ������ Ŭ���̾�Ʈ�� �����ش�.

void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL bIsPurchase) {
	char * cp, cMagicName[31], cData[100];
	DWORD * dwp, dwGoldCount;
	WORD * wp;
	int * ip, iReqInt, iCost, iRet;
	BOOL bMagic = TRUE;
	int iTempInt;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// ������ ����.
	std::memset(cData, 0, sizeof(cData));

	std::memset(cMagicName, 0, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);

	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// �̷� �̸��� ������ �������� �ʴ´�. �����Ѵ�.

	} else {
		if (bIsPurchase == TRUE) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE; // �Ϲ������� ���� ��� �����̶��(������ ����) ��� �� ���.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD) iCost > dwGoldCount) bMagic = FALSE; // ���� �����ص� ��� �� ���.
		}

		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;
		iTempInt = m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt;
		if ((iReqInt <= iTempInt) && (bMagic == TRUE)) {

			// ���� ��������� �˸���.
			if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);

			// ����ǰ �� �߷� �� ���
			iCalcTotalWeight(iClientH);

			// ���� ��� �ɷ� ǥ�� .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;

			// ������ ���ٴ� �޽����� ����Ѵ�.
			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

			// ���� ��ȣ
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			// ���� ���
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		} else {
			// ������ �������� �ʾ� ������ ��� �� ���.
			// ������ ���� ���ٴ� �޽����� ����Ѵ�.
			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_MAGICSTUDYFAIL;

			cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);
			// ��������.
			*cp = 1;
			cp++;

			// ���� ��ȣ
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *) cp;
			*ip = iCost;
			cp += 4;

			ip = (int *) cp;
			*ip = iReqInt;
			cp += 4;

			// ���� ���
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
	}
}

int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost) {
	register int i;
	char cTmpName[31];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
				// °°Àº ÀÌ¸§À» °¡Áø ¸¶¹ý ¼³Á¤À» Ã£¾Ò´Ù. ¸¶¹ý ¹øÈ£¸¦ ¹ÝÈ¯ÇÑ´Ù.
				*pReqInt = (int) m_pMagicConfigList[i]->m_sIntLimit;
				*pCost = (int) m_pMagicConfigList[i]->m_iGoldCost;

				return i;
			}
		}

	return -1;
}

void CGame::TrainSkillResponse(BOOL bSuccess, int iClientH, int iSkillNum, int iSkillLevel) {
	char * cp, cData[100];
	DWORD * dwp;
	WORD * wp;
	int iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((iSkillNum < 0) || (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess == TRUE) {
		// �̹� ����� ���� ���¶�� �ҿ��� ���.
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;

		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		// ��� �� ���� �� ����Ѵ�.
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		// ����� ���ٴ� �޽����� ����Ѵ�.
		dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_NOTIFY_SKILLTRAINSUCCESS;

		cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

		// ����ȣ
		*cp = iSkillNum;
		cp++;

		// ��� ���� .
		*cp = iSkillLevel;
		cp++;

		//wsprintf(G_cTxt, "Skill Improve: (%s) increased (%s) at %s (%d,%d).", m_pClientList[iClientH]->m_cCharName, m_pSkillConfigList[iSkillNum]->m_cName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		//PutLogFileList(G_cTxt);

		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL)
			_bItemLog(DEF_ITEMLOG_SKILLLEARN, iClientH, m_pSkillConfigList[iSkillNum]->m_cName, NULL);

		// ���� ���
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}
	} else {


	}

	/*
	// ����� ����.
	std::memset(cData, 0, sizeof(cData));

	std::memset(cSkillName, 0, sizeof(cSkillName));
	memcpy(cSkillName, pName, 20);

	iRet = _iGetSkillNumber(cSkillName);
	if (iRet == 0) {
		// �̷� �̸��� ����� �������� �ʴ´�.

	}
	else {
		// Ŭ���̾�Ʈ�� iRet��° ����� ����� ���� ��, ���⿡ ����� �ɷ�ġ�� ���� �ִ��� �˻��Ѵ�.

		if (1) {
			// @@ Test������ �ϴ� ������ ����� �����ϰ� �����.
			m_pClientList[iClientH]->m_cSkillMastery[iRet]++;

			// ����� ���ٴ� �޽����� ����Ѵ�.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	 *dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	 *wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ��� ���� .
	 *cp = m_pClientList[iClientH]->m_cSkillMastery[iRet];
			cp++;

			// ����ȣ
	 *cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// ���� ���
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// ������ �������� �ʾ� ������ ��� �� ���.
			// ������ ���� ���ٴ� �޽����� ����Ѵ�.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	 *dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	 *wp  = DEF_NOTIFY_SKILLTRAINFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ��������.
	 *cp = 1;
			cp++;

			// ����ȣ
	 *cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// ���� ���
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
	 */
}

int CGame::_iGetSkillNumber(char * pSkillName) {
	register int i;
	char cTmpName[21];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
				// °°Àº ÀÌ¸§À» °¡Áø ±â¼ú ¼³Á¤À» Ã£¾Ò´Ù. ±â¼ú ¹øÈ£¸¦ ¹ÝÈ¯ÇÑ´Ù.
				return i;
			}
		}

	return 0;
}

BOOL CGame::bPlayerItemToBank(int iClientH, short sItemIndex) {
	register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			iIndex = i;
			goto NEXT_STEP_PLTB;
		}
	// ´õÀÌ»ó ÀúÀåÇÒ °ø°£ÀÌ ¾ø´Ù.
	return FALSE;

NEXT_STEP_PLTB:
	;

	// ¾ÆÀÌÅÛÀ» ÀúÀåÇÒ °ø°£ÀÌ ³²¾ÆÀÖ´Ù.
	// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù.
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);

	// ¾ÆÀÌÅÛ Å¬·¡½ºÀÇ ÁÖ¼Ò¸¦ ¹Ù²Û´Ù.
	m_pClientList[iClientH]->m_pItemInBankList[iIndex] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
	// ÇÃ·¹ÀÌ¾î ¾ÆÀÌÅÛ ¸®½ºÆ®¸¦ Å¬¸®¾îÇÏ°í
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

	// ¾ÆÀÌÅÛ ¸®½ºÆ®ÀÇ ºó °ø°£À» »èÁ¦ÇÑ´Ù.
	for (i = 1; i < DEF_MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i - 1] == NULL) && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
			m_pClientList[iClientH]->m_pItemList[i - 1] = m_pClientList[iClientH]->m_pItemList[i];
			m_pClientList[iClientH]->m_bIsItemEquipped[i - 1] = m_pClientList[iClientH]->m_bIsItemEquipped[i];
			m_pClientList[iClientH]->m_pItemList[i] = NULL;
			m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
		}

	return TRUE;
}

BOOL CGame::bBankItemToPlayer(int iClientH, short sItemIndex) {
	register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			iIndex = i;
			goto NEXT_STEP_PLTB;
		}
	// ´õÀÌ»ó °®°íÀÖÀ» °ø°£ÀÌ ¾ø´Ù.
	return FALSE;

NEXT_STEP_PLTB:
	;

	// ¾ÆÀÌÅÛÀ» ¼ÒÁöÇÒ °ø°£ÀÌ ³²¾ÆÀÖ´Ù.

	// ¾ÆÀÌÅÛ Å¬·¡½ºÀÇ ÁÖ¼Ò¸¦ ¹Ù²Û´Ù.
	m_pClientList[iClientH]->m_pItemList[iIndex] = m_pClientList[iClientH]->m_pItemInBankList[sItemIndex];

	m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = NULL;

	return TRUE;
}

BOOL CGame::__bReadMapInfo(int iMapIndex) {
	char * pContents, * token, * pTile, cTxt[250], cFn[255];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int iTeleportLocIndex = 0;
	int iWayPointCfgIndex = 0;
	int iTotalNpcSetting = 0;
	int iMGARCfgIndex = 0;
	int iSMGRCfgIndex = 0;
	int iNMRCfgIndex = 0;
	int iFishPointIndex = 0;
	int iMineralPointIndex = 0;
	int iStrategicPointIndex = 0;
	int iIndex = 0;

	int iNamingValue;
	class CStrTok * pStrTok;
	HANDLE hFile;
	DWORD dwFileSize, dwReadSize;
	FILE * pFile;

	char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
	short sIPindex, dX, dY;

	// »çÅõÀåÀÎÁö¸¦ ÆÇ´Ü.
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0)
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0)
		m_pMapList[iMapIndex]->m_bIsSnowEnabled = TRUE;

	std::memset(cFn, 0, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize + 1];
	ZeroMemory(pContents, dwFileSize + 1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// ¸Ê Á¤º¸ÆÄÀÏÀ»  ÀÐÀ» ¼ö ¾ø´Ù.
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	} else {
		wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
						case 1:
							// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ X
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ Y
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö ¸Ê ÀÌ¸§
							ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName,
									  sizeof (m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
							strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
							cReadModeB = 4;
							break;

						case 4:
							// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ X
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ Y
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							// ÅÚ·¹Æ÷Æ® ÈÄ ¹æÇâ
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
							iTeleportLocIndex++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 2:
					switch (cReadModeB) {
						case 1:
							// waypoint ¹øÈ£
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iWayPointCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							// waypoint ÁýÇÕ Á¤ÀÇ X
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							// waypoint ÁýÇÕ Á¤ÀÇ Y
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 3:
					// Npc¸¦ Æ¯Á¤À§Ä¡¿¡ À§Ä¡½ÃÅ²´Ù.
					switch (cReadModeB) {
						case 1:
							// NPCÀÇ ÀÌ¸§.
							std::memset(cNpcName, 0, sizeof(cNpcName));
							strcpy(cNpcName, token);
							cReadModeB = 2;
							break;
						case 2:
							// NpcMoveType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cNpcMoveType = atoi(token);
							cReadModeB = 3;
							break;
						default:
							// WayPoint0~waypoint9
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cNpcWaypointIndex[cReadModeB - 3] = atoi(token);
							cReadModeB++;
							break;
						case 13:
							// cNamePrefix
							cNamePrefix = token[0];
							// ÀÌÁ¦ ÀÌ°÷¿¡¼­ NPC¸¦ »ý¼ºÇÑ´Ù.

							iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
							if (iNamingValue == -1) {
								// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
							} else {
								// NPC¸¦ »ý¼ºÇÑ´Ù.
								std::memset(cName, 0, sizeof(cName));
								wsprintf(cName, "XX%d", iNamingValue);
								cName[0] = cNamePrefix;
								cName[1] = iMapIndex + 65;

								if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
									// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
									m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
								}
							}
							cReadModeA = 0;
							cReadModeB = 0;
							iTotalNpcSetting++;
							break;
					}
					break;

				case 4:
					switch (cReadModeB) {
						case 1:
							// Random-Mob-Generator »ç¿ë ¿©ºÎ
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_bRandomMobGenerator = (BOOL) atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							// Mob- Level
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 5:
					// Maximum object
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 6:
					// Ä³¸¯ÅÍ ·£´ý »ý¼º ±ÝÁö ±¸¿ª : ¸¶À» Áß½ÉºÎ °°Àºµ¥¼­ ¸÷ÀÌ ¹ß»ýµÇ¸é °ï¶õÇÏ¹Ç·Î
					switch (cReadModeB) {
						case 1:
							// Rect ¹øÈ£
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iMGARCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							cReadModeB = 2;
							break;

						case 2:
							// left
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							// top
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// right
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// bottom
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 7:
					// Æ¯Á¤Áö¿ª ¸÷ »ý¼º
					switch (cReadModeB) {
						case 1:
							// Rect ¹øÈ£ m_stSpotMobGenerator[]
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iSMGRCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â ¸÷ Á¦³Ê·¹ÀÌÅÍ ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);

							if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
								cReadModeB = 3;
							else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
								cReadModeB = 9; // RECT°¡ ¾Æ´Ï¶ó WaypointÁýÇÕÀ» ÀÐ¾î¾ß ÇÑ´Ù.
							break;

						case 3:
							// left
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// top
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// right
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							// bottom
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
							cReadModeB = 7;
							break;

						case 7:
							// spot mob type
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
							cReadModeB = 8;
							break;

						case 8:
							// Max Mobs
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
							cReadModeA = 0;
							cReadModeB = 0;
							break;

						default:
							// WayPoint0~waypoint9
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
							cReadModeB++;
							break;

						case 19:
							// spot mob type
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
							cReadModeB = 20;
							break;

						case 20:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 8:
					// ¸ÊÀÌ ¼ÓÇÑ Àå¼Ò ÀÌ¸§
					std::memset(m_pMapList[iMapIndex]->m_cLocationName, 0, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
					memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 9:
					switch (cReadModeB) {
						case 1:
							// Initial-Point Index
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							sIPindex = atoi(token);
							if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
								PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							// Initial-Point X
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							// Initial-Point Y
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 10:
					// °ø°Ý ¹«È¿È­ ¿µ¿ª RECT
					switch (cReadModeB) {
						case 1:
							//
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iNMRCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â No-Magic-Rect ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 11:
					m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL) atoi(token);
					if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
						m_pMapList[iMapIndex]->m_bIsSnowEnabled = FALSE;
					cReadModeA = 0;
					break;

				case 12:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iFishPointIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Fish Point ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalFishPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

					cReadModeA = 0;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cType = atoi(token);

					cReadModeA = 0;
					break;

				case 15:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

					cReadModeA = 0;
					break;

				case 16:
					// ±¤¹° Á¦³×·¹ÀÌÅÍÀÇ Á¸ÀçÀ¯¹«¿Í µî±Þ
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL) atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 17:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iMineralPointIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Mineral Point ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 18:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

					cReadModeA = 0;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

					cReadModeA = 0;
					break;

				case 20:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iStrategicPointIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Strategic Point ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 21:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Creation Point ¹øÈ£ÀÌ´Ù.
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 22:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Goal Point ¹øÈ£ÀÌ´Ù.
								wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
								PutLogList(G_cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);

							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);

							cReadModeB = 6;
							break;

						case 6:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 23:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
								// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â  Point ¹øÈ£ÀÌ´Ù.
								wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
								PutLogList(G_cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
							cReadModeB = 5;
							break;


						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);

							cReadModeB = 6;
							break;

						case 6:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);

							cReadModeB = 7;
							break;

						case 7:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);

							cReadModeB = 8;
							break;

						case 8:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);

							cReadModeB = 9;
							break;

						case 9:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);

							cReadModeB = 10;
							break;

						case 10:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);

							cReadModeB = 11;
							break;

						case 11:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);

							cReadModeB = 12;
							break;

						case 12:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);

							cReadModeB = 13;
							break;

						case 13:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);

							cReadModeB = 14;
							break;

						case 14:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);

							cReadModeB = 15;
							break;

						case 15:
							std::memset(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, 0, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
							strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);

							m_pMapList[iMapIndex]->m_iTotalStrikePoints++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;

					}
					break; // end 23

				case 24:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
								// �̹� �Ҵ�Ǿ��ִ� Item-Event ��ȣ�̴�.
								wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
								PutLogList(G_cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalItemEvents++;
							cReadModeB = 2;
							break;

						case 2:
							strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);

							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);

							cReadModeB = 6;
							break;

						case 6:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 25: //mobevent-amount
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
							cReadModeB = 0;
							break;
					}
					break;

				case 26: //ApocalypseMobGenType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 27: // ApocalypseBossMob
					switch (cReadModeB) {
						case 1: // 3CB6Ch m_pMapList[]->m_ApocalypseBossMobNpcID
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
							cReadModeB = 2;
							break;
						case 2: // 3CB70h m_pMapList[]->ApocalypseBossMobRectX1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX1 = atoi(token);
							cReadModeB = 3;
							break;
						case 3: // 3CB74h m_pMapList[]->ApocalypseBossMobRectY1
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY1 = atoi(token);
							cReadModeB = 4;
							break;
						case 4: // 3CB78h m_pMapList[]->ApocalypseBossMobRectX2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX2 = atoi(token);
							cReadModeB = 5;
							break;
						case 5: // 3CB7Ch m_pMapList[]->ApocalypseBossMobRectY2
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY2 = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 28: //DynamicGateType // 28
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 29: //DynamicGateCoord // 29
					// DynamicGateCoord	= 59 196 60 197        abaddon	   -1  -1
					switch (cReadModeB) {
						case 1: // 3CA20h
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
							cReadModeB = 2;
							break;

						case 2: // 3CA24h
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
							cReadModeB = 3;
							break;

						case 3: // 3CA28h
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
							cReadModeB = 4;
							break;

						case 4: // 3CA2Ch
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
							cReadModeB = 5;
							break;

						case 5: // 3CA30h
							memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
							cReadModeB = 6;
							break;

						case 6: // 3CA3Ch
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
							cReadModeB = 7;
							break;

						case 7: // (ty = 3CB60h) unknown (3CA3Eh)
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 30: // RecallImpossible // 30
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsRecallImpossible = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 31: // ApocalypseMap // 31
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsApocalypseMap = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 32: // CitizenLimit // 32
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsCitizenLimit = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 33: // HeldenianMap
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 34: // HeldenianTower
					switch (cReadModeB) {
						case 1: // NpcID
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
							cReadModeB = 2;
							break;
						case 2: // side
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
							cReadModeB = 3;
							break;
						case 3: // sX
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
							cReadModeB = 4;
							break;
						case 4: // sY
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 35: // HeldenianModeMap
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 36: // HeldenianWinningZone
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							dX = atoi(token);
							cReadModeB = 2;
							break;
						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							dY = atoi(token);
							pTile = 0;
							pTile = (char *) (m_pMapList[iMapIndex]->m_pTile + dX + dY * m_pMapList[iMapIndex]->m_sSizeY);
							if (pTile == 0) {
								wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map Info file error HeldenianWinningZone - pTile is Null dx(%d), dy(%d).", dX, dY);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							//pTile->m_iAttribute = 1;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 37: // HeldenianGateDoor // 37
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
							cReadModeB = 2;
							break;
						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
							cReadModeB = 3;
							break;
						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
							iIndex++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				default:
					break;
			}
		} else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}

			if (memcmp(token, "maximum-object", 14) == 0)
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0) cReadModeA = 13;
			if (memcmp(token, "type", 4) == 0) cReadModeA = 14;
			if (memcmp(token, "level-limit", 11) == 0) cReadModeA = 15;

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0) cReadModeA = 18;
			if (memcmp(token, "upper-level-limit", 17) == 0) cReadModeA = 19; // v1.4
			if (memcmp(token, "strategic-point", 15) == 0) { // v1.41
				cReadModeA = 20;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}

			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}

			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}

RMI_SKIPDECODING:
	;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);

	// Crusade °ø°Ý ºÒ°¡´É ¿µ¿ªÀ» Å¸ÀÏ¿¡ Ç¥½ÃÇÑ´Ù.
	m_pMapList[iMapIndex]->_SetupNoAttackArea();
	//Heldenian 3.00 Source
	strncmp(m_cHeldenianMapName, m_pMapList[iMapIndex]->m_cName, 11);
	m_bIsHeldenianReady = TRUE;

	return TRUE;

}

void CGame::Quit() {
	int i;

	// ¾²·¹µå¸¦ Á×ÀÎ´Ù.
	G_bIsThread = FALSE;
	Sleep(300);

	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i]; // Crafting
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

}

int CGame::iGetLevelExp(int iLevel) {
	int iRet;

	if (iLevel == 0) return 0;

	iRet = iGetLevelExp(iLevel - 1) + iLevel * (50 + (iLevel * (iLevel / 17) * (iLevel / 17)));

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel) {
	int iRet;

	if (iLevel < 1) return 1;

	if (iLevel <= 50)
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = (iLevel * iLevel) / 10;
	}
	return iRet;
}

BOOL CGame::bCheckLevelUp(int iClientH) // Sobrepaso de lvl fix.
{
	BOOL bStr, bVit, bDex, bInt, bMag, bChr;
	char cLoopCnt;
	int bobdole;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) {
		if (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iPlayerMaxLevel + 1]) {
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_iPlayerMaxLevel];
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft > DEF_MAXGIZONPOINT) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = DEF_MAXGIZONPOINT; // adamas
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
		}
		return FALSE;
	}

	/*	if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL - 1 ) && (m_pClientList[iClientH]->m_bIsHunter == TRUE ) ) 
		{
			SetNoHunterMode(iClientH,TRUE) ;
	 */

	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;

	bStr = bVit = bDex = bInt = bMag = bChr = FALSE;
	cLoopCnt = 0;
	while (m_pClientList[iClientH]->m_iExp > m_pClientList[iClientH]->m_iNextLevelExp
			  && m_pClientList[iClientH]->m_iLevel < m_iPlayerMaxLevel) {

		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3; // v2.23
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);

			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

			CalcTotalItemEffect(iClientH, -1, FALSE);

			if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL) {
				wsprintf(G_cTxt, "(!) Character (%s) is over max level", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);
			}
		} else return TRUE;
	}
	bobdole = 3;
	return FALSE;
}

void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize) {
	char * cp, cStateChange1, cStateChange2, cStateChange3;
	char cStr, cVit, cDex, cInt, cMag, cChar;
	int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	cStr = cVit = cDex = cInt = cMag = cChar = 0;

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	cStateChange1 = *cp;
	cp++;

	cStateChange2 = *cp;
	cp++;

	cStateChange3 = *cp;
	cp++;

	iOldStr = m_pClientList[iClientH]->m_iStr;
	iOldVit = m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;

	if (!bChangeState(cStateChange1, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if (!bChangeState(cStateChange2, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if (!bChangeState(cStateChange3, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iGuildRank == 0) {
		if (m_pClientList[iClientH]->m_iCharisma - cChar < 20) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
	}

	if (iOldStr + iOldVit + iOldDex + iOldInt + iOldMag + iOldChar != (179 * 3 + 70)) {
		return;
	}

	if ((cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0) ||
			  (cStr + cVit + cDex + cInt + cMag + cChar != 3)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT)
			  || (m_pClientList[iClientH]->m_iStr - cStr < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT)
			  || (m_pClientList[iClientH]->m_iDex - cDex < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT)
			  || (m_pClientList[iClientH]->m_iInt - cInt < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT)
			  || (m_pClientList[iClientH]->m_iVit - cVit < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT)
			  || (m_pClientList[iClientH]->m_iMag - cMag < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
			  || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;

	m_pClientList[iClientH]->m_iStr -= cStr;
	m_pClientList[iClientH]->m_iVit -= cVit;
	m_pClientList[iClientH]->m_iDex -= cDex;
	m_pClientList[iClientH]->m_iInt -= cInt;
	m_pClientList[iClientH]->m_iMag -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;

	if (cInt > 0) {
		bCheckMagicInt(iClientH);
	}

	//Re-Calculate HP,MP,SP
	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
}

// 2003-04-21 ÀÎÆ®¿¡ µû¸¥ ¸¶¹ýÀ» »èÁ¦ ½ÃÄÑÁØ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  BOOL CGame::bCheckMagicInt(int iClientH)  //another retarded korean function
//  desc		 :: ÀÎÆ®°¡ ³»·Á°¬À»¶§ »èÁ¦ÇÒ ¸¶¹ýÀ» Ã³¸®ÇÑ´Ù... Ã¼Å©¸¸...
//	return value :: ¹«Á¶°Ç TRUE   // ....dumbass koreans
//  date		 :: 2003-04-21
/////////////////////////////////////////////////////////////////////////////////////

BOOL CGame::bCheckMagicInt(int iClientH) {

	for (int i = 0; i < DEF_MAXMAGICTYPE; i++) {
		if (m_pMagicConfigList[i] != NULL)
			if (m_pMagicConfigList[i]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)) {
				m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
			}
	}

	return TRUE;
}

// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¾µ¼ö ÀÖ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  bChangeState(char cStateChange
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
//  desc		 :: ÁöÁ¸ Æ÷ÀÎÆ®·Î Æ¯¼º°ª ¹Ù²Üƒ”À» ´õÇØ ÁØ´Ù...
//	return value :: BOOLÇü 0(FASLE) ¿¡·¯ ·¹º§ ¼öÁ¤ ºÒ°¡...
//  date		 :: [2003-04-14]
/////////////////////////////////////////////////////////////////////////////////////

BOOL CGame::bChangeState(char cStateChange, char *cStr, char *cVit, char *cDex, char *cInt, char *cMag, char *cChar) {
	if (cStateChange == DEF_STR) {
		*cStr += 1;
	} else if (cStateChange == DEF_VIT) {
		*cVit += 1;
	} else if (cStateChange == DEF_DEX) {
		*cDex += 1;
	} else if (cStateChange == DEF_INT) {
		*cInt += 1;
	} else if (cStateChange == DEF_MAG) {
		*cMag += 1;
	} else if (cStateChange == DEF_CHR) {
		*cChar += 1;
	} else {
		return 0;
	}

	return cStateChange;
}


//50Cent - LU Fix

void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize) {
	char * cp;
	int * ip;
	int iStr, iVit, iDex, iInt, iMag, iChar;
	int iTotalSetting = 0;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);

	ip = (int *) cp;
	iStr = (int) *ip;
	cp += 4;

	ip = (int *) cp;
	iVit = (int) *ip;
	cp += 4;

	ip = (int *) cp;
	iDex = (int) *ip;
	cp += 4;

	ip = (int *) cp;
	iInt = (int) *ip;
	cp += 4;

	ip = (int *) cp;
	iMag = (int) *ip;
	cp += 4;

	ip = (int *) cp;
	iChar = (int) *ip;
	cp += 4;

	if ((iStr + iVit + iDex + iInt + iMag + iChar) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	// Level-Up Setting���� ���� �ִ��� �˻��Ѵ�.
	if ((m_pClientList[iClientH]->m_iStr + iStr > DEF_CHARPOINTLIMIT) || (iStr < 0))
		return;

	if ((m_pClientList[iClientH]->m_iDex + iDex > DEF_CHARPOINTLIMIT) || (iDex < 0))
		return;

	if ((m_pClientList[iClientH]->m_iInt + iInt > DEF_CHARPOINTLIMIT) || (iInt < 0))
		return;

	if ((m_pClientList[iClientH]->m_iVit + iVit > DEF_CHARPOINTLIMIT) || (iVit < 0))
		return;

	if ((m_pClientList[iClientH]->m_iMag + iMag > DEF_CHARPOINTLIMIT) || (iMag < 0))
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + iChar > DEF_CHARPOINTLIMIT) || (iChar < 0))
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
			  m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool - 3 > ((m_pClientList[iClientH]->m_iLevel - 1)*3 + 70)) {
		int bobdole;
		bobdole = 3;
		m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel - 1)*3 + 70 - iTotalSetting;

		if (m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (iTotalSetting + (iStr + iVit + iDex + iInt + iMag + iChar)
			  > ((m_pClientList[iClientH]->m_iLevel - 1)*3 + 70)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (iStr + iVit + iDex + iInt + iMag + iChar);

	m_pClientList[iClientH]->m_iStr += iStr;
	m_pClientList[iClientH]->m_iVit += iVit;
	m_pClientList[iClientH]->m_iDex += iDex;
	m_pClientList[iClientH]->m_iInt += iInt;
	m_pClientList[iClientH]->m_iMag += iMag;
	m_pClientList[iClientH]->m_iCharisma += iChar;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

}

/*
void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChar;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	m_pClientList[iClientH]->m_iLU_Pool += DEF_TOTALLEVELUPPOINT;
	wsprintf(G_cTxt, "(*) Level Up: Char(%s) Level (%d) DEF_TOTALLEVELUPPOINT (%d) m_pClientList[iClientH]->m_iLU_Pool (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel, DEF_TOTALLEVELUPPOINT, m_pClientList[iClientH]->m_iLU_Pool);
	PutLogList(G_cTxt);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChar = *cp;
	cp++;

	// Level-Up Setting°ª¿¡ ¿À·ù°¡ ÀÖ´ÂÁö °Ë»çÇÑ´Ù.
	if ((cStr > DEF_TOTALLEVELUPPOINT) || (cStr < 0))
		return;

	if ((cDex > DEF_TOTALLEVELUPPOINT) || (cDex < 0))
		return;

	if ((cInt > DEF_TOTALLEVELUPPOINT) || (cInt < 0))
		return;

	if ((cVit > DEF_TOTALLEVELUPPOINT) || (cVit < 0))
		return;

	if ((cMag > DEF_TOTALLEVELUPPOINT) || (cMag < 0))
		return;

	if ((cChar > DEF_TOTALLEVELUPPOINT) || (cChar < 0))
		return;

	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > DEF_TOTALLEVELUPPOINT)
		return;

	// ¿À·ù°¡ ¾øÀ¸¸é °ªÀ» ÇÒ´çÇÑ´Ù.

	//m_pClientList[iClientH]->m_cLU_Str  = cStr;
	//m_pClientList[iClientH]->m_cLU_Vit  = cVit;
	//m_pClientList[iClientH]->m_cLU_Dex  = cDex;
	//m_pClientList[iClientH]->m_cLU_Int  = cInt;
	//m_pClientList[iClientH]->m_cLU_Mag  = cMag;
	//m_pClientList[iClientH]->m_cLU_Char = cChar;

	/*
	m_pClientList[iClientH]->m_cLU_Str = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Vit = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Dex = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Int = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Mag = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Char = *cp;
	cp++;

	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0))
	m_pClientList[iClientH]->m_cLU_Str = 0;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0))
	m_pClientList[iClientH]->m_cLU_Vit = 0;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0))
	m_pClientList[iClientH]->m_cLU_Dex = 0;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0))
	m_pClientList[iClientH]->m_cLU_Int = 0;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0))
	m_pClientList[iClientH]->m_cLU_Mag = 0;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0))
	m_pClientList[iClientH]->m_cLU_Char = 0;

	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex +
	m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) {
	// Level-Up Setting°ª¿¡ ¿À·ù°¡ ÀÖ´Ù.
	m_pClientList[iClientH]->m_cLU_Str = m_pClientList[iClientH]->m_cLU_Vit = m_pClientList[iClientH]->m_cLU_Dex =
	m_pClientList[iClientH]->m_cLU_Int = m_pClientList[iClientH]->m_cLU_Mag = m_pClientList[iClientH]->m_cLU_Char = 0;
	}
 */
//}

// v1.4311-3 Ãß°¡ »çÅõÀå ¿¹¾à ÇÔ¼ö FightzoneReserveHandler

void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize) {
	char cData[100];
	int iFightzoneNum, * ip, iEnableReserveTime;
	DWORD * dwp, dwGoldCount;
	WORD * wp, wResult;
	int iRet, iResult = 1, iCannotReserveDay;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	GetLocalTime(&SysTime);

	// ¿¹¾à °¡´ÉÇÑ ½Ã°£ : µÎ½Ã°£ °£°ÝÀ¸·Î ¿¹¾àÀÌ °¡´ÉÇÏ¸ç »ç¿ë¿Ï·á 5ºÐÀü¿¡´Â ¿¹¾àÀÌ ºÒ°¡´ÉÇÏ´Ù.
	iEnableReserveTime = 2 * 20 * 60 - ((SysTime.wHour % 2)*20 * 60 + SysTime.wMinute * 20) - 5 * 20;

	dwGoldCount = dwGetItemCount(iClientH, "Gold");

	ip = (int *) (pData + DEF_INDEX2_MSGTYPE + 2);
	// ¿¹¾àÀ» ¿øÇÏ´Â »çÅõÀå ¹øÈ£¸¦ ¹Þ´Â´Ù.
	iFightzoneNum = *ip;

	// Àß¸øµÈ fightzone ¹øÈ£¸¦ °É·¯³½´Ù.
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// »çÅõÀåÀÌ Áßº¹µÇÁö ¾Ê°Ô ÇÏ±â À§ÇØ ¿äÀÏ¿¡ µû¶ó »ç¿ëÇÒ¼ö ÀÖ´Â »çÅõÀåÀÌ ´Ù¸£°Ô ÇÏ±â À§ÇÑ º¯¼ö´Ù.
	// È¦¼ö³¯¿¡´Â ¾Æ·¹½ºµ§ 2 4 6 8 ¿¤¹ÙÀÎÀÌ 1 3 5 7  »çÅõÀåÀÌ »ç¿ë°¡´ÉÇÏ´Ù
	//             ex) 1ÀÏÀÎ°æ¿ì => {1 + 1 (¾Æ·¹½ºµ§) + 1 (»çÅõÀå ¹øÈ£ )} %2 == 1 ÀÌ¹Ç·Î
	//                            ¾Æ·¹½ºµ§Àº È¦¼ö³¯ È¦¼ö »çÅõÀåÀ»  ¿¹¾à ÇÒ¼ö ¾ø´Ù.

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum) % 2;
	if (iEnableReserveTime <= 0) {
		// ¿¹¾à¿¡ ½ÇÆÐÇß´Ù.
		// ¸¸¾à ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ ¾Æ´Ï¸é 0 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³»°í
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0;
	} else if (m_iFightZoneReserve[iFightzoneNum - 1] != 0) {
		// »çÅõÀåÀÌ ¿¹¾à µÇ¾î ÀÖÀ¸¸é  -1 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1;
	} else if (dwGoldCount < 1500) {
		// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ÀÔÀå±Ç °¡°Ý¿¡ ºñÇØ Àû´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2; // µ·ÀÌ ÀûÀ¸¸é -2 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô º¸³½´Ù.
	} else if (iCannotReserveDay) {
		// ¿À´ÃÀº ¿¹¾àÇÒ ¼ö ¾ø´Â ³¯ÀÌ´Ù. ÀÌ¶§´Â -3 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3;
	} else if (m_pClientList[iClientH]-> m_iFightzoneNumber != 0) {
		// ÀÌ¹Ì ´Ù¸¥ »çÅõÀåÀ» ¿¹¾àÇß´Ù. ÀÌ¶§´Â -4 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4;
	} else {
		// »ç¿ëÀÚ°¡ °í¸¥ »çÅõÀåÀÌ ¿¹¾àÀÌ µÇ¾î ÀÖÁö ¾Ê°í
		// ¿¹¾à¿¡ ÇÊ¿äÇÑ ±Ý¾×µµ °¡Áö°í ÀÖ°í
		// ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ¸é  ¿¹¾àÇÑ´Ù.

		// ¿¹¾à¿¡ ¼º°ø Çß´Ù.
		wResult = DEF_MSGTYPE_CONFIRM;

		// »çÅõÀå ¿¹¾àÀ» À§ÇÑ ±Ý¾×À» °¨¼Ò ½ÃÅ²´Ù.
		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);

		// »çÅõÀåÀ» ¿¹¾àÇÑ Å¬¶óÀÌ¾ðÆ®ÀÇ ID¸¦ ³Ö´Â´Ù.
		m_iFightZoneReserve[iFightzoneNum - 1] = iClientH;

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneNum;
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth * 10000 + SysTime.wDay * 100 + SysTime.wHour;

		if (SysTime.wHour % 2) m_pClientList[iClientH]->m_iReserveTime += 1; // È¦¼ö ½Ã°£´ëÀÌ¸é ÇÑ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		else m_pClientList[iClientH]->m_iReserveTime += 2; // Â¦¼ö ½Ã°£´ëÀÌ¸é µÎ ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 50;
		iResult = 1;
	}

	std::memset(cData, 0, sizeof(cData));

	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = wResult;

	ip = (int *) (cData + DEF_INDEX2_MSGTYPE + 2);
	*ip = iResult;
	ip += 4;

	// »çÅõÀå ¿¹¾à ÀÀ´ä ¸Þ¼¼Áö  Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);

	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
	}
}

BOOL CGame::bCheckLimitedUser(int iClientH) {
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) &&
			  (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20)) {
		// ¿©ÇàÀÚ°¡ ·¹º§ 20 °æÇèÄ¡¸¦ ¾ò¾ú´Ù¸é 19¼öÁØÀ¸·Î È¯¿ø.

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}


	return FALSE;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData) {
	char * cp, cData[100];
	DWORD * dwp;
	WORD * wp, wResult;
	int iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	// ?횑쨔횑 횉횗 쨍쨋?쨩?횉 쩌횘쩌횙?횑 ?횜쨈횢쨍챕 쩍횄쨔횓짹횉?쨩 째징횁첬 쩌철 쩐첩쨈횢.
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;

	// 쨌쨔쨘짠?횑 5 ?횑횉횕쨋처쨉쨉 쩍횄쨔횓짹횉?쨩 쩐챵?쨩 쩌철 쩐첩쨈횢.
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;

	if (wResult == 1) {
		// 횉철?챌 쨍횎?횉 ?횑쨍짠?쨩 횉횘쨈챌횉횗쨈횢.
		std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}

	// Side 횉횘쨈챌
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;

	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = wResult;

	// v1.41 쨍횎 ?횑쨍짠 쩐횏쨌횁횁횥
	cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	// ??쨈채 쨍횧쩍횄횁철쨍짝 횇짭쨋처?횑쩐챨횈짰쩔징째횚 ?체쩌횤
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// 쨍횧쩍횄횁철쨍짝 쨘쨍쨀쩐쨋짠 쩔징쨌짱째징 쨔횩쨩첵횉횩쨈횢쨍챕 횁짝째횇횉횗쨈횢.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
	}
	// 횈짱쩌쨘?횑 쨔횢짼챤쨔횉쨌횓 쩔횥쩐챌?쨩 쨩천쨌횓 쨘쨍쨀쩍쨈횢.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	RequestChangePlayMode(iClientH);
}

void CGame::RequestRetrieveItemHandler(int iClientH, char *pData) {
	char * cp, cBankItemIndex, cMsg[100];
	register int i, j, iRet, iItemWeight;
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *) (pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		// ¿À·ù´Ù.
		std::memset(cMsg, 0, sizeof(cMsg));

		dwp = (DWORD *) (cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp = (WORD *) (cMsg + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	} else {
		// Áß·®°è»ê
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		 */
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

		if ((iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			// ÇÑ°èÁß·® ÃÊ°ú, ¾ÆÀÌÅÛÀ» Ã£À» ¼ö ¾ø´Ù.
			// ½ÇÆÐ ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			std::memset(cMsg, 0, sizeof(cMsg));

			// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			dwp = (DWORD *) (cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD *) (cMsg + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
			}
			return;
		}

		//!!!
		if ((m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				  (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// Áßº¹ÀÌ °¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ¶ó¸é ¼ö·®¸¸ Áõ°¡½ÃÅ²´Ù.
			for (i = 0; i < DEF_MAXITEMS; i++)
				if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) &&
						  (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) &&
						  (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0)) {
					// °°Àº Çü½ÄÀÇ ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. ¼ö·®À» Áõ°¡½ÃÅ²´Ù.
					// v1.41 !!!
					SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

					// ¹ðÅ© ¾ÆÀÌÅÛ »èÁ¦
					delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

					// ºó °ø°£À» ¾ø¾Ø´Ù.
					for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

							m_pClientList[iClientH]->m_pItemInBankList[j + 1] = NULL;
						}
					}

					// ¼º°ø ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					std::memset(cMsg, 0, sizeof(cMsg));

					dwp = (DWORD *) (cMsg + DEF_INDEX4_MSGID);
					*dwp = MSGID_RESPONSE_RETRIEVEITEM;
					wp = (WORD *) (cMsg + DEF_INDEX2_MSGTYPE);
					*wp = DEF_MSGTYPE_CONFIRM;

					cp = (char *) (cMsg + DEF_INDEX2_MSGTYPE + 2);
					*cp = cBankItemIndex;
					cp++;
					*cp = i;
					cp++;

					// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
					iCalcTotalWeight(iClientH);
					// È­»ì ÇÒ´ç
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					// ¸Þ½ÃÁö Àü¼Û
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
					return;
				}

			// °°Àº ÀÌ¸§À» °®°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ¾ø´Ù. »õ·Î Ãß°¡ÇØ¾ß ÇÑ´Ù.
			goto RRIH_NOQUANTITY;
		} else {
RRIH_NOQUANTITY:
			;
			// ¼ö·®°³³äÀÌ ¾ø´Â ¾ÆÀÌÅÛ
			for (i = 0; i < DEF_MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
					// ºó °ø°£À» Ã£¾Ò´Ù.
					// ¸ÕÀú ÁÖ¼Ò¸¦ ¿Å±ä´Ù.
					m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
					// v1.3 1-27 12:22
					m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
					m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

					// ºó °ø°£À» ¾ø¾Ø´Ù.
					for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

							m_pClientList[iClientH]->m_pItemInBankList[j + 1] = NULL;
						}
					}

					// ¼º°ø ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					std::memset(cMsg, 0, sizeof(cMsg));

					dwp = (DWORD *) (cMsg + DEF_INDEX4_MSGID);
					*dwp = MSGID_RESPONSE_RETRIEVEITEM;
					wp = (WORD *) (cMsg + DEF_INDEX2_MSGTYPE);
					*wp = DEF_MSGTYPE_CONFIRM;

					cp = (char *) (cMsg + DEF_INDEX2_MSGTYPE + 2);
					*cp = cBankItemIndex;
					cp++;
					*cp = i;
					cp++;

					// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
					iCalcTotalWeight(iClientH);

					// È­»ì ÇÒ´ç
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					// ¸Þ½ÃÁö Àü¼Û
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
					return;
				}
			// ¾ÆÀÌÅÛÀ» µÇÃ£À» °ø°£ÀÌ ¾ø´Ù. ¿À·ù
			std::memset(cMsg, 0, sizeof(cMsg));

			dwp = (DWORD *) (cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp = (WORD *) (cMsg + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_REJECT;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
	}
}

BOOL CGame::bSetItemToBankItem(int iClientH, short sItemIndex) {
	register int i, iRet;
	DWORD * dwp;
	WORD * wp;
	char * cp;
	short * sp;
	char cData[100];
	class CItem * pItem;

	// ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀ» º¸°üÇÑ´Ù.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			// ºñ¾îÀÖ´Â À§Ä¡¸¦ Ã£¾Ò´Ù.

			m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
			pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
			// !!! ¾ÆÀÌÅÛÀÇ Æ÷ÀÎÅÍ¸¦ ÀÌµ¿ÇßÀ¸´Ï ±âÁ¸ÀÇ Æ÷ÀÎÅÍ´Â NULL°ªÀ¸·Î ÇÒ´ç.
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê
			iCalcTotalWeight(iClientH);

			dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_NOTIFY_ITEMTOBANK;

			cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = i; // À§Ä¡ ÀúÀå
			cp++;

			// 1°³.
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp = (DWORD *) cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char) 0;
			cp++;

			sp = (short *) cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *) cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *) cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp = (short *) cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp = (short *) cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			// v1.432
			sp = (short *) cp;
			*sp = pItem->m_sItemEffectValue2;
			cp += 2;

			// v1.42
			dwp = (DWORD *) cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù. v1.41 Á¦°ÅÇÏÁö ¾Ê´Â´Ù.
					// DeleteClient(iClientH, TRUE, TRUE);
					return TRUE; // v1.41 FALSE¸¦ ¹ÝÈ¯ÇÏ¸é ¾ÆÀÌÅÛÀÌ ¹Ù´Ú¿¡ º¹»çµÈ´Ù.
			}

			return TRUE;
		}

	// ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¿©À¯°ø°£ÀÌ ¾ø´Ù.
	return FALSE;
}
// 05/21/2004 - Hypnotoad - send player to jail

void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH) {
	int iV1, iV2;

	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL) return;
	// ¾ÈÀü °ø°Ý ¸ðµå°¡ ÄÑÁø »óÅÂ¿¡¼­ °ø°ÝÀ¸·Î ÀÎÇØ °°Àº ÆíÀÌ Á×À»¼ö´Â ¾øÁö¸¸ ¸¸¾à ÀÖÀ»°æ¿ì ¹«½Ã
	// ´Ü °ø°ÝÀÚ°¡ ¹üÁËÀÚ°¡ ¾Æ´Ï¾î¾ß¸¸ ÇØ´çµÈ´Ù.
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return;

	// PK Count Áõ°¡
	m_pClientList[sAttackerH]->m_iPKCount++;

	_bPKLog(DEF_PKLOG_BYPK, sAttackerH, sVictumH, NULL);

	// °æÇèÄ¡ °¨¼Ò
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel / 2) + 1, 50);
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel / 2) + 1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1;
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	// Æä³ÎÆ¼¸¦ ¸Ô¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);

	// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù.
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// v1.4 ·Î±× ÆÄÀÏ¿¡ ±â·Ï
	//wsprintf(G_cTxt, "(!) PK-penalty: °ø°ÝÀÚ(%s) ¼Õ½Ç °æÇèÄ¡(%d) °æÇèÄ¡(%d) ", m_pClientList[sAttackerH]->m_cCharName, iV1+iV2, m_pClientList[sAttackerH]->m_iExp);
	//PutLogFileList(G_cTxt);

	// v1.4 Å©¶óÀÓ È½¼ö Áõ°¡
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	// v1.41 Rating ÇÏ¶ô
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000) m_pClientList[sAttackerH]->m_iRating = 10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;


	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "aresden") == 0) {
		if ((strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm") == 0)) {

			// ¾Æ·¹½ºµ§ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
			// v2.16 ¼ºÈÄ´Ï ¼öÁ¤
			std::memset(m_pClientList[sAttackerH]->m_cLockedMapName, 0, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 5 * 2;
			RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
			return;
		}
	}

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "elvine") == 0) {
		if ((strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni") == 0) ||
				  (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {

			// ¿¤¹ÙÀÎ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
			std::memset(m_pClientList[sAttackerH]->m_cLockedMapName, 0, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 5 * 2;
			RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
			return;
		}
	}
}


// 05/17/2004 - Hypnotoad - register pk log

void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH) {
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL) return;

	_bPKLog(DEF_PKLOG_BYPLAYER, sAttackerH, sVictumH, NULL);

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PK¸¦ ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.

	} else {
		// Æ÷»ó±Ý¸¸ ´©Àû. °æÇèÄ¡´Â ¿À¸£Áö ¾Ê´Â´Ù.
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;


		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0)
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH) {
	// enemy-kill-mode = 1 | 0
	// if m_bEnemyKillMode is true than death match mode

	// DEATHMATCH MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and gets an EK
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and gets an EK

	// CLASSIC MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and doesnt get an EK
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and doesnt get an EK

	int iRewardExp, iEK_Level;

	// if the attacker doesnt exist no result
	if (m_pClientList[iAttackerH] == NULL) return;
	// if the target doesnt exist no result
	if (m_pClientList[iClientH] == NULL) return;

	// Log the EK (killed by enemy)
	_bPKLog(DEF_PKLOG_BYENERMY, iAttackerH, iClientH, NULL);

	// set EK level to 30
	iEK_Level = 30;
	// if attacker's level is greater than 80, set ek level to 80
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;
	// check if attacker level is less than or equal to max level
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iPlayerMaxLevel) {
		// if the
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
			// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
					  && (m_bEnemyKillMode == FALSE)) {
				// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
				//Happy Hour para vos
				if (m_bHappyHour == TRUE) {
					m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
				} else {
					m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
				}
			}


			if (m_bEnemyKillMode == TRUE) {
				// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
				//Happy Hour para vos
				if (m_bHappyHour == TRUE) {
					m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
				} else {
					m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
				}
			}
		}
		// Æ÷»ó±Ý ´©Àû
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		// ÀûÀ» Àâ¾Ò´Ù´Â ¸Þ½ÃÁö º¸³¿
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
		// ÀûÀ» ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.
	} else {
		// Èñ»ýÀÚÀÇ ½Ã¹Î, ±æµå¿ø ¿©ºÎ¿¡ µû¶ó Æ÷»óÀÌ ´Þ¶óÁø´Ù.
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			// ±æµå¿øÀÌ ¾Æ´Ï¹Ç·Î ½Ã¹Î. (¿©ÇàÀÚÀÇ °æ¿ì¿¡´Â ÀÌ ÇÔ¼ö°¡ È£ÃâµÇÁö ¾ÊÀ¸¹Ç·Î)
			// v2.15 ÀûÀ» Á×¿´À»¶§ Æò±Õ°æÇèÄ¡¸¦ ¾ò±âÀ§ÇØ
			iRewardExp = (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;

			if (m_bIsCrusadeMode == TRUE) {
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ (1/3)*3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 6¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp / 3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp / 3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp / 3))*6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}
					if (m_bEnemyKillMode == TRUE) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}
				}
				// Æ÷»ó±Ý ´©Àû
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			} else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
							  && (m_bEnemyKillMode == FALSE)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}

					if (m_bEnemyKillMode == TRUE) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}
				}
				// Æ÷»ó±Ý ´©Àû
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		} else {
			// v2.15 ÀûÀ» Á×¿´À»¶§ Æò±Õ°æÇèÄ¡¸¦ ¾ò±âÀ§ÇØ
			iRewardExp = (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;

			// ±æµå¿øÀÌ´Ù.
			if (m_bIsCrusadeMode == TRUE) {
				// Å©·ç¼¼ÀÌµå ¸ðµå.
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ 1/3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 2¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp / 3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp / 3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp / 3))*6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
							  && (m_bEnemyKillMode == FALSE)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}

					if (m_bEnemyKillMode == TRUE) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}
				}
				// Æ÷»ó±Ý ´©Àû
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			} else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 80ÀÌ»óÀÌ°í
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
							  && (m_bEnemyKillMode == FALSE)) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}

					if (m_bEnemyKillMode == TRUE) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤
						//Happy Hour para vos
						if (m_bHappyHour == TRUE) {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust * 2;
						} else {
							m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
						}
					}
				}
				// Æ÷»ó±Ý ´©Àû
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		// ÀûÀ» Àâ¾Ò´Ù´Â ¸Þ½ÃÁö º¸³¿
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);

		if (bCheckLimitedUser(iAttackerH) == FALSE) {
			// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ ÇØ´çµÇÁö ¾ÊÀ¸¸é °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
		// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
		bCheckLevelUp(iAttackerH);

		//v1.4 ±³Àü¿¡¼­ ÀÌ±ä Ä«¿îÆ®¸¦ ¿Ã¸°´Ù.
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

// 05/22/2004 - Hypnotoad - register in pk log

void CGame::ApplyCombatKilledPenalty(int iClientH, int cPenaltyLevel, BOOL bIsSAattacked) {
	int iExp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// Crusade
	if (m_bIsCrusadeMode == TRUE) {
		// Å©·ç¼¼ÀÌµå ¸ðµåÀÎ °æ¿ì ÀüÀïÁß¿¡ Á×¾îµµ ¾Æ¹«·± Æä³ÎÆ¼°¡ ¾ø´Ù.
		// PKcount¸¸ °¨¼Ò
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL, NULL, iClientH, NULL);

		}
		return;
	} else {
		// PKcount °¨¼Ò
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL, NULL, iClientH, NULL);
		}

		// ÇÃ·¹ÀÌ¾î·ÎºÎÅÍÀÇ °ø°ÝÀ» ¹Þ°í ÀüÀïÁß »ç¸ÁÇß´Ù.
		iExp = iDice(1, (5 * cPenaltyLevel * m_pClientList[iClientH]->m_iLevel));

		// Áß¸³ÀÎ °æ¿ì Á×¾úÀ» ¶§ ¶³¾îÁö´Â °æÇèÄ¡´Â 1/3
		if (m_pClientList[iClientH]->m_bIsNeutral == TRUE) iExp = iExp / 3;

		// v2.17 2002-7-31 ÃÖ°í·¾Àº Á×¾úÀ»¶§ °æÄ¡°¡ ¶³¾îÁöÁö ¾Ê´Â´Ù. ¼öÁ¤
		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);

		// v1.41 Áß¸³Àº ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		if (m_pClientList[iClientH]->m_bIsNeutral != TRUE) {
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// ·¹º§ 80 ¹Ì¸¸Àº ¾ÆÀÌÅÛÀÌ ÇÏ³ª Àû°Ô ¶³¾îÁø´Ù.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			} else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
		}
	}
}

// 05/29/2004 - Hypnotoad - Limits some items from not dropping

void CGame::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked) {
	register int i, j, iRemainItem;
	char cItemIndexList[DEF_MAXITEMS], cItemIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) {
		// Testcode
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
			// v2.04 ½ºÅæ ¿Àºê »õÅ©¸®ÆÄÀÌ½º°¡ ¸Â´ÂÁö È®ÀÎ
			// ´ëÃ¼ÀûÀ¸·Î ¶³¾îÁö´Â ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é ´Ù¸¥ ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê°í ÀÌ ¾ÆÀÌÅÛ¸¸ ¶³¾îÁø´Ù.
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);

			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		} else {
			// v2.04 testcode
			PutLogFileList("Alter Drop Item Index Error1");
			// ´Ù½Ã °Ë»ö
			for (i = 0; i < DEF_MAXITEMS; i++)
				if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
					m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
					if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
						m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

					DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);
					m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
					return;
				}

			// ¿À·ù¹ß»ý! Èñ»ý¼®ÀÌ ¾ø´Ù.
			goto PID_DROP;
		}
		return;
	}

PID_DROP:
	;

	for (i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		std::memset(cItemIndexList, 0, sizeof(cItemIndexList));

		for (j = 0; j < DEF_MAXITEMS; j++)
			if (m_pClientList[iClientH]->m_pItemList[j] != NULL) {
				cItemIndexList[iRemainItem] = j;
				iRemainItem++;
			}

		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];


		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
				  (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				  (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				  (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			// °³ÀÎ¿¡°Ô ¼ÓÇÑ ¾ÆÀÌÅÛÀ¸·Î ¶³¾îÁöÁö ¾Ê´Â´Ù. ¸ÁÅä°°Àº °³ÀÎ¿ë ¾ÆÀÌÅÛ
		} else if (
				  (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum >= 400) &&
				  (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum != 402) &&
				  (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum <= 428)) {
		} else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
				  (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
				  (bIsSAattacked == FALSE)) {
			// Æ¯¼ö ´É·ÂÀ» °¡Áø ¾ÆÀÌÅÛÀÌ Æ¯¼ö °ø°ÝÀ» ¹ÞÀº°Ô ¾Æ´Ï¶ó¸é ¶³¾îÁöÁö ¾Ê´Â´Ù.
		} else if ((m_pClientList[iClientH]->m_bIsLuckyEffect == TRUE) && (iDice(1, 10) == 5)) {
			// Ä³¸¯ÅÍ¿¡°Ô Çà¿îÈ¿°ú°¡ ÀÖÀ¸¸é 10% È®·ü·Î ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		} else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH) {
	int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
	DWORD * dwp;
	WORD * wp;
	char * cp, cData[100], cItemName[21];
	class CItem * pItem;
	short * sp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;


	// ³²Àº Áß·®À» °è»êÇÑ´Ù.
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);

	if (iWeightLeft <= 0) return;
	// Áß·®À» ¹ÝÀ¸·Î ³ª´«´Ù. <- Ã£Àº µ·À¸·Î ¾ÆÀÌÅÛÀ» »ì °ø°£Àº ¸¶·ÃÇØ µÖ¾ß ÇÏ¹Ç·Î.
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	std::memset(cItemName, 0, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;

	// (iWeightLeft / pItem->m_wWeight)°¡ ÃÖ´ë ¹ÞÀ» ¼ö ÀÖ´Â Gold°¹¼ö. °®°íÀÖ´Â Æ÷»ó±Ý°ú ºñ±³ÇÑ´Ù.
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
		// Æ÷»ó±ÝÀ» ¸ðµÎ ¹ÞÀ» ¼ö ÀÖ´Ù.
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	} else {
		// (iWeightLeft / pItem->m_wWeight)¸¸ ¹Þ´Â´Ù.
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.

		// ³²Àº Æ÷»ó±Ý ³»¿ª °è»ê.
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;

		dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_NOTIFY_ITEMOBTAINED;

		cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

		// 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp = (DWORD *) cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char) 0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;

		sp = (short *) cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *) cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *) cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp = (short *) cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp = (short *) cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char) pItem->m_sItemSpecEffectValue2; // v1.41
		cp++;

		dwp = (DWORD *) cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		 *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ
		cp++;
		 */

		if (iEraseReq == 1) delete pItem;

		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}

		// ±× ´ÙÀ½ ³²Àº Æ÷»ó±ÝÀ» ¾Ë·ÁÁØ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	} else {
		// ¹ÞÀ» ¼ö ¾ø´Â °æ¿ì´Â ¾Æ¹«·± Ã³¸®¸¦ ÇÏÁö ¾Ê´Â´Ù.

	}
}

int CGame::_iCalcMaxLoad(int iClientH) {
	if (m_pClientList[iClientH] == NULL) return 0;

	return ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 500 + m_pClientList[iClientH]->m_iLevel * 500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1) {
	register int i;
	short sPreType;
	DWORD dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	switch (sType) {
		case DEF_DYNAMICOBJECT_FIRE3:
		case DEF_DYNAMICOBJECT_FIRE:
			if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
				return NULL;
			if (dwLastTime != NULL) {
				switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
					case 1: dwLastTime = dwLastTime - (dwLastTime / 2);
						break;
					case 2: dwLastTime = (dwLastTime / 2) - (dwLastTime / 3);
						break;
					case 3: dwLastTime = (dwLastTime / 3) - (dwLastTime / 4);
						break;
				}

				if (dwLastTime == NULL) dwLastTime = 1000;
			}
			break;

		case DEF_DYNAMICOBJECT_FISHOBJECT:
		case DEF_DYNAMICOBJECT_FISH:
			if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
				return NULL;
			break;

		case DEF_DYNAMICOBJECT_ARESDENFLAG1:
		case DEF_DYNAMICOBJECT_ELVINEFLAG1:
		case DEF_DYNAMICOBJECT_MINERAL1:
		case DEF_DYNAMICOBJECT_MINERAL2:
			if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
				return NULL;
			m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
			break;

	}

	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] == NULL) {
			dwTime = timeGetTime();

			if (dwLastTime != NULL)
				dwLastTime += (iDice(1, 4)*1000);

			m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
			m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

			return i;
		}
	return NULL;
}

void CGame::CheckDynamicObjectList() {
	register int i;
	DWORD dwTime = timeGetTime(), dwRegisterTime;
	short sType;

	// ³¯¾¾ È¿°ú¿¡ µû¸¥ µ¿Àû °´Ã¼ÀÇ Áö¼Ó½Ã°£ ´ÜÃàÀ» °è»êÇÑ´Ù.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
		if ((m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL)) {

			switch (m_pDynamicObjectList[i]->m_sType) {
				case DEF_DYNAMICOBJECT_FIRE3:
				case DEF_DYNAMICOBJECT_FIRE:
					// ºÒÀÇ °æ¿ì ºñ°¡ ¿ÈÀ¸·Î ÀÎÇØ ¼ö¸íÀÌ ±Þ°ÝÈ÷ ´ÜÃàµÈ´Ù.
					switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
						case 0: break;
						case 1:
						case 2:
						case 3:
							// (³²Àº ½Ã°£/10)*ºñ¿À´Â »óÅÂ ¸¸Å­ ½Ã°£À» »«´Ù.
							m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime -
									  (m_pDynamicObjectList[i]->m_dwLastTime / 10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
							break;
					}
					break;
			}
		}
	}

	// ½Ã°£ÀÌ ¸¸·áµÈ °´Ã¼¸¦ Á¾·á½ÃÅ²´Ù. Áö¼Ó½Ã°£ÀÌ NULLÀÌ¸é ¿µ¿øÈ÷ ³²¾ÆÀÖ´Â µ¿Àû °´Ã¼ÀÌ´Ù.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
		if ((m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) &&
				  ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime)) {

			// Áö¼Ó½Ã°£ÀÌ °æ°úÇÑ µ¿Àû °´Ã¼¸¦ Ã£¾Ò´Ù.
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject(m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime);
			// µî·Ï½Ã°£ÀÌ ÀÏÄ¡ÇÑ´Ù¸é °´Ã¼°¡ »ç¶óÁø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»Áà¾ß ÇÑ´Ù.

			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				// ¸Ê¿¡¼­ »èÁ¦ÇÑ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
				case DEF_DYNAMICOBJECT_FISHOBJECT:
				case DEF_DYNAMICOBJECT_FISH:
					// ¹°°í±â ¿ÀºêÁ§Æ®°¡ »ç¶óÁ³À¸¹Ç·Î Ã³¸®ÇÑ´Ù.
					bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // ½Ã°£ÀÌ Áö³ª¼­ ¹°°í±â°¡ »ç¶óÁø´Ù.
					break;
			}

			// ¸®½ºÆ®¸¦ »èÁ¦ÇÑ´Ù.
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue) {
	short sSkillIndex;
	int iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;

	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1 ];

	if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
			  (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {

		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;

		switch (sSkillIndex) {
			case 0: // Mining
			case 5: // Hand-Attack
			case 13: // Manufacturing
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 3: // Magic-Resistance
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 4: // Magic
			case 21: // Staff-Attack
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)* 2)) {
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 1: // Fishing
			case 6: // Archery
			case 7: // Short-Sword
			case 8: // Long-Sword
			case 9: // Fencing
			case 10: // Axe-Attack
			case 11: // Shield
			case 14: // Hammer
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 2: // Farming
			case 12: // Alchemy
			case 15: // ����óġ
			case 19: // Pretend-Corpse
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 23: // Poison-Resistance
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			default:
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;
		}

		// ���� ����� ����ִ� ��ų�� �ö�� ���� �� ���⸦ ��� ���̶�� ���� ���߷� 1�� ���Ѵ�.
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// ī��Ʈ�� 0�̸� ��ų�� ���������� �ö�ٴ� �ǹ�.
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ��չ��Ⱑ ����Ǿ� �־��.
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// Ȱ���� ��뿡 ���� ��ų�� ����̾��. ���߷��� 1 �ø���.
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ���Ⱑ ����Ǿ� �־��.
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// ���̳� Mace���� ��뿡 ���� ��ų�� ����̾��. ���߷��� 1 �ø���.
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill�� ������ 600�� ������ �ٸ� ��ų�� �ϳ��� 1 ������.
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// Skill�� �ö�ٴ� ���� Ŭ���̾�Ʈ���� �˷��ش�.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

/*void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	// ½ºÅ³ ¼öÁØÀÌ 0ÀÌ¶ó¸é Ä«¿îÆ®°¡ ¿À¸£Áö ¾Ê´Â´Ù.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;

	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// ¸¸¾à SkillSSNÀÌ Á¦ÇÑÄ¡¸¦ ³Ñ¾î¼¹´Ù¸é Skill°ªÀÌ Áõ°¡ÇÑ´Ù.
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {

		// ½ºÅ³ÀÌ ¿Ã¶ú´Ù.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;
		// Æ¯¼ºÄ¡ Á¦ÇÑÀÌ ÀÖ´Â SkillÀ» Ã³¸®ÇÑ´Ù.

		switch (sSkillIndex) {
		case 0:
		case 2:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// ¸¶¹ý ÀúÇ×ÀÇ ÃÖ´ëÄ¡´Â Level*2
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21: // ÁöÆÎÀÌ °ø°Ý
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 14:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 12:
		case 14:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // µ¶¼º ÀúÇ×
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}

		// ¸¸¾à ¹«±â¿Í °ü·ÃÀÖ´Â ½ºÅ³ÀÌ ¿Ã¶ú°í ÇöÀç ±× ¹«±â¸¦ »ç¿ë ÁßÀÌ¶ó¸é ÇöÀç ¸íÁß·ü¿¡ 1À» ´õÇÑ´Ù.
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ä«¿îÆ®°¡ 0ÀÌ¸é ½ºÅ³ÀÌ Á¤»óÀûÀ¸·Î ¿Ã¶ú´Ù´Â ÀÇ¹Ì.
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù.
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù.
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù.
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù.
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÀÇ ÃÑÇÕÀÌ 600À» ³ÑÀ¸¸é ´Ù¸¥ ½ºÅ³Áß ÇÏ³ª¸¦ 1 ³»¸°´Ù.
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// SkillÀÌ ¿Ã¶ú´Ù´Â °ÍÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}*/


void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue) {
	int iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// ±â¼ú ¼öÁØÀÌ 0ÀÌ¶ó¸é ½ºÅ³Àº ¿À¸£Áö ¾Ê´Â´Ù.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;

	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1 ];

	// ¸¸¾à SkillSSNÀÌ Á¦ÇÑÄ¡¸¦ ³Ñ¾î¼¹´Ù¸é Skill°ªÀÌ Áõ°¡ÇÑ´Ù.
	if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
			  (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {

		// ½ºÅ³ÀÌ ¿Ã¶ú´Ù.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;
		// Æ¯¼ºÄ¡ Á¦ÇÑÀÌ ÀÖ´Â SkillÀ» Ã³¸®ÇÑ´Ù.
		switch (sSkillIndex) {
			case 0:
			case 5:
			case 13:
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
					// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 3:
				// ¸¶¹ý ÀúÇ×Àº ÃÖ´ë Level*2¸¸Å­ ¿À¸¥´Ù.
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
					// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 4:
			case 21:
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag)* 2)) {
					// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 1:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iDex) * 2)) {
					// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 2:
			case 12:
			case 14:
			case 15:
			case 19:
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)* 2)) {
					// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			case 23: // µ¶¼º ÀúÇ×
				if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
					// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
					m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
				} else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;

			default:
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
				break;
		}

		// ¸¸¾à ¹«±â¿Í °ü·ÃÀÖ´Â ½ºÅ³ÀÌ ¿Ã¶ú°í ÇöÀç ±× ¹«±â¸¦ »ç¿ë ÁßÀÌ¶ó¸é ÇöÀç ¸íÁß·ü¿¡ 1À» ´õÇÑ´Ù.
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ä«¿îÆ®°¡ 0ÀÌ¸é ½ºÅ³ÀÌ Á¤»óÀûÀ¸·Î ¿Ã¶ú´Ù´Â ÀÇ¹Ì.
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù.
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù.
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù.
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù.
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÀÇ ÃÑÇÕÀÌ 700À» ³ÑÀ¸¸é ´Ù¸¥ ½ºÅ³Áß ÇÏ³ª¸¦ 1 ³»¸°´Ù.
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);

			// SkillÀÌ ¿Ã¶ú´Ù´Â °ÍÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

void CGame::MobGenerator() {
	register int i, x, j, iNamingValue, iResult, iTotalMob;
	char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
	char cSA;
	int pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iNpcID;
	BOOL bMaster, bFirmBerserk, bIsSpecialEvent;

	if (m_bOnExitProcess == TRUE) return;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		// Random Mob Generator

		/*
		iResultNum = 0;
		// v1.432 ??? ??????????????? ?????? ??? ?????? ??? ??????. 1000???????? 100%  ??? 50%
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE)) {
		// ???????? ?????? ??? ????? ???.
		if (m_iTotalGameServerClients >= 1000) {
		iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}
		else {
		dV2 = (double)m_iTotalGameServerClients;
		dV3 = (m_pMapList[i]->m_iMaximumObject - 30);

		dV1 = (dV2 / 1000.0f)*dV3;
		iResultNum = (int)dV1;
		}

			if ((m_pMapList[i]->m_bIsHeldenianMap == TRUE) && (m_bIsHeldenianMode == TRUE)) break;
			else if ((m_pMapList[i]->m_bIsHeldenianMap == TRUE) && (m_bHeldenianInitiated == TRUE)) break;

		// v1.432 ??? ???
		iMin = (m_pMapList[i]->m_iMaximumObject - 30) - ((m_pMapList[i]->m_iMaximumObject - 30)/3);
		if (iResultNum > (m_pMapList[i]->m_iMaximumObject - 30)) iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		if (iResultNum < iMin) iResultNum = iMin;
		}
		 */

		//if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) &&
		//	 ((m_pMapList[i]->m_iMaximumObject - 30) > m_pMapList[i]->m_iTotalActiveObject) ) {

		if (m_pMapList[i] != NULL) {
			//if (m_bIsCrusadeMode == TRUE)
			//	 iResultNum = (m_pMapList[i]->m_iMaximumObject - 30) / 3;
			//else iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}

		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject)) {
			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;

			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				// Master Mob????????.
				std::memset(cName_Master, 0, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;

				std::memset(cNpcName, 0, sizeof(cNpcName));

				bFirmBerserk = FALSE;
				iResult = iDice(1, 100);
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {

					case 1: // arefarm, elvfarm, aresden, elvine
						if ((iResult >= 1) && (iResult < 20)) {
							iResult = 1; // Slime
						} else if ((iResult >= 20) && (iResult < 40)) {
							iResult = 2; // Giant-Ant
						} else if ((iResult >= 40) && (iResult < 85)) {
							iResult = 24; // Rabbit
						} else if ((iResult >= 85) && (iResult < 95)) {
							iResult = 25; // Cat
						} else if ((iResult >= 95) && (iResult <= 100)) {
							iResult = 3; // Orc
						}
						iMapLevel = 1;
						break;

					case 2:
						if ((iResult >= 1) && (iResult < 40)) {
							iResult = 1;
						} else if ((iResult >= 40) && (iResult < 80)) {
							iResult = 2;
						} else iResult = 10;
						iMapLevel = 1;
						break;

					case 3: // v1.4334 ????????? ????
						if ((iResult >= 1) && (iResult < 20)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 3;
									break;
								case 2: iResult = 4;
									break;
							}
						} else if ((iResult >= 20) && (iResult < 25)) {
							iResult = 30;
						} else if ((iResult >= 25) && (iResult < 50)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 5;
									break;
								case 2: iResult = 6;
									break;
								case 3: iResult = 7;
									break;
							}
						} else if ((iResult >= 50) && (iResult < 75)) {
							switch (iDice(1, 7)) {
								case 1:
								case 2: iResult = 8;
									break;
								case 3: iResult = 11;
									break;
								case 4: iResult = 12;
									break;
								case 5: iResult = 18;
									break;
								case 6: iResult = 26;
									break;
								case 7: iResult = 28;
									break;
							}
						} else if ((iResult >= 75) && (iResult <= 100)) {
							switch (iDice(1, 5)) {
								case 1:
								case 2: iResult = 9;
									break;
								case 3: iResult = 13;
									break;
								case 4: iResult = 14;
									break;
								case 5: iResult = 27;
									break;
							}
						}
						iMapLevel = 3;
						break;

					case 4:
						if ((iResult >= 1) && (iResult < 50)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 2;
									break;
								case 2: iResult = 10;
									break;
							}
						} else if ((iResult >= 50) && (iResult < 80)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 8;
									break;
								case 2: iResult = 11;
									break;
							}
						} else if ((iResult >= 80) && (iResult <= 100)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 14;
									break;
								case 2: iResult = 9;
									break;
							}
						}
						iMapLevel = 2;
						break;

					case 5:
						if ((iResult >= 1) && (iResult < 30)) {
							switch (iDice(1, 5)) {
								case 1:
								case 2:
								case 3:
								case 4:
								case 5: iResult = 2;
									break;
							}
						} else if ((iResult >= 30) && (iResult < 60)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 3;
									break;
								case 2: iResult = 4;
									break;
							}
						} else if ((iResult >= 60) && (iResult < 80)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 5;
									break;
								case 2: iResult = 7;
									break;
							}
						} else if ((iResult >= 80) && (iResult < 95)) {
							switch (iDice(1, 3)) {
								case 1:
								case 2: iResult = 8;
									break;
								case 3: iResult = 11;
									break;
							}
						} else if ((iResult >= 95) && (iResult <= 100)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 11;
									break;
								case 2: iResult = 14;
									break;
								case 3: iResult = 9;
									break;
							}
						}
						iMapLevel = 3;
						break;

					case 6: // huntzone3, huntzone4
						if ((iResult >= 1) && (iResult < 60)) {
							switch (iDice(1, 4)) {
								case 1: iResult = 5;
									break; // Skeleton
								case 2: iResult = 6;
									break; // Orc-Mage
								case 3: iResult = 12;
									break; // Cyclops
								case 4: iResult = 11;
									break; // Troll
							}
						} else if ((iResult >= 60) && (iResult < 90)) {
							switch (iDice(1, 5)) {
								case 1:
								case 2: iResult = 8;
									break; // Stone-Golem
								case 3: iResult = 11;
									break; // Troll
								case 4: iResult = 12;
									break; // Cyclops
								case 5: iResult = 43;
									break; // Tentocle
							}
						} else if ((iResult >= 90) && (iResult <= 100)) {
							switch (iDice(1, 9)) {
								case 1: iResult = 26;
									break;
								case 2: iResult = 9;
									break;
								case 3: iResult = 13;
									break;
								case 4: iResult = 14;
									break;
								case 5: iResult = 18;
									break;
								case 6: iResult = 28;
									break;
								case 7: iResult = 27;
									break;
								case 8: iResult = 29;
									break;
							}
						}
						iMapLevel = 4;
						break;

					case 7: // areuni, elvuni
						if ((iResult >= 1) && (iResult < 50)) {
							switch (iDice(1, 5)) {
								case 1: iResult = 3;
									break; // Orc
								case 2: iResult = 6;
									break; // Orc-Mage
								case 3: iResult = 10;
									break; // Amphis
								case 4: iResult = 3;
									break; // Orc
								case 5: iResult = 50;
									break; // Giant-Tree
							}
						} else if ((iResult >= 50) && (iResult < 60)) {
							iResult = 29; // Rudolph
						} else if ((iResult >= 60) && (iResult < 85)) {
							switch (iDice(1, 4)) {
								case 1: iResult = 50;
									break; // Giant-Tree
								case 2:
								case 3: iResult = 6;
									break; // Orc-Mage
								case 4: iResult = 12;
									break; // Troll
							}
						} else if ((iResult >= 85) && (iResult <= 100)) {
							switch (iDice(1, 4)) {
								case 1: iResult = 12;
									break; // Troll
								case 2:
								case 3:
									if (iDice(1, 100) < 3)
										iResult = 17; // Unicorn
									else iResult = 12; // Troll
									break;
								case 4: iResult = 29;
									break; // Cannibal-Plant
							}
						}
						iMapLevel = 4;
						break;

					case 8:
						if ((iResult >= 1) && (iResult < 70)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 4;
									break;
								case 2: iResult = 5;
									break;
							}
						} else if ((iResult >= 70) && (iResult < 95)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 8;
									break;
								case 2: iResult = 11;
									break;
							}
						} else if ((iResult >= 95) && (iResult <= 100)) {
							iResult = 14;
							break;
						}
						iMapLevel = 4;
						break;

					case 9:
						if ((iResult >= 1) && (iResult < 70)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 4;
									break;
								case 2: iResult = 5;
									break;
							}
						} else if ((iResult >= 70) && (iResult < 95)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 8;
									break;
								case 2: iResult = 9;
									break;
								case 3: iResult = 13;
									break;
							}
						} else if ((iResult >= 95) && (iResult <= 100)) {
							switch (iDice(1, 6)) {
								case 1:
								case 2:
								case 3: iResult = 9;
									break;
								case 4:
								case 5: iResult = 14;
									break;
								case 6: iResult = 15;
									break;
							}
						}

						if ((iDice(1, 3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
						iMapLevel = 5;
						break;

					case 10:
						if ((iResult >= 1) && (iResult < 70)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 9;
									break;
								case 2: iResult = 5;
									break;
								case 3: iResult = 8;
									break;
							}
						} else if ((iResult >= 70) && (iResult < 95)) {
							switch (iDice(1, 3)) {
								case 1:
								case 2: iResult = 13;
									break;
								case 3: iResult = 14;
									break;
							}
						} else if ((iResult >= 95) && (iResult <= 100)) {
							switch (iDice(1, 3)) {
								case 1:
								case 2: iResult = 14;
									break;
								case 3: iResult = 15;
									break;
							}
						}
						// Demon?? Berserk ????? ??? ?????
						if ((iDice(1, 3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
						iMapLevel = 5;
						break;

					case 11:
						if ((iResult >= 1) && (iResult < 30)) {
							switch (iDice(1, 5)) {
								case 1:
								case 2:
								case 3:
								case 4:
								case 5: iResult = 2;
									break;
							}
						} else if ((iResult >= 30) && (iResult < 60)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 3;
									break;
								case 2: iResult = 4;
									break;
							}
						} else if ((iResult >= 60) && (iResult < 80)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 5;
									break;
								case 2: iResult = 7;
									break;
							}
						} else if ((iResult >= 80) && (iResult < 95)) {
							switch (iDice(1, 3)) {
								case 1:
								case 2: iResult = 10;
									break;
								case 3: iResult = 11;
									break;
							}
						} else if ((iResult >= 95) && (iResult <= 100)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 11;
									break;
								case 2: iResult = 7;
									break;
								case 3: iResult = 8;
									break;
							}
						}
						iMapLevel = 4;
						break;

					case 12:
						if ((iResult >= 1) && (iResult < 50)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 1;
									break;
								case 2: iResult = 2;
									break;
								case 3: iResult = 10;
									break;
							}
						} else if ((iResult >= 50) && (iResult < 85)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 5;
									break;
								case 2: iResult = 4;
									break;
							}
						} else if ((iResult >= 85) && (iResult <= 100)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 8;
									break;
								case 2: iResult = 11;
									break;
								case 3: iResult = 26;
									break;
							}
						}
						iMapLevel = 4;
						break;

					case 13:
						if ((iResult >= 1) && (iResult < 15)) {
							iResult = 4;
							bFirmBerserk = TRUE;
							iTotalMob = 4 - (iDice(1, 2) - 1);
							break;
						} else if ((iResult >= 15) && (iResult < 40)) {
							iResult = 14;
							bFirmBerserk = TRUE;
							iTotalMob = 4 - (iDice(1, 2) - 1);
							break;
						} else if ((iResult >= 40) && (iResult < 60)) {
							iResult = 9;
							bFirmBerserk = TRUE;
							iTotalMob = 4 - (iDice(1, 2) - 1);
							break;
						} else if ((iResult >= 60) && (iResult < 75)) {
							iResult = 13;
							bFirmBerserk = TRUE;
							iTotalMob = 4 - (iDice(1, 2) - 1);
							break;
						} else if ((iResult >= 75) && (iResult < 95)) {
							iResult = 23;
						} else if ((iResult >= 95) && (iResult <= 100)) {
							iResult = 22;
						}
						iMapLevel = 5;
						break;

					case 14: // icebound
						if ((iResult >= 1) && (iResult < 30)) {
							iResult = 23; // Dark-Elf
						} else if ((iResult >= 30) && (iResult < 50)) {
							iResult = 31; // Ice-Golem
						} else if ((iResult >= 50) && (iResult < 70)) {
							iResult = 22; // Beholder
							bFirmBerserk = TRUE;
							iTotalMob = 4 - (iDice(1, 2) - 1);
						} else if ((iResult >= 70) && (iResult < 90)) {
							iResult = 32; // DireBoar
						} else if ((iResult >= 90) && (iResult <= 100)) {
							iResult = 33; // Frost
						}
						iMapLevel = 5;
						break;

					case 15:
						if ((iResult >= 1) && (iResult < 35)) {
							iResult = 23;
							bFirmBerserk = TRUE;
						} else if ((iResult >= 35) && (iResult < 50)) {
							iResult = 22;
							bFirmBerserk = TRUE;
						} else if ((iResult >= 50) && (iResult < 80)) {
							iResult = 15;
						} else if ((iResult >= 80) && (iResult <= 100)) {
							iResult = 21;
						}
						iMapLevel = 4;
						break;

					case 16: // 2ndmiddle, huntzone1, huntzone2,
						if ((iResult >= 1) && (iResult < 40)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 7;
									break; // Scorpion
								case 2: iResult = 2;
									break; // Giant-Ant
								case 3: iResult = 10;
									break; // Amphis
							}
						} else if ((iResult >= 40) && (iResult < 50)) {
							iResult = 30; // Rudolph
						} else if ((iResult >= 50) && (iResult < 85)) {
							switch (iDice(1, 2)) {
								case 1: iResult = 5;
									break; // Skeleton
								case 2: iResult = 4;
									break; // Zombie
							}
						} else if ((iResult >= 85) && (iResult <= 100)) {
							switch (iDice(1, 3)) {
								case 1: iResult = 8;
									break; // Stone-Golem
								case 2: iResult = 11;
									break; // Clay-Golem
								case 3: iResult = 7;
									break; // Scorpion
							}
						}
						iMapLevel = 1;
						break;

					case 17:
						if ((iResult >= 1) && (iResult < 30)) {
							switch (iDice(1, 4)) {
								case 1: iResult = 22;
									break; // Giant-Frog
								case 2: iResult = 8;
									break; // Stone-Golem
								case 3: iResult = 24;
									break; // Rabbit
								case 4: iResult = 5;
									break;
							}
						} else if ((iResult >= 30) && (iResult < 40)) {
							iResult = 30;
						} else if ((iResult >= 40) && (iResult < 70)) {
							iResult = 32;
						} else if ((iResult >= 70) && (iResult < 90)) {
							iResult = 31;
							if (iDice(1, 5) == 1) {
								bFirmBerserk = TRUE;
							}
						} else if ((iResult >= 90) && (iResult <= 100)) {
							iResult = 33;
						}
						iMapLevel = 1;
						break;

					case 18: // druncncity
						if ((iResult >= 1) && (iResult < 2)) {
							iResult = 39; // Tentocle
						} else if ((iResult >= 2) && (iResult < 12)) {
							iResult = 44; // ClawTurtle
						} else if ((iResult >= 12) && (iResult < 50)) {
							iResult = 48; // Nizie
						} else if ((iResult >= 50) && (iResult < 80)) {
							iResult = 45; // Giant-Crayfish
						} else if ((iResult >= 80) && (iResult < 90)) {
							iResult = 34; // Stalker
						} else if ((iResult >= 90) && (iResult <= 100)) {
							iResult = 26; // Giant-Frog
						}
						iMapLevel = 4;
						break;

					case 19:
						if ((iResult >= 1) && (iResult < 15)) {
							iResult = 44;
						} else if ((iResult >= 15) && (iResult < 25)) {
							iResult = 46;
						} else if ((iResult >= 25) && (iResult < 35)) {
							iResult = 21;
						} else if ((iResult >= 35) && (iResult < 60)) {
							iResult = 43;
						} else if ((iResult >= 60) && (iResult < 85)) {
							iResult = 23;
						} else if ((iResult >= 85) && (iResult <= 100)) {
							iResult = 22;
						}
						iMapLevel = 4;
						break;

					case 20:
						if ((iResult >= 1) && (iResult < 2)) {
							iResult = 41;
						} else if ((iResult >= 2) && (iResult < 3)) {
							iResult = 40;
						} else if ((iResult >= 3) && (iResult < 8)) {
							iResult = 53;
						} else if ((iResult >= 8) && (iResult < 9)) {
							iResult = 39;
						} else if ((iResult >= 9) && (iResult < 20)) {
							iResult = 21;
						} else if ((iResult >= 20) && (iResult < 35)) {
							iResult = 16;
						} else if ((iResult >= 35) && (iResult < 45)) {
							iResult = 44;
						} else if ((iResult >= 45) && (iResult < 55)) {
							iResult = 45;
						} else if ((iResult >= 55) && (iResult < 75)) {
							iResult = 28;
						} else if ((iResult >= 75) && (iResult < 95)) {
							iResult = 43;
						} else if ((iResult >= 95) && (iResult < 100)) {
							iResult = 22;
						}
						iMapLevel = 4;
						break;

					case 21:
						if ((iResult >= 1) && (iResult < 94)) {
							iResult = 17; // Unicorn
							bFirmBerserk = TRUE;
						} else if ((iResult >= 94) && (iResult < 95)) {
							iResult = 36; // Wyvern
						} else if ((iResult >= 95) && (iResult < 96)) {
							iResult = 37; // Fire-Wyvern
						} else if ((iResult >= 96) && (iResult < 97)) {
							iResult = 47; // MasterMage-Orc
						} else if ((iResult >= 97) && (iResult < 98)) {
							iResult = 35; // Hellclaw
						} else if ((iResult >= 98) && (iResult < 99)) {
							iResult = 49; // Tigerworm
						} else if ((iResult >= 99) && (iResult <= 100)) {
							iResult = 51; // Abaddon
						}
						iMapLevel = 4;
						break;

				}

				pX = NULL;
				pY = NULL;

				//				bIsSpecialEvent = TRUE;
				if ((m_bIsSpecialEventTime == TRUE) && (iDice(1, 10) == 3)) bIsSpecialEvent = TRUE;

				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
						case 1:
							if (m_pMapList[i]->m_iMaxPx != 0) {
								pX = m_pMapList[i]->m_iMaxPx * 20 + 10;
								pY = m_pMapList[i]->m_iMaxPy * 20 + 10;

								if (pX < 0) pX = 0;
								if (pY < 0) pY = 0;

								if (m_bIsCrusadeMode == TRUE) {
									if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
										switch (iDice(1, 6)) {
											case 1: iResult = 20;
												break;
											case 2: iResult = 53;
												break;
											case 3: iResult = 55;
												break;
											case 4: iResult = 57;
												break;
											case 5: iResult = 59;
												break;
											case 6: iResult = 61;
												break;
										} else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
										switch (iDice(1, 6)) {
											case 1: iResult = 19;
												break;
											case 2: iResult = 52;
												break;
											case 3: iResult = 54;
												break;
											case 4: iResult = 56;
												break;
											case 5: iResult = 58;
												break;
											case 6: iResult = 60;
												break;
										}
								}
								wsprintf(G_cTxt, "(!) Mob-Event Map(%s)[%d (%d,%d)]", m_pMapList[i]->m_cName, iResult, pX, pY);
							}
							break;

						case 2:
							if (iDice(1, 3) == 2) {
								if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7) == 0) ||
										  (memcmp(m_pMapList[i]->m_cLocationName, "middled1n", 9) == 0) ||
										  (memcmp(m_pMapList[i]->m_cLocationName, "arefarm", 7) == 0) ||
										  (memcmp(m_pMapList[i]->m_cLocationName, "elvfarm", 7) == 0) ||
										  (memcmp(m_pMapList[i]->m_cLocationName, "elvine", 6) == 0)) {
									if (iDice(1, 30) == 5)
										iResult = 16;
									else iResult = 5;
								} else iResult = 16;
							} else iResult = 17;

							m_bIsSpecialEventTime = FALSE;
							break;
					}
				}

				std::memset(cNpcName, 0, sizeof(cNpcName));
				//Random Monster Spawns
				switch (iResult) {
					case 1: strcpy(cNpcName, "Slime");
						iNpcID = 10;
						iProbSA = 5;
						iKindSA = 1;
						break;
					case 2: strcpy(cNpcName, "Giant-Ant");
						iNpcID = 16;
						iProbSA = 10;
						iKindSA = 2;
						break;
					case 3: strcpy(cNpcName, "Orc");
						iNpcID = 14;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 4: strcpy(cNpcName, "Zombie");
						iNpcID = 18;
						iProbSA = 15;
						iKindSA = 3;
						break;
					case 5: strcpy(cNpcName, "Skeleton");
						iNpcID = 11;
						iProbSA = 35;
						iKindSA = 8;
						break;
					case 6: strcpy(cNpcName, "Orc-Mage");
						iNpcID = 14;
						iProbSA = 30;
						iKindSA = 7;
						break;
					case 7: strcpy(cNpcName, "Scorpion");
						iNpcID = 17;
						iProbSA = 15;
						iKindSA = 3;
						break;
					case 8: strcpy(cNpcName, "Stone-Golem");
						iNpcID = 12;
						iProbSA = 25;
						iKindSA = 5;
						break;
					case 9: strcpy(cNpcName, "Cyclops");
						iNpcID = 13;
						iProbSA = 35;
						iKindSA = 8;
						break;
					case 10: strcpy(cNpcName, "Amphis");
						iNpcID = 22;
						iProbSA = 20;
						iKindSA = 3;
						break;
					case 11: strcpy(cNpcName, "Clay-Golem");
						iNpcID = 23;
						iProbSA = 20;
						iKindSA = 5;
						break;
					case 12: strcpy(cNpcName, "Troll");
						iNpcID = 28;
						iProbSA = 25;
						iKindSA = 3;
						break;
					case 13: strcpy(cNpcName, "Orge");
						iNpcID = 29;
						iProbSA = 25;
						iKindSA = 1;
						break;
					case 14: strcpy(cNpcName, "Hellbound");
						iNpcID = 27;
						iProbSA = 25;
						iKindSA = 8;
						break;
					case 15: strcpy(cNpcName, "Liche");
						iNpcID = 30;
						iProbSA = 30;
						iKindSA = 8;
						break;
					case 16: strcpy(cNpcName, "Demon");
						iNpcID = 31;
						iProbSA = 20;
						iKindSA = 8;
						break;
					case 17: strcpy(cNpcName, "Unicorn");
						iNpcID = 32;
						iProbSA = 35;
						iKindSA = 7;
						break;
					case 18: strcpy(cNpcName, "WereWolf");
						iNpcID = 33;
						iProbSA = 25;
						iKindSA = 1;
						break;
					case 19: strcpy(cNpcName, "YB-Aresden");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 20: strcpy(cNpcName, "YB-Elvine");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 21: strcpy(cNpcName, "Gagoyle");
						iNpcID = 52;
						iProbSA = 20;
						iKindSA = 8;
						break;
					case 22: strcpy(cNpcName, "Beholder");
						iNpcID = 53;
						iProbSA = 20;
						iKindSA = 5;
						break;
					case 23: strcpy(cNpcName, "Dark-Elf");
						iNpcID = 54;
						iProbSA = 20;
						iKindSA = 3;
						break;
					case 24: strcpy(cNpcName, "Rabbit");
						iNpcID = -1;
						iProbSA = 5;
						iKindSA = 1;
						break;
					case 25: strcpy(cNpcName, "Cat");
						iNpcID = -1;
						iProbSA = 10;
						iKindSA = 2;
						break;
					case 26: strcpy(cNpcName, "Giant-Frog");
						iNpcID = 57;
						iProbSA = 10;
						iKindSA = 2;
						break;
					case 27: strcpy(cNpcName, "Mountain-Giant");
						iNpcID = 58;
						iProbSA = 25;
						iKindSA = 1;
						break;
					case 28: strcpy(cNpcName, "Ettin");
						iNpcID = 59;
						iProbSA = 20;
						iKindSA = 8;
						break;
					case 29: strcpy(cNpcName, "Cannibal-Plant");
						iNpcID = 60;
						iProbSA = 20;
						iKindSA = 5;
						break;
					case 30: strcpy(cNpcName, "Rudolph");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 5;
						break;
					case 31: strcpy(cNpcName, "Ice-Golem");
						iNpcID = 65;
						iProbSA = 35;
						iKindSA = 8;
						break;
					case 32: strcpy(cNpcName, "DireBoar");
						iNpcID = 62;
						iProbSA = 20;
						iKindSA = 5;
						break;
					case 33: strcpy(cNpcName, "Frost");
						iNpcID = 63;
						iProbSA = 30;
						iKindSA = 8;
						break;
					case 34: strcpy(cNpcName, "Stalker");
						iNpcID = 48;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 35: strcpy(cNpcName, "Hellclaw");
						iNpcID = 49;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 36: strcpy(cNpcName, "Wyvern");
						iNpcID = 66;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 37: strcpy(cNpcName, "Fire-Wyvern");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 38: strcpy(cNpcName, "Barlog");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 39: strcpy(cNpcName, "Tentocle");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 40: strcpy(cNpcName, "Centaurus");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 41: strcpy(cNpcName, "Giant-Lizard");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 42: strcpy(cNpcName, "Minotaurs");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 43: strcpy(cNpcName, "Tentocle");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 44: strcpy(cNpcName, "Claw-Turtle");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 45: strcpy(cNpcName, "Giant-Crayfish");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 46: strcpy(cNpcName, "Giant-Plant");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 47: strcpy(cNpcName, "MasterMage-Orc");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 48: strcpy(cNpcName, "Nizie");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 49: strcpy(cNpcName, "Tigerworm");
						iNpcID = 50;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 50: strcpy(cNpcName, "Giant-Plant");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 51: strcpy(cNpcName, "Abaddon");
						iNpcID = -1;
						iProbSA = 20;
						iKindSA = 1;
						break;
					case 52: strcpy(cNpcName, "YW-Aresden");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 53: strcpy(cNpcName, "YW-Elvine");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 54: strcpy(cNpcName, "YY-Aresden");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 55: strcpy(cNpcName, "YY-Elvine");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 56: strcpy(cNpcName, "XB-Aresden");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 57: strcpy(cNpcName, "XB-Elvine");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 58: strcpy(cNpcName, "XW-Aresden");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 59: strcpy(cNpcName, "XW-Elvine");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 60: strcpy(cNpcName, "XY-Aresden");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					case 61: strcpy(cNpcName, "XY-Elvine");
						iNpcID = -1;
						iProbSA = 15;
						iKindSA = 1;
						break;
					default: strcpy(cNpcName, "Orc");
						iNpcID = 14;
						iProbSA = 15;
						iKindSA = 1;
						break;
				}

				cSA = 0;
				if (iDice(1, 100) <= iProbSA) {
					cSA = _cGetSpecialAbility(iKindSA);
				}

				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				} else {

				}
			}

			switch (iResult) {
				case 1: iTotalMob = iDice(1, 5) - 1;
					break;
				case 2: iTotalMob = iDice(1, 5) - 1;
					break;
				case 3: iTotalMob = iDice(1, 5) - 1;
					break;
				case 4: iTotalMob = iDice(1, 3) - 1;
					break;
				case 5: iTotalMob = iDice(1, 3) - 1;
					break;

				case 6: iTotalMob = iDice(1, 3) - 1;
					break;
				case 7: iTotalMob = iDice(1, 3) - 1;
					break;
				case 8: iTotalMob = iDice(1, 2) - 1;
					break;
				case 9: iTotalMob = iDice(1, 2) - 1;
					break;
				case 10: iTotalMob = iDice(1, 5) - 1;
					break;
				case 11: iTotalMob = iDice(1, 3) - 1;
					break;
				case 12: iTotalMob = iDice(1, 5) - 1;
					break;
				case 13: iTotalMob = iDice(1, 3) - 1;
					break;
				case 14: iTotalMob = iDice(1, 2) - 1;
					break;
				case 15: iTotalMob = iDice(1, 3) - 1;
					break;
				case 16: iTotalMob = iDice(1, 2) - 1;
					break;
				case 17: iTotalMob = iDice(1, 2) - 1;
					break;

				case 18: iTotalMob = iDice(1, 5) - 1;
					break;
				case 19: iTotalMob = iDice(1, 2) - 1;
					break;
				case 20: iTotalMob = iDice(1, 2) - 1;
					break;
				case 21: iTotalMob = iDice(1, 5) - 1;
					break;
				case 22: iTotalMob = iDice(1, 2) - 1;
					break;
				case 23: iTotalMob = iDice(1, 2) - 1;
					break;

				case 24: iTotalMob = iDice(1, 4) - 1;
					break;
				case 25: iTotalMob = iDice(1, 2) - 1;
					break;
				case 26: iTotalMob = iDice(1, 3) - 1;
					break;
				case 27: iTotalMob = iDice(1, 3) - 1;
					break;

				case 28: iTotalMob = iDice(1, 3) - 1;
					break;
				case 29: iTotalMob = iDice(1, 5) - 1;
					break;
				case 30: iTotalMob = iDice(1, 3) - 1;
					break;
				case 31: iTotalMob = iDice(1, 3) - 1;
					break;

				case 32: iTotalMob = 1;
					break;
				case 33: iTotalMob = 1;
					break;
				case 34: iTotalMob = 1;
					break;
				case 35: iTotalMob = 1;
					break;
				case 36: iTotalMob = 1;
					break;

				case 37: iTotalMob = 1;
					break;
				case 38: iTotalMob = 1;
					break;
				case 39: iTotalMob = 1;
					break;
				case 40: iTotalMob = 1;
					break;
				case 41: iTotalMob = 1;
					break;

				case 42: iTotalMob = iDice(1, 3) - 1;
					break;
				case 43: iTotalMob = 1;
					break;
				case 44: iTotalMob = iDice(1, 3) - 1;
					break;
				case 45: iTotalMob = 1;
					break;
				default: iTotalMob = 0;
					break;
			}

			if (bMaster == FALSE) iTotalMob = 0;

			if (iTotalMob > 2) {
				switch (iResult) {
					case 1: // Slime
					case 2: // Giant-Ant
					case 3: // Orc
					case 4: // Zombie
					case 5: // Skeleton
					case 6: // Orc-Mage
					case 7: // Scorpion
					case 8: // Stone-Golem
					case 9: // Cyclops
					case 10: // Amphis
					case 11: // Clay-Golem
					case 12: // Troll
					case 13: // Orge
					case 14: // Hellbound
					case 15: // Liche
					case 16: // Demon
					case 17: // Unicorn
					case 18: // WereWolf
					case 19:
					case 20:
					case 21:
					case 22:
					case 23:
					case 24:
					case 25:
					case 26:
					case 27:
					case 28:
					case 29:
					case 30:
					case 31:
					case 32:
						if (iDice(1, 5) == 1) iTotalMob = 0; // 75% ???????? ???.
						break;

					case 33:
					case 34:
					case 35:
					case 36:
					case 37:
					case 38:
					case 39:
					case 40:
					case 41:
					case 42:
					case 44:
					case 45:
					case 46:
					case 47:
					case 48:
					case 49:
						if (iDice(1, 5) != 1) iTotalMob = 0; // 75% ???????????????
						break;
				}
			}

			if (bIsSpecialEvent == TRUE) {
				switch (m_cSpecialEventType) {
					case 1:
						if ((iResult != 35) && (iResult != 36) && (iResult != 37) && (iResult != 49)
								  && (iResult != 51) && (iResult != 15) && (iResult != 16) && (iResult != 21)) iTotalMob = 12;
						for (x = 1; x < DEF_MAXCLIENTS; x++)
							if ((iNpcID != -1) && (m_pClientList[x] != NULL) && (m_pClientList[x]->m_bIsInitComplete == TRUE)) {
								SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, NULL, NULL, NULL);
							}
						break;

					case 2:
						if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7) == 0) ||
								  (memcmp(m_pMapList[i]->m_cLocationName, "elvine", 6) == 0) ||
								  (memcmp(m_pMapList[i]->m_cLocationName, "elvfarm", 7) == 0) ||
								  (memcmp(m_pMapList[i]->m_cLocationName, "arefarm", 7) == 0)) {
							iTotalMob = 0;
						}
						break;
				}
				m_bIsSpecialEventTime = FALSE;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					std::memset(cName_Slave, 0, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = 95; // original '_';
					cName_Slave[1] = i + 65;

					cSA = 0;

					if (iDice(1, 100) <= iProbSA) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					} else {
						bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		}

		if ((m_pMapList[i] != NULL) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject)) {
			for (j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++)
				if ((iDice(1, 3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
						  (m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs)) {
					iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
					if (iNamingValue != -1) {

						std::memset(cNpcName, 0, sizeof(cNpcName));
						switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
								// spot-mob-generator
							case 10: strcpy(cNpcName, "Slime");
								iProbSA = 5;
								iKindSA = 1;
								break;
							case 16: strcpy(cNpcName, "Giant-Ant");
								iProbSA = 10;
								iKindSA = 2;
								break;
							case 14: strcpy(cNpcName, "Orc");
								iProbSA = 15;
								iKindSA = 1;
								break;
							case 18: strcpy(cNpcName, "Zombie");
								iProbSA = 15;
								iKindSA = 3;
								break;
							case 11: strcpy(cNpcName, "Skeleton");
								iProbSA = 35;
								iKindSA = 8;
								break;
							case 6: strcpy(cNpcName, "Orc-Mage");
								iProbSA = 30;
								iKindSA = 7;
								break;
							case 17: strcpy(cNpcName, "Scorpion");
								iProbSA = 15;
								iKindSA = 3;
								break;
							case 12: strcpy(cNpcName, "Stone-Golem");
								iProbSA = 25;
								iKindSA = 5;
								break;
							case 13: strcpy(cNpcName, "Cyclops");
								iProbSA = 35;
								iKindSA = 8;
								break;
							case 22: strcpy(cNpcName, "Amphis");
								iProbSA = 20;
								iKindSA = 3;
								break;
							case 23: strcpy(cNpcName, "Clay-Golem");
								iProbSA = 20;
								iKindSA = 5;
								break;
							case 24: strcpy(cNpcName, "Guard-Aresden");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 25: strcpy(cNpcName, "Guard-Elvine");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 26: strcpy(cNpcName, "Guard-Neutral");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 27: strcpy(cNpcName, "Hellbound");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 29: strcpy(cNpcName, "Orge");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 30: strcpy(cNpcName, "Liche");
								iProbSA = 30;
								iKindSA = 8;
								break;
							case 31: strcpy(cNpcName, "Demon");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 32: strcpy(cNpcName, "Unicorn");
								iProbSA = 35;
								iKindSA = 7;
								break;
							case 33: strcpy(cNpcName, "WereWolf");
								iProbSA = 25;
								iKindSA = 1;
								break;
							case 34: strcpy(cNpcName, "Dummy");
								iProbSA = 5;
								iKindSA = 1;
								break;
							case 35: strcpy(cNpcName, "Attack-Dummy");
								iProbSA = 5;
								iKindSA = 1;
								break;
							case 48: strcpy(cNpcName, "Stalker");
								iProbSA = 20;
								iKindSA = 3;
								break;
								/*									case 49:
								if (iDice(1,144000) == 13) {
								strcpy(cNpcName,"Hellclaw");
								iProbSA = 20;
								iKindSA = 8;
								}
								break;
								case 50:
								if (iDice(1, 3606) == 135) {
								strcpy(cNpcName,"Tigerworm");
								iProbSA = 20;
								iKindSA = 8;
								}
								else {
								strcpy(cNpcName, "Stalker");
								iProbSA = 15;
								iKindSA = 1;
								}
								break;*/
							case 49: strcpy(cNpcName, "Hellclaw");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 50: strcpy(cNpcName, "Tigerworm");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 54: strcpy(cNpcName, "Dark-Elf");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 53: strcpy(cNpcName, "Beholder");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 52: strcpy(cNpcName, "Gagoyle");
								iProbSA = 20;
								iKindSA = 8;
								break;
								/*									case 40:
								if (iDice(1, 3606) == 135) {
								strcpy(cNpcName,"Hellclaw");
								iProbSA = 20;
								iKindSA = 8;
								}
								break;*/
							case 57: strcpy(cNpcName, "Giant-Frog");
								iProbSA = 10;
								iKindSA = 2;
								break;
							case 58: strcpy(cNpcName, "Mountain-Giant");
								iProbSA = 25;
								iKindSA = 1;
								break;
							case 59: strcpy(cNpcName, "Ettin");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 60: strcpy(cNpcName, "Cannibal-Plant");
								iProbSA = 20;
								iKindSA = 5;
								break;
							case 61: strcpy(cNpcName, "Rudolph");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 62: strcpy(cNpcName, "DireBoar");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 63: strcpy(cNpcName, "Frost");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 65: strcpy(cNpcName, "Ice-Golem");
								iProbSA = 20;
								iKindSA = 8;
								break;
							case 66: strcpy(cNpcName, "Wyvern");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 55: strcpy(cNpcName, "Rabbit");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 67: strcpy(cNpcName, "McGaffin");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 68: strcpy(cNpcName, "Perry");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 69: strcpy(cNpcName, "Devlin");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 73: strcpy(cNpcName, "Fire-Wyvern");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 70: strcpy(cNpcName, "Barlog");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 80: strcpy(cNpcName, "Tentocle");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 71: strcpy(cNpcName, "Centaurus");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 75: strcpy(cNpcName, "Giant-Lizard");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 78: strcpy(cNpcName, "Minotaurs");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 81: strcpy(cNpcName, "Abaddon");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 72: strcpy(cNpcName, "Claw-Turtle");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 74: strcpy(cNpcName, "Giant-Crayfish");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 76: strcpy(cNpcName, "Giant-Plant");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 77: strcpy(cNpcName, "MasterMage-Orc");
								iProbSA = 20;
								iKindSA = 1;
								break;
							case 79: strcpy(cNpcName, "Nizie");
								iProbSA = 20;
								iKindSA = 1;
								break;
							default:
								strcpy(cNpcName, "Orc");
								iProbSA = 15;
								iKindSA = 1;
								break;
						}
						/* NPCs not spawning in pits:
						case 56:  strcpy(cNpcName,"Cat");				iProbSA = 15; iKindSA = 6;  break;
						case 28:  strcpy(cNpcName, "Troll");			iProbSA = 25; iKindSA = 3; break;

						// 15 ShopKeeper-W
						// 19 Gandlf
						// 20 Howard
						// 36 Arrow Gaurd Tower Kit - Aresden, Elvine
						// 37 Cannon Gaurd Tower Kit - Aresden, Elvine
						// 38 Mana Collector Kit - Aresden, Elvine
						// 39 Detector Constructor Kit - Aresden, Elvine
						// 40 Energy Shield Generator - Aresden, Elvine
						// 41 Grand Master Generator - Aresden Elvine
						// 43 Light War Beetle - Aresden, Elvine
						// 44 God's Hand Knight
						// 45 Mounted God's Hand Knight
						// 46 Temple Knight
						// 47 Battle Golem
						// 51 Catapult
						// 64 Crops
						 */
						bFirmBerserk = FALSE;
						if ((iMapLevel == 5) && (iDice(1, 3) == 1)) bFirmBerserk = TRUE;

						std::memset(cName_Master, 0, sizeof(cName_Master));
						wsprintf(cName_Master, "XX%d", iNamingValue);
						cName_Master[0] = 95; // original '_';
						cName_Master[1] = i + 65;

						cSA = 0;
						if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1, 100) <= iProbSA)) {
							cSA = _cGetSpecialAbility(iKindSA);
						}

						switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
							case 1:
								if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
									m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
								} else {
									m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
								}
								break;

							case 2:
								if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
									m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
								} else {
									m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
								}
								break;
						}
					}
				}
		}
	}
}

void CGame::CalcNextWayPointDestination(int iNpcH) {
	short sRange, sX, sY;
	register int i, j, iMapIndex;
	BOOL bFlag;

	switch (m_pNpcList[iNpcH]->m_cMoveType) {
		case DEF_MOVETYPE_GUARD:
			// ÁöÁ¤µÈ À§Ä¡¸¦ ¹þ¾î³ªÁö ¾ÊÀ¸¸ç Ãß°ÝÀÌ ³¡³­ ÈÄ¿¡ µ¹¾Æ¿Â´Ù.
			break;

		case DEF_MOVETYPE_SEQWAYPOINT:

			m_pNpcList[iNpcH]->m_cCurWaypoint++;
			if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
				m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
			m_pNpcList[iNpcH]->m_dX = (short) (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
			m_pNpcList[iNpcH]->m_dY = (short) (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:

			m_pNpcList[iNpcH]->m_cCurWaypoint = (short) ((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
			m_pNpcList[iNpcH]->m_dX = (short) (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
			m_pNpcList[iNpcH]->m_dY = (short) (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
			break;

		case DEF_MOVETYPE_RANDOMAREA:

			sRange = (short) (m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
			m_pNpcList[iNpcH]->m_dX = (short) ((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
			sRange = (short) (m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
			m_pNpcList[iNpcH]->m_dY = (short) ((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
			break;

		case DEF_MOVETYPE_RANDOM:
			// ¿ÏÀü ·£´ý
			//m_pNpcList[iNpcH]->m_dX = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX - 50)) + 15;
			//m_pNpcList[iNpcH]->m_dY = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY - 50)) + 15;
			iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

			for (i = 0; i <= 30; i++) {
				// °¥ ¼ö ÀÖ´Â ÁÂÇ¥°¡ ³ª¿Ã¶§ ±îÁö 30¹ø ¹Ýº¹
				sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
				sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

				bFlag = TRUE;
				for (j = 0; j < DEF_MAXMGAR; j++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
						// ÇÇÇØ¾ß ÇÒ ÁÂÇ¥°¡ ÀÖ´Ù.
						if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
								  (sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
								  (sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
								  (sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {
							// Avoid Rect¾ÈÀÌ¹Ç·Î ÀÌ À§Ä¡¿¡´Â »ý¼º½ÃÅ³ ¼ö ¾ø´Ù.
							bFlag = FALSE;
						}
					}
				if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
			}
			// Fail!
			m_pNpcList[iNpcH]->m_tmp_iError = 0;
			return;

CNW_GET_VALIDLOC_SUCCESS:
			;
			m_pNpcList[iNpcH]->m_dX = sX;
			m_pNpcList[iNpcH]->m_dY = sY;
			break;
	}

	m_pNpcList[iNpcH]->m_tmp_iError = 0; // @@@ !!! @@@
}

void CGame::DeleteNpc(int iNpcH) {
	int i, iNamingValue, iNumItem, iItemID, iItemIDs[MAX_NPCITEMDROP], iSlateID;
	char cTmp[21], cItemName[21];
	class CItem * pItem, * pItem2;
	DWORD dwCount, dwTime;
	POINT ItemPositions[MAX_NPCITEMDROP];
	char cTemp[256];
	SYSTEMTIME SysTime;
	if (m_pNpcList[iNpcH] == NULL) return;

	dwTime = timeGetTime();

	//Init number of items to 1 unless its a multidrop;
	iNumItem = 0;
	iItemID = 0; // No current item

	//ì£½ì–´ìžˆë˜ ìœ„ì¹˜ì—ì„œ ì‚­ì œ 
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	std::memset(cTmp, 0, sizeof(cTmp));
	strcpy(cTmp, (char *) (m_pNpcList[iNpcH]->m_cName + 2));
	// NPCì˜ NamigValueë¥¼ ì–»ì–´ì™€ ì‚¬ìš©ì¤‘ì¸ í‘œì‹œë¥¼ í•´ì§€í•œë‹¤.
	iNamingValue = atoi(cTmp);

	// NamingValueë¥¼ ë¹„ìš°ê³  ë™ìž‘ì¤‘ì¸ ê°œì²´ ìˆ˜ë¥¼ ê°ì†Œì‹œí‚¨ë‹¤.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject--;

	// Spot-mob-generatorì •ë³´ 
	if (m_pNpcList[iNpcH]->m_iSpotMobIndex != NULL)
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	// í¬ë£¨ì„¸ì´ë“œìš© ê±´ì¶•ë¬¼ì´ë¼ë©´ ì§€íœ˜ê´€ í†µë³´ìš© ê±´ì¶•ë¬¼ ë¦¬ìŠ¤íŠ¸ë¥¼ í•´ì œ
	switch (m_pNpcList[iNpcH]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 42:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCrusadeStructureInfo(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// ê¸¸ë“œ ê±´ì¶•ë¬¼ ê°œìˆ˜ë„ ê°ì†Œì‹œí‚´ 
			for (i = 0; i < DEF_MAXGUILDS; i++)
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					m_pGuildTeleportLoc[i].m_iV2--;
					if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
					break;
				}
			break;
		case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum();
			break;

	}

	// DelayEventë¥¼ ì‚­ì œ 
	bRemoveFromDelayEventList(iNpcH, DEF_OWNERTYPE_NPC, NULL);
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == FALSE) && (m_pNpcList[iNpcH]->m_bIsUnsummoned == FALSE)) {
		// ì†Œí™˜ëª¹ì´ ì•„ë‹ˆë¼ë©´ ì—°ê¸ˆ ìž¬ë£Œê°€ ë‚˜ì˜¨ë‹¤.
		pItem = new class CItem;
		std::memset(cItemName, 0, sizeof(cItemName));
		switch (m_pNpcList[iNpcH]->m_sType) {

			case 10: // Slime
				if (iDice(1, 25) == 1) iItemID = 220;
				break; // SlimeJelly 
				break;

			case 11: // Skeleton
				switch (iDice(1, 2)) {
					case 1:if (iDice(1, 20) == 1) iItemID = 219;
						break; // SkeletonBones
					case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 12: // Stone-Golem
				switch (iDice(1, 2)) {
					case 1: if (iDice(1, 30) == 1) iItemID = 221;
						break; // StoneGolemPiece
					case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 13: // Cyclops
				switch (iDice(1, 6)) {
					case 1: if (iDice(1, 36) == 1) iItemID = 194;
						break; // CyclopsEye
					case 2: if (iDice(1, 40) == 1) iItemID = 195;
						break; // CyclopsHandEdge
					case 3: if (iDice(1, 30) == 1) iItemID = 196;
						break; // CyclopsHeart
					case 4: if (iDice(1, 22) == 1) iItemID = 197;
						break; // CyclopsMeat
					case 5: if (iDice(1, 40) == 1) iItemID = 198;
						break; // CyclopsLeather
					case 6: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 14: // Orc, Orc-Mage
				switch (iDice(1, 4)) {
					case 1: if (iDice(1, 11) == 1) iItemID = 206;
						break; // OrcMeat
					case 2: if (iDice(1, 20) == 1) iItemID = 207;
						break; // OrcLeather
					case 3: if (iDice(1, 21) == 1) iItemID = 208;
						break; // OrcTeeth
					case 4: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 16: //Giant-Ant
				switch (iDice(1, 3)) {
					case 1: if (iDice(1, 9) == 1) iItemID = 192;
						break; // AntLeg
					case 2: if (iDice(1, 10) == 1) iItemID = 193;
						break; // AntFeeler
					case 3: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 17: //Scorpion
				switch (iDice(1, 5)) {
					case 1: if (iDice(1, 50) == 1) iItemID = 215;
						break; // ScorpionPincers
					case 2: if (iDice(1, 20) == 1) iItemID = 216;
						break; // ScorpionMeat
					case 3: if (iDice(1, 50) == 1) iItemID = 217;
						break; // ScorpionSting
					case 4: if (iDice(1, 40) == 1) iItemID = 218;
						break; // ScorpionSkin
					case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 18: //Zombie
				bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
				break;
				break;

			case 22: //Amphis
				switch (iDice(1, 5)) {
					case 1: if (iDice(1, 15) == 1) iItemID = 188;
						break; // SnakeMeat
					case 2: if (iDice(1, 16) == 1) iItemID = 189;
						break; // SnakeSkin
					case 3: if (iDice(1, 16) == 1) iItemID = 190;
						break; // SnakeTeeth
					case 4: if (iDice(1, 17) == 1) iItemID = 191;
						break; // SnakeTongue
					case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 23: //Clay-Golem
				switch (iDice(1, 2)) {
					case 1: if (iDice(1, 30) == 1) iItemID = 205;
						break; // LumpofClay
					case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;


			case 27: //Hellbound
				switch (iDice(1, 7)) {
					case 1: if (iDice(1, 40) == 1) iItemID = 199;
						break; // HelboundHeart
					case 2: if (iDice(1, 38) == 1) iItemID = 200;
						break; // HelboundLeather
					case 3: if (iDice(1, 38) == 1) iItemID = 201;
						break; // HelboundTail
					case 4: if (iDice(1, 36) == 1) iItemID = 202;
						break; // HelboundTeeth
					case 5: if (iDice(1, 36) == 1) iItemID = 203;
						break; // HelboundClaw
					case 6: if (iDice(1, 50) == 1) iItemID = 204;
						break; // HelboundTongue
					case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 28: //Troll
				switch (iDice(1, 5)) {
					case 1: if (iDice(1, 35) == 1) iItemID = 222;
						break; // TrollHeart
					case 2: if (iDice(1, 23) == 1) iItemID = 223;
						break; // TrollMeat
					case 3: if (iDice(1, 25) == 1) iItemID = 224;
						break; // TrollLeather
					case 4: if (iDice(1, 27) == 1) iItemID = 225;
						break; // TrollClaw
					case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 29: //Orge
				switch (iDice(1, 7)) {
					case 1: if (iDice(1, 20) == 1) iItemID = 209;
						break; // OgreHair
					case 2: if (iDice(1, 22) == 1) iItemID = 210;
						break; // OgreHeart
					case 3: if (iDice(1, 25) == 1) iItemID = 211;
						break; // OgreMeat
					case 4: if (iDice(1, 25) == 1) iItemID = 212;
						break; // OgreLeather
					case 5: if (iDice(1, 28) == 1) iItemID = 213;
						break; // OgreTeeth
					case 6: if (iDice(1, 28) == 1) iItemID = 214;
						break; // OgreClaw
					case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 30: //Liche
				bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
				break;
				break;

			case 31: //Demon
				switch (iDice(1, 5)) {
					case 1: if (iDice(1, 400) == 123) iItemID = 541;
						break; // DemonHeart
					case 2: if (iDice(1, 1000) == 123) iItemID = 542;
						break; // DemonMeat
					case 3: if (iDice(1, 200) == 123) iItemID = 543;
						break; // DemonLeather
					case 4: if (iDice(1, 300) == 123) iItemID = 540;
						break; // DemonEye
					case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 32: //Unicorn
				switch (iDice(1, 5)) {
					case 1: if (iDice(1, 3000) == 396) iItemID = 544;
						break; // UnicornHeart
					case 2: if (iDice(1, 500) == 3) iItemID = 545;
						break; // UnicornHorn
					case 3: if (iDice(1, 100) == 3) iItemID = 546;
						break; // UnicornMeat
					case 4: if (iDice(1, 200) == 3) iItemID = 547;
						break; // UnicornLeather
					case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 33: //WereWolf
				switch (iDice(1, 8)) {
					case 1: if (iDice(1, 30) == 3) iItemID = 551;
						break; // WerewolfTail
					case 2: if (iDice(1, 28) == 3) iItemID = 548;
						break; // WerewolfHeart
					case 3: if (iDice(1, 25) == 3) iItemID = 550;
						break; // WerewolfMeat
					case 4: if (iDice(1, 35) == 3) iItemID = 553;
						break; // WerewolfLeather
					case 5: if (iDice(1, 28) == 3) iItemID = 552;
						break; // WerewolfTeeth
					case 6: if (iDice(1, 28) == 3) iItemID = 554;
						break; // WerewolfClaw
					case 7: if (iDice(1, 38) == 3) iItemID = 549;
						break; // WerewolfNail
					case 8: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
						break;
					default: break;
				}
				break;

			case 48: //Stalker
			case 49: //Hellclaw
			case 50: //Tigerworm
			case 52: //Gagoyle
			case 53: //Beholder
			case 54: //Dark-Elf
			case 55: //Rabbit
			case 56: //Cat
			case 57: //Giant-Frog
			case 58: //Mountain-Giant
			case 59: //Ettin
			case 60: //Cannibal-Plant
			case 61: //Rudolph
			case 62: //DireBoar
			case 63: //Frost
			case 65: //Ice
				bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType);
				break;

				// new 05/10/2004
			case 66: // Wyvern
				bGetMultipleItemNamesWhenDeleteNpc(m_pNpcList[iNpcH]->m_sType, // NPC Type
						  50, // È®·ü( ÃÖ¼Ò ~ ÃÖ´ë »çÀÌÀÇ ¾ÆÀÌÅÛÀÌ ³ª¿Ã È®·ü , 100 ÀÌ¸é ÃÖ´ë °¹¼ö ¸¸Å­ ³ª¿Â´Ù.)
						  5, // ³ª¿Í¾ß ÇÏ´Â Item ÃÖ¼Ò °³¼ö
						  15, // ³ª¿Ã¼ö ÀÖ´Â Item ÃÖ´ë °³¼ö
						  m_pNpcList[iNpcH]->m_sX, // ±âÁØ ÁÂÇ¥ X
						  m_pNpcList[iNpcH]->m_sY, // ±âÁØ ÁÂÇ¥ Y
						  DEF_ITEMSPREAD_FIXED, // ¾ÆÀÌÅÛ »Ñ¸®´Â ¹æ¹ý (RANDOM, FIXED)
						  4, // ¾ÆÀÌÅÛ »Ñ¸± ¹üÀ§, DEF_ITEMSPREAD_RANDOM ÀÏ¶§¸¸ »ç¿ë
						  iItemIDs, // ¹Þ¾Æ¿Ã ¾ÆÀÌÅÛ Idµé
						  ItemPositions, // ¾ÆÀÌÅÛµéÀÇ À§Ä¡
						  &iNumItem); // ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö
				break;

			case 73: // Fire-Wyvern
				bGetMultipleItemNamesWhenDeleteNpc(m_pNpcList[iNpcH]->m_sType, // NPC Type
						  50, // È®·ü( ÃÖ¼Ò ~ ÃÖ´ë »çÀÌÀÇ ¾ÆÀÌÅÛÀÌ ³ª¿Ã È®·ü , 100 ÀÌ¸é ÃÖ´ë °¹¼ö ¸¸Å­ ³ª¿Â´Ù.)
						  5, // ³ª¿Í¾ß ÇÏ´Â Item ÃÖ¼Ò °³¼ö
						  15, // ³ª¿Ã¼ö ÀÖ´Â Item ÃÖ´ë °³¼ö
						  m_pNpcList[iNpcH]->m_sX, // ±âÁØ ÁÂÇ¥ X
						  m_pNpcList[iNpcH]->m_sY, // ±âÁØ ÁÂÇ¥ Y
						  2, // ¾ÆÀÌÅÛ »Ñ¸®´Â ¹æ¹ý (RANDOM, FIXED)
						  4, // ¾ÆÀÌÅÛ »Ñ¸± ¹üÀ§, DEF_ITEMSPREAD_RANDOM ÀÏ¶§¸¸ »ç¿ë
						  iItemIDs, // ¹Þ¾Æ¿Ã ¾ÆÀÌÅÛ Idµé
						  ItemPositions, // ¾ÆÀÌÅÛµéÀÇ À§Ä¡
						  &iNumItem); // ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö
				break;
			case 81:
				bGetMultipleItemNamesWhenDeleteNpc(m_pNpcList[iNpcH]->m_sType, // NPC Type
						  50, // È®·ü( ÃÖ¼Ò ~ ÃÖ´ë »çÀÌÀÇ ¾ÆÀÌÅÛÀÌ ³ª¿Ã È®·ü , 100 ÀÌ¸é ÃÖ´ë °¹¼ö ¸¸Å­ ³ª¿Â´Ù.)
						  12, // ³ª¿Í¾ß ÇÏ´Â Item ÃÖ¼Ò °³¼ö
						  20, // ³ª¿Ã¼ö ÀÖ´Â Item ÃÖ´ë °³¼ö
						  m_pNpcList[iNpcH]->m_sX, // ±âÁØ ÁÂÇ¥ X
						  m_pNpcList[iNpcH]->m_sY, // ±âÁØ ÁÂÇ¥ Y
						  DEF_ITEMSPREAD_FIXED, // ¾ÆÀÌÅÛ »Ñ¸®´Â ¹æ¹ý (RANDOM, FIXED)
						  65, // ¾ÆÀÌÅÛ »Ñ¸± ¹üÀ§, DEF_ITEMSPREAD_RANDOM ÀÏ¶§¸¸ »ç¿ë
						  iItemIDs, // ¹Þ¾Æ¿Ã ¾ÆÀÌÅÛ Idµé
						  ItemPositions, // ¾ÆÀÌÅÛµéÀÇ À§Ä¡
						  &iNumItem);
				break;
		}

		dwCount = 1;
		if (iNumItem > 0) {
			GetLocalTime(&SysTime);
			wsprintf(cTemp, "%d%02d%", SysTime.wMonth, SysTime.wDay);
			for (int j = 0; j < iNumItem; j++) {
				if (pItem == NULL) {
					pItem = new class CItem;
				}
				if (_bInitItemAttr(pItem, iItemIDs[j]) == FALSE ||
						  m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bGetIsMoveAllowedTile(ItemPositions[j].x, ItemPositions[j].y) == FALSE) {
					delete pItem;
					pItem = NULL;
				} else {
					if (iItemIDs[j] == 90) // Gold
						pItem->m_dwCount = iDice(10, 15000);
					else
						pItem->m_dwCount = dwCount;

					pItem->m_sTouchEffectType = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1, 100000);
					pItem->m_sTouchEffectValue2 = iDice(1, 100000);
					pItem->m_sTouchEffectValue3 = (short) timeGetTime();
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(ItemPositions[j].x, ItemPositions[j].y, pItem);
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
							  ItemPositions[j].x, ItemPositions[j].y, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
					pItem = NULL;
				}
			}
		} else {
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				pItem = NULL;
			} else {
				pItem->m_dwCount = dwCount;

				pItem->m_sTouchEffectType = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1, 100000);
				pItem->m_sTouchEffectValue2 = iDice(1, 100000);
				pItem->m_sTouchEffectValue3 = (short) timeGetTime();
				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
						  m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
			}
		}

		if (iDice(1, 100000) < 10) {
			pItem2 = new class CItem;
			switch (iDice(1, 4)) {
				case 1: iSlateID = 868;
					break;
				case 2: iSlateID = 869;
					break;
				case 3: iSlateID = 870;
					break;
				case 4: iSlateID = 871;
					break;
			}
			if (_bInitItemAttr(pItem2, iSlateID) == FALSE) {
				delete pItem2;
				pItem2 = NULL;
			} else {
				pItem2->m_dwCount = 1;

				pItem2->m_sTouchEffectType = DEF_ITET_ID;
				pItem2->m_sTouchEffectValue1 = iDice(1, 100000);
				pItem2->m_sTouchEffectValue2 = iDice(1, 100000);
				pItem2->m_sTouchEffectValue3 = (short) timeGetTime();

				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
						  m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2->m_sSprite, pItem2->m_sSpriteFrame, pItem2->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem2);
			}
		}
	}

	delete m_pNpcList[iNpcH];
	m_pNpcList[iNpcH] = NULL;
}

void CGame::RequestFullObjectData(int iClientH, char *pData) {
	DWORD * dwp;
	WORD * wp, wObjectID;
	char * cp, cData[100];
	short * sp, sX, sY;
	int sTemp, sTemp2;
	int * ip, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	wp = (WORD *) (pData + DEF_INDEX2_MSGTYPE);
	wObjectID = *wp;

	std::memset(cData, 0, sizeof(cData));
	dwp = (DWORD *) (cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp = (WORD *) (cData + DEF_INDEX2_MSGTYPE);
	*wp = DEF_OBJECTSTOP;

	cp = (char *) (cData + DEF_INDEX2_MSGTYPE + 2);

	if (wObjectID < 10000) {
		// Ä³¸¯ÅÍÀÇ Á¤º¸¸¦ ¿øÇÑ´Ù.
		// Àß¸øµÈ ÀÎµ¦½º°ªÀÌ°Å³ª Á¸ÀçÇÏÁö ¾Ê´Â ÇÃ·¹ÀÌ¾î¶ó¸é ¹«½Ã.
		if ((wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS)) return;
		if (m_pClientList[wObjectID] == NULL) return;

		wp = (WORD *) cp;
		*wp = wObjectID; // ObjectID
		cp += 2;
		sp = (short *) cp;
		sX = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp = (short *) cp;
		sY = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		//v1.4 ApprColor
		ip = (int *) cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;

		ip = (int *) cp;

		// m_pClientList[i]¿Í m_pClientList[sOwnerH]ÀÇ °ü°è¸¦ ÀÔ·ÂÇÑ´Ù.
		// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù.
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp; //Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH); //(short)iGetPlayerRelationship(iClientH, wObjectID);
		sTemp = (sTemp | (sTemp2 << 28)); //Original : 12

		*ip = sTemp;
		//*sp = DEF_TEST;
		cp += 4; //Original 2

		if (m_pClientList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			*cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 41); // v1.4
	} else {
		// NPCÀÇ Á¤º¸¸¦ ¿øÇÑ´Ù.
		// Àß¸øµÈ ÀÎµ¦½º °ªÀÌ°Å³ª »ý¼ºµÇÁö ¾ÊÀº NPC¶ó¸é ¹«½Ã
		if (((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS)) return;
		if (m_pNpcList[wObjectID - 10000] == NULL) return;

		wp = (WORD *) cp;
		*wp = wObjectID;
		cp += 2;

		wObjectID -= 10000;

		sp = (short *) cp;
		sX = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp = (short *) cp;
		sY = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp = (short *) cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp = (short *) cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;

		ip = (int *) cp;

		sTemp = m_pNpcList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp; //Original : sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î

		sTemp2 = iGetNpcRelationship(wObjectID, iClientH);
		sTemp = (sTemp | (sTemp2 << 28)); //Original : 12
		*ip = sTemp;
		//*sp = DEF_TEST;
		cp += 4; //Original 2

		if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			*cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 27); // v1.4 //Original : 25
	}

	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH) {
	register int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

			// Arrow ¾ÆÀÌÅÛÀÌ 1°³ ÀÌ»ó ÀÖÀ¸¸é ÀÎµ¦½º °ªÀ» ¹ÝÈ¯ÇÑ´Ù.
			if ((m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
					  (m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0))
				return i;
		}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, BOOL bIsUseItemResult, BOOL bIsItemUsed) {
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((bIsItemUsed == 1) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_MATERIAL) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 380) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 381) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 382)) {
		_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], FALSE);
	} else if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 247) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 248)) {
		_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], FALSE);
	}
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int) bIsUseItemResult, NULL, NULL);
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	iCalcTotalWeight(iClientH);
}

void CGame::NpcBehavior_Stop(int iNpcH) {
	char cTargetType;
	short sTarget = NULL;
	BOOL bFlag;

	if (m_pNpcList[iNpcH] == NULL) return;

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
		case 5:
			switch (m_pNpcList[iNpcH]->m_sType) {
				case 38:
					if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						bFlag = _bNpcBehavior_ManaCollector(iNpcH);
						if (bFlag == TRUE) {
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1);
						}
					}
					break;

				case 39: // Detector
					if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						bFlag = _bNpcBehavior_Detector(iNpcH);

						if (bFlag == TRUE) {
							// ���� �߰��ߴ�. ��� �������� �˷��� �Ѵ�.
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1);
						}
					}
					break;

				case 40: // Energy Shield Generator
					break;

				case 41: // Grand Magic Generator
					if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						_NpcBehavior_GrandMagicGenerator(iNpcH);
					}
					break;

				case 42: // ManaStone: v2.05 ���������� ���������� �������� 5�� ���Ѵ�.
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[iNpcH]->m_iV1 += 5;
					if (m_pNpcList[iNpcH]->m_iV1 >= 5) m_pNpcList[iNpcH]->m_iV1 = 5;
					break;

				default:
					TargetSearch(iNpcH, &sTarget, &cTargetType);
					break;
			}
			break;
	}

	if ((sTarget != NULL)) {

		// ��ݸ�ǥ �߰�.
		m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
		// ���⼭ ǥȿ ���۰������� ���� �޽��� �߼�.
		return;
	}
}

void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID) {
	int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
	DWORD dwTime;
	short sTemp, sTmpType, sTmpAppr1;
	char cSlateType[20];

	dwTime = timeGetTime();
	std::memset(cSlateType, 0, sizeof(cSlateType));

	//testcode
	//wsprintf(G_cTxt, "%d", sDestItemID);
	//PutLogList(G_cTxt);

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)) {
	} else return;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
			  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT)) {

		// ¾ÆÀÌÅÛÀÇ È¿°ú¿¡ ¸Â´Â Ã³¸®¸¦ ÇÑ´Ù.
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_WARM: // v2.172 2002-7-5 �ص� �þ�.

				// �õ� ������ ��� �ص� �Ǿ�ٴ� �޼����� �����ش�.
				if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) {
					//	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);

					// ȿ�� ������ �� �߻��� ������ �̺�Ʈ�� ����Ѵ�.
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1 * 1000),
							  iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);


					//				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, NULL, NULL, NULL);
				}

				m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
				break;

			case DEF_ITEMEFFECTTYPE_LOTTERY:
				// º¹±Ç ¾ÆÀÌÅÛ EV1(È®·ü: ÃÖÀú 100) EV2(»óÇ° Á¾·ù) EV3(»óÇ° ¼ö·®)
				iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
				if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {
					// ´çÃ·!

				} else {
					// ²Î!

				}
				break;

			case DEF_ITEMEFFECTTYPE_SLATES:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
					// Full Ancient Slate ??
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) {
						// Slates dont work on Heldenian Map
						switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
							case 2: // Bezerk slate
								m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = TRUE;
								SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (1000 * 600),
										  iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, NULL, NULL);
								strcpy(cSlateType, "Berserk");
								break;

							case 1: // Invincible slate
								if (strlen(cSlateType) == 0) {
									strcpy(cSlateType, "Invincible");
								}
							case 3: // Mana slate
								if (strlen(cSlateType) == 0) {
									strcpy(cSlateType, "Mana");
								}
							case 4: // Exp slate
								if (strlen(cSlateType) == 0) {
									strcpy(cSlateType, "Exp");
								}
								SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2,
										  dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
									case 1:
										iEffectResult = 4;
										break;
									case 3:
										iEffectResult = 5;
										break;
									case 4:
										iEffectResult = 6;
										break;
								}
						}
						if (strlen(cSlateType) > 0)
							_bItemLog(DEF_ITEMLOG_USE, iClientH, strlen(cSlateType), m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					}
				}
				break;
			case DEF_ITEMEFFECTTYPE_HP:
				iMax = iGetMaxHP(iClientH);
				if (m_pClientList[iClientH]->m_iHP < iMax) {

					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
						iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
						iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
						iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
					} else {
						iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
						iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
						iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
					}

					m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3);
					if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
					if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

					iEffectResult = 1;
				}
				break;

			case DEF_ITEMEFFECTTYPE_MP:
				iMax = iGetMaxMP(iClientH);
				if (m_pClientList[iClientH]->m_iMP < iMax) {

					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
						iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
						iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
						iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
					} else {
						iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
						iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
						iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
					}

					m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3);
					if (m_pClientList[iClientH]->m_iMP > iMax)
						m_pClientList[iClientH]->m_iMP = iMax;

					iEffectResult = 2;
				}
				break;

			case DEF_ITEMEFFECTTYPE_SP:
				iMax = iGetMaxSP(iClientH);
				if (m_pClientList[iClientH]->m_iSP < iMax) {

					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
						iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
						iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
						iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
					} else {
						iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
						iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
						iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
					}

					m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3);
					if (m_pClientList[iClientH]->m_iSP > iMax)
						m_pClientList[iClientH]->m_iSP = iMax;

					iEffectResult = 3;
				}

				if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {
					// Áßµ¶µÈ »óÅÂ¿´´Ù¸é Áßµ¶À» Ç¬´Ù.
					m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
					// Áßµ¶ÀÌ Ç®·ÈÀ½À» ¾Ë¸°´Ù.
					SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); // removes poison aura when using a revitalizing potion
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
				}
				break;

			case DEF_ITEMEFFECTTYPE_HPSTOCK:
				iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;

				m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
				if (m_pClientList[iClientH]->m_iHPstock < 0) m_pClientList[iClientH]->m_iHPstock = 0;
				if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

				// ¹è°íÇÄÀ» ÇØ°áÇÑ´Ù.
				m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
				if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
				if (m_pClientList[iClientH]->m_iHungerStatus < 0) m_pClientList[iClientH]->m_iHungerStatus = 0;
				break;

			case DEF_ITEMEFFECTTYPE_REPPLUS:
				iMax = 10000;
				if (m_pClientList[iClientH]->m_iRating < iMax) m_pClientList[iClientH]->m_iRating += 1;
				iEffectResult = 7;
				break;

			case DEF_ITEMEFFECTTYPE_STUDYSKILL:
				// ±â¼úÀ» ¹è¿î´Ù.
				iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
				// iV1Àº ¹è¿ï Skill ¹øÈ£. iV2´Â ±â¼ú ¼öÁØ, iSEV1Àº »ç¿ëÀÚ Á¤ÀÇ ±â¼ú ¼öÁØ(¿ì¼±¼øÀ§)
				if (iSEV1 == 0) {
					// »ç¿ëÀÚ Á¤ÀÇ ±â¼ú¼öÁØÀÌ 0ÀÌ¶ó¸é Ç¥ÁØ ±â¼ú¼öÁØ¿¡ µû¶ó ±â¼úÀ» ¹è¿ì°Ô µÈ´Ù.
					TrainSkillResponse(TRUE, iClientH, iV1, iV2);
				} else {
					TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
				}
				break;

			case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
				// iV1Àº ¹è¿ï ¸¶¹ý ¹øÈ£.
				iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				if (m_pMagicConfigList[iV1] != NULL)
					RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, FALSE);
				break;

			case DEF_ITEMEFFECTTYPE_ADDBALLPOINTS:
				char cInfoString[56];
				iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_iBallPoints += iV1;

				wsprintf(cInfoString, "%d Ball Points added. Total Amount: %d ", iV1, m_pClientList[iClientH]->m_iBallPoints);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);

				break;

				/*case DEF_ITEMEFFECTTYPE_LOTTERY:
					iLottery = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->
					break;*/

				// New 15/05/2004 Changed
			case DEF_ITEMEFFECTTYPE_MAGIC:
				// Åõ¸í ¸ðµå¿´´Ù¸é ¸¶¹ý È¿°ú ¾ÆÀÌÅÛ »ç¿ë½Ã¿¡ ÇØÁ¦µÈ´Ù.
				if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
					if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
						SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

						bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
						m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					}
				}

				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
					case 1:
						// Recall ¸¶¹ý È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ.
						// testcode
						if (bCheckIfIsFlagCarrier(iClientH)) ShowClientMsg(iClientH, "You can not use that item being a flag carrier.");
						else RequestTeleportHandler(iClientH, "1   ");
						break;

					case 2:
						// Åõ¸í ¸¶¹ýÈ¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ.
						if (bCheckIfIsFlagCarrier(iClientH)) ShowClientMsg(iClientH, "You can not use that item being a flag carrier.");
						else PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE);
						break;

					case 3:
						// Åõ¸í ¸¶¹ý Ã£±â. »çÅõÀå ³»ºÎ¸é ¼Ò¿ë¾ø´Ù.
						if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
							PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE);
						break;

					case 4:
						// fixed location teleportation: ÀÔÀå±Ç µîµî
						switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
							case 1:
								// ºí¸®µù ¾ÆÀÏ·Î °£´Ù
								if (bCheckIfIsFlagCarrier(iClientH)) ShowClientMsg(iClientH, "You can not use that item being a flag carrier.");
								else {
									if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
										ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);
										RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
									}
								}

								break;


							case 11:
							case 12:
							case 13:
							case 14:
							case 15:
							case 16:
							case 17:
							case 18:
							case 19:
								// °áÅõÀåÀ¸·Î °£´Ù.
								SYSTEMTIME SysTime;

								GetLocalTime(&SysTime);
								// v1.4311-3 º¯°æ ÀÔÀå±Ç Ã¼Å© ´Þ/³¯Â¥/½Ã°£À¸·Î Ã¼Å©ÇÑ´Ù.
								// ÀÔÀå °¡´ÉÇÑ ½Ã°£º¸´Ù ÀÛ°Å³ª °°À¸¸é ÀÔÀå±ÇÀÌ »ç¶óÁø´Ù.
								if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) ||
										  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
										  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour)) {
									// ³¯Â¥°¡ Á¤È®ÇÏÁö ¾Ê´Ù. ¾Æ¹«·± È¿°ú°¡ ¾ø°í ÀÔÀå±ÇÀº »ç¶óÁø´Ù.
								} else {
									char cDestMapName[11];
									std::memset(cDestMapName, 0, sizeof(cDestMapName));
									wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
									if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
										//v1.42
										ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);
										RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
									}
								}
								break;
						}
						break;

					case 5:
						// new
						if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == 0) break;
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "GodH", 4) == 0) break;
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 > 8) {
							if ((m_bHeldenianInitiated == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE)) {
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
										  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
							}
						}
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
								  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
						break;
				}
				break;

			case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20 * 30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20 * 30; // ÃÖ´ë 30ºÐ°£
				break;

			case DEF_ITEMEFFECTTYPE_CHANGEATTR:
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
					case 1:
						// ¸Ó¸® »öÀ» ¹Ù²Û´Ù.
						m_pClientList[iClientH]->m_cHairColor++;
						if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

						sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
						m_pClientList[iClientH]->m_sAppr1 = sTemp;
						break;

					case 2:
						// ¸Ó¸® ½ºÅ¸ÀÏÀ» ¹Ù²Û´Ù.
						m_pClientList[iClientH]->m_cHairStyle++;
						if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

						sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
						m_pClientList[iClientH]->m_sAppr1 = sTemp;
						break;

					case 3:
						// ÇÇºÎ»öÀ» ¹Ù²Û´Ù.
						// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
						m_pClientList[iClientH]->m_cSkin++;
						if (m_pClientList[iClientH]->m_cSkin > 3)
							m_pClientList[iClientH]->m_cSkin = 1;

						if (m_pClientList[iClientH]->m_cSex == 1) sTemp = 1;
						else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4;

						switch (m_pClientList[iClientH]->m_cSkin) {
							case 2: sTemp += 1;
								break;
							case 3: sTemp += 2;
								break;
						}
						m_pClientList[iClientH]->m_sType = sTemp;
						break;

					case 4:
						// ¼ºÀüÈ¯ - ¸¸¾à ¿ÊÀ» ÀÔ°í ÀÖ´Ù¸é ½ÇÆÐÇÑ´Ù.
						sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
						if (sTemp == 0) {
							// sTemp°¡ 0ÀÌ ¾Æ´Ï¶ó¸é °Ñ¿Ê, ¼Ó¿Ê, ¹ÙÁöÁß ÇÑ°¡Áö¸¦ ÀÔ°í ÀÖ´Â °ÍÀÌ´Ù. ¼ºÀüÈ¯À» ÇÒ ¼ö ¾ø´Ù.
							if (m_pClientList[iClientH]->m_cSex == 1)
								m_pClientList[iClientH]->m_cSex = 2;
							else m_pClientList[iClientH]->m_cSex = 1;

							// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
							if (m_pClientList[iClientH]->m_cSex == 1) {
								// ³²ÀÚÀÌ´Ù.
								sTmpType = 1;
							} else if (m_pClientList[iClientH]->m_cSex == 2) {
								// ¿©ÀÚÀÌ´Ù.
								sTmpType = 4;
							}

							switch (m_pClientList[iClientH]->m_cSkin) {
								case 1:
									// ¹éÀÎÀÌ¸é ±×´ë·Î.
									break;
								case 2:
									sTmpType += 1;
									break;
								case 3:
									sTmpType += 2;
									break;
							}

							sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
							m_pClientList[iClientH]->m_sType = sTmpType;
							m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;
							//
						}
						break;
				}

				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
		// *** Request Teleport Handler°¡ ÀÛµ¿µÇ¸é ÀÌ¹Ì µ¥ÀÌÅÍ ÀúÀåÀÌ ¿äÃ»µÈ »óÅÂÀÌ¹Ç·Î ÀÌÈÄ¿¡ ¾ÆÀÌÅÛÀ» ¾ø¾ÖºÁ¾ß ¼Ò¿ëÀÌ ¾ø´Ù.
		// ¾ÆÀÌÅÛÀ» ¸ÕÀú ¾ø¾Ø´Ù.
		ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);

		switch (iEffectResult) {
			case 1:
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				break;
			case 2:
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
				break;
			case 3:
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
				break;
			case 4: // Invincible
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_INVINCIBLE, NULL, NULL, NULL, NULL);
				break;
			case 5: // Mana
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_MANA, NULL, NULL, NULL, NULL);
				break;
			case 6: // EXP
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_EXP, NULL, NULL, NULL, NULL);
				break;
			default:
				break;
			case 7: //Rep
				char cRepMessage[60];
				wsprintf(cRepMessage, "You have Earned 1 Rep Point.");
				ShowClientMsg(iClientH, cRepMessage);
				break;
		}
	} else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
		// »ç¿ëÇÏ¸é¼­ ¸ñÇ¥ÁöÁ¡À» ÁöÁ¤ÇÏ´Â ¾ÆÀÌÅÛ.
		// dX, dYÀÇ ÁÂÇ¥°¡ À¯È¿ ¹üÀ§ ³»¿¡ ÀÖ´ÂÁö È®ÀÎÇØ¾ß ÇÑ´Ù.
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE)
			ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);
	} else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
		// È­»ìÀ» ÇÒ´çÇÑ´Ù.
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	} else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) {
		// ¿µ±¸È÷ ¾µ ¼ö ÀÖ´Â ¾ÆÀÌÅÛ. Áï ¾²°í³ªµµ ¾ø¾îÁöÁö ¾Ê´Â ¾ÆÀÌÅÛ. (ex: Áöµµ)
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
				iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				switch (iV1) {
					case 1:
						// ÇöÀç ÀÚ½ÅÀÇ À§Ä¡¸¦ º¸¿©ÁØ´Ù.
						if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, NULL, NULL);
						else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, NULL, NULL);
						else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
						break;
				}
				break;
		}
	} else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {
		// ±â¼ú°ú °ü·ÃµÈ ¾ÆÀÌÅÛÀ» »ç¿ëÇÑ´Ù. ¾ÆÀÌÅÛÀÇ ¼ö¸íÀ» ³·Ãß°í µô·¹ÀÌ ÀÌº¥Æ®¿¡ µî·ÏÇÑ´Ù.

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) ||
				  (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
				  (m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] == TRUE)) {
			// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù Çß°Å³ª ¾ø°Å³ª °ü·Ã ½ºÅ³À» »ç¿ëÁßÀÌ¶ó¸é ¹«½Ã
			return;
		} else {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0) {
				// ÃÖ´ë ¼ö¸íÀÌ 0ÀÌ¸é »ç¿ëÇØµµ ¼ö¸íÀÌ ÁÙÁö ¾Ê´Â´Ù.
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù µÇ¾ú´Ù.
					// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				} else {
					// ±â¼ú »ç¿ë ½Ã°£ ID°ªÀ» ±¸ÇÑ´Ù. v1.12
					int iSkillUsingTimeID = (int) timeGetTime();

					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill,
							  dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2 * 1000,
							  iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY,
							  m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, NULL);

					// ±â¼ú »ç¿ëÁß
					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = TRUE;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID; //v1.12
				}
			}
		}
	}
}

void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr) {
	int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iExp, iMaxSuperAttack, iRepDamage;
	char cAttackerSide, cDamageMoveDir;
	DWORD dwTime;
	register double dTmp1, dTmp2, dTmp3;
	short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY, sItemIndex;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) &&
			  (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1) && (m_bHeldenianInitiated == TRUE)) return;

	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
			if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
			if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
			if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {

					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
						float damageTemp = (float) iDamage;
						damageTemp *= 1.5; // O el valor con punto flotante que ustedes dispongan...

						iDamage = (int) damageTemp;
					}

					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
						if (m_pClientList[sAttackerH]->m_iRating > 0) {
							iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
							if (iRepDamage < 5) iRepDamage = 5;
							iDamage += iRepDamage;
						}
						if (cTargetType == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[sTargetH] != NULL) {
								if (m_pClientList[sTargetH]->m_iRating < 0) {
									iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 10);
									if (iRepDamage > 10) iRepDamage = 10;
									iDamage += iRepDamage;
								}
							}
						}
					}
				}
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
						if (cTargetType == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[sTargetH] != NULL) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 20);
								if (iRepDamage > 5) iRepDamage = 5;
								iDamage += iRepDamage;
							}
						}
					}
				}
			}

			if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

			dTmp1 = (double) iDamage;
			if ((m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double) (m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag);
			dTmp2 = dTmp2 / 3.3f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iDamage = (int) (dTmp3 + 0.5f);

			iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
			if (iDamage <= 0) iDamage = 0;

			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)
				iDamage += iDamage / 3;

			if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
				iDamage += iDamage / 3;
			}

			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
					iDamage += (iDamage * 7) / 10;
				} else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
					iDamage += iDamage / 2;
				} else
					iDamage += iDamage / 3;
			}


			cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
			sAtkX = m_pClientList[sAttackerH]->m_sX;
			sAtkY = m_pClientList[sAttackerH]->m_sY;
			iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
			break;

		case DEF_OWNERTYPE_NPC:
			cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
			sAtkX = m_pNpcList[sAttackerH]->m_sX;
			sAtkY = m_pNpcList[sAttackerH]->m_sY;
			break;
	}

	switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:

			if (m_pClientList[sTargetH] == NULL) return;
			if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
			if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

			if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) &&
					  (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) &&
					  (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation == TRUE)) return;

			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
			if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
			if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
			m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;



			if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
				if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
					iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
					if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

					} else {
						if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
							if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

							} else return;
						} else return;
					}
				}

				if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
			}

			ClearSkillUsingStatus(sTargetH);

			switch (iAttr) {
				case 1:
					if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
						dTmp1 = (double) iDamage;
						dTmp2 = (double) m_pClientList[sTargetH]->m_iAddAbsEarth;
						dTmp3 = (dTmp2 / 100.0f) * dTmp1;
						iDamage = iDamage - (int) (dTmp3);
						if (iDamage < 0) iDamage = 0;
					}
					break;

				case 2:
					if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
						dTmp1 = (double) iDamage;
						dTmp2 = (double) m_pClientList[sTargetH]->m_iAddAbsAir;
						dTmp3 = (dTmp2 / 100.0f) * dTmp1;
						iDamage = iDamage - (int) (dTmp3);
						if (iDamage < 0) iDamage = 0;
					}
					break;

				case 3:
					if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
						dTmp1 = (double) iDamage;
						dTmp2 = (double) m_pClientList[sTargetH]->m_iAddAbsFire;
						dTmp3 = (dTmp2 / 100.0f) * dTmp1;
						iDamage = iDamage - (int) (dTmp3);
						if (iDamage < 0) iDamage = 0;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
						dTmp1 = (double) iDamage;
						dTmp2 = (double) m_pClientList[sTargetH]->m_iAddAbsWater;
						dTmp3 = (dTmp2 / 100.0f) * dTmp1;
						iDamage = iDamage - (int) (dTmp3);
						if (iDamage < 0) iDamage = 0;
					}
					break;

				default: break;
			}

			iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
			if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {

				switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
					case 335:
						dTmp1 = (double) iDamage;
						dTmp2 = dTmp1 * 0.2f;
						dTmp3 = dTmp1 - dTmp2;
						iDamage = (int) (dTmp3 + 0.5f);
						break;

					case 337:
						dTmp1 = (double) iDamage;
						dTmp2 = dTmp1 * 0.1f;
						dTmp3 = dTmp1 - dTmp2;
						iDamage = (int) (dTmp3 + 0.5f);
						break;
				}
				if (iDamage <= 0) iDamage = 0;

				iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
				if (iRemainLife <= iDamage) {
					ItemDepleteHandler(sTargetH, iIndex, TRUE, TRUE);
				} else {
					m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				}
			}

			if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
				dTmp1 = (double) iDamage;
				dTmp2 = (double) m_pClientList[sTargetH]->m_iAddAbsMD;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int) dTmp3;
			}

			if (cTargetType == DEF_OWNERTYPE_PLAYER) {
				iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
				if (iDamage <= 0) iDamage = 0;
			}

			if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) &&
					  (iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
				iDamage = m_pClientList[sTargetH]->m_iHP - 1;
			}

			if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
				iDamage = iDamage / 2;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
				switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
					case 51:
					case 52:
						return;
				}
			}

			m_pClientList[sTargetH]->m_iHP -= iDamage;
			if (m_pClientList[sTargetH]->m_iHP <= 0) {
				ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);
			} else {
				if (iDamage > 0) {
					if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
						dTmp1 = (double) m_pClientList[sTargetH]->m_iAddTransMana;
						dTmp2 = (double) iDamage;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2 + 1.0f;

						iTemp = (2 * (m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag)) + (2 * m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iInt + m_pClientList[sTargetH]->m_iAngelicInt) / 2);
						m_pClientList[sTargetH]->m_iMP += (int) dTmp3;
						if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
					}

					if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
						if (iDice(1, 100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
							iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
							if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
						}
					}

					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

					if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
						m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
						m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					}

					if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
						m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}
			}

			sTgtX = m_pClientList[sTargetH]->m_sX;
			sTgtY = m_pClientList[sTargetH]->m_sY;
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sTargetH] == NULL) return;
			if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
			if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;

			sTgtX = m_pNpcList[sTargetH]->m_sX;
			sTgtY = m_pNpcList[sTargetH]->m_sY;

			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
				case 1:
				case 2:
					return;

				case 4:
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY) return;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					} else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY) cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					} else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY) cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						cDamageMoveDir = iDice(1, 8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX = dX;
					m_pNpcList[sTargetH]->m_sY = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						cDamageMoveDir = iDice(1, 8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX = dX;
					m_pNpcList[sTargetH]->m_sY = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
						DeleteNpc(sTargetH);
					}
					return;
			}

			if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
				switch (m_pNpcList[sTargetH]->m_sType) {
					case 40:
					case 41:
						if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
						break;
				}
			}

			switch (m_pNpcList[sTargetH]->m_sType) {
				case 67: // McGaffin
				case 68: // Perry
				case 69: // Devlin
					return;
			}

			if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
				dTmp1 = (double) iDamage;
				dTmp2 = (double) (m_pNpcList[sTargetH]->m_iAbsDamage) / 100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int) dTmp2;
				if (iDamage < 0) iDamage = 1;
			}

			if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
				iDamage = iDamage / 2;

			m_pNpcList[sTargetH]->m_iHP -= iDamage;
			if (m_pNpcList[sTargetH]->m_iHP < 0) {
				NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
			} else {
				switch (cAttackerType) {
					case DEF_OWNERTYPE_PLAYER:
						if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
								  && (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
						break;
				}

				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
					if ((cAttackerType == DEF_OWNERTYPE_NPC) &&
							  (m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
							  (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

					m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
					m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;

					m_pNpcList[sTargetH]->m_dwTime = dwTime;

					if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}

					if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) &&
							  (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							iExp = iDamage;
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double) m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double) iExp;
								dTmp3 = (dTmp1 / 100.0f) * dTmp2;
								iExp += (int) dTmp3;
							}

							if (m_pClientList[sAttackerH]->m_iLevel > 100) {
								switch (m_pNpcList[sTargetH]->m_sType) {
									case 55:
									case 56:
										iExp = 0;
										break;
									default: break;
								}
							}

							if (bExp == TRUE)
								GetExp(sAttackerH, iExp, TRUE);
							else GetExp(sAttackerH, (iExp / 2), TRUE);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						} else {
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double) m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double) iExp;
								dTmp3 = (dTmp1 / 100.0f) * dTmp2;
								iExp += (int) dTmp3;
							}

							if (m_pClientList[sAttackerH]->m_iLevel > 100) {
								switch (m_pNpcList[sTargetH]->m_sType) {
									case 55:
									case 56:
										iExp = 0;
										break;
									default: break;
								}
							}

							if (bExp == TRUE)
								GetExp(sAttackerH, iExp, TRUE);
							else GetExp(sAttackerH, (iExp / 2), TRUE);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}
					}
				}
			}
			break;
	}
}
